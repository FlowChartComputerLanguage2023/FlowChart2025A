



Option Strict On
Option Infer Off
Option Compare Text
Option Explicit On
'Imports System.Deployment.Application
Imports System.IO
Imports System.Net
Imports System.Reflection
Imports System.Reflection.Emit
Imports System.Runtime.ConstrainedExecution
Imports System.Runtime.InteropServices.ComTypes
Imports System.Runtime.Remoting.Messaging


'Imports System.Reflection
'Imports System.Runtime.ConstrainedExecution
Imports System.Text
Imports System.Windows
Imports System.Windows.Forms.AxHost
Imports System.Windows.Forms.Form
Imports System.Windows.Forms.LinkLabel
Imports System.Windows.Forms.VisualStyles.VisualStyleElement
Imports System.Xml.XPath

Class OLD

    Public Shared Sub Clear_Window(a As PictureBox)
        a.CreateGraphics.Clear(Color.LightYellow)
    End Sub
    Public Shared Sub DisplayStatus(A As Integer,
                            Optional B As String = "",
                            Optional C As String = "",
                            Optional D As String = "",
                            Optional E As String = "",
                            Optional F As String = "",
                            Optional G As String = "",
                            Optional H As String = "",
                            Optional I As String = "",
                            Optional J As String = "",
                            Optional K As String = "",
                            Optional L As String = "",
                            Optional M As String = "",
                            Optional N As String = "")
        Debug.Print(A.ToString & B & C & D & E & F & G & H & I & J & K & L & M & N)
    End Sub

    Public Shared DrillDownFileNames As ListBox
    Public Shared SplashScreenWindowText As String = "Splash Screen Text "
    Public Shared FileInputOutputWindow As PictureBox
    Public Shared FLOWCHARTNAME As String = "FlowChart"
    Public Shared INPUTTEXTBOX As String = "INPUTTEXTBOX"
    Public Shared FCWIDTH As Integer = Source.Width
    Public Shared FCHEIGHT As Integer = Source.Height



End Class



Module GetParts





    ']] > '
    '11008 ⬂⬃⬀⬁⬄⬅⬆⬇⬈⬉⬊⬋⬌⬍⬏

    'todo need to allow more versions of 0X0000, such as &0000
    ' 0x????, ????h, $0????, $0x????, %????, \x????, &h0000, 
    ' % URLs, # HTML, 0h, \x XML, 0X unix and C, $0x0000 AT&T, 0000h Intel MASM, 0X0000 GNU FASM NASM 

    '✅    ■²ⁿ√·∙°≈÷⌡⌠≤≥±≡  █
    '11010   ⬂ 2B02
    '11011   ⬃ 2B03
    '39     ' 0027
    '9989   ✅ 2705
    '160        00A0
    '9632   ■ 25A0
    '178    ² 00B2
    '8319   ⁿ 207F
    '8730   √ 221A
    '183    · 00B7
    '8729   ∙ 2219
    '176    ° 00B0
    '8776   ≈ 2248
    '247    ÷ 00F7
    '8993   ⌡ 2321
    '8992   ⌠ 2320
    '8804   ≤ 2264
    '8805   ≥ 2265
    '177    ± 00B1
    '8801   ≡ 2261
    '9608   █ 2588
    '219    █   00DB


    '    Public Class F_C
    Public Const VBSpace As String = " "
    Public Const DefaultDebugLevel1 As Integer = 4    'Is used when starting up the program
    Public Const DefaultDebugLevel2 As Integer = 2    'Is used when starting up the program

    'see also errorMessages.vb
    Public Const A_ERROR As Integer = 1                  'msgbox, log
    Public Const A_WARNING As Integer = 2                'msgbox, log
    Public Const A_NOTICE As Integer = 3                'msgbox, log
    Public Const A_INFORMATION As Integer = 4                'log
    Public Const A_DISPLAY As Integer = 5                'log
    Public Const A_STATUS As Integer = 6                'ignore 
    Public Const A_FLOWCHART As Integer = 7                'ERROR@(), log
    Public Const A_DEBUG As Integer = 8                'no msgbox, no log
    Public Const A_FMB As Integer = 9                'msgbox, log
    Public Const A_BUG As Integer = 10                    '

    Public Const ShowWindow As Integer = 1                           '1 means to show this form (in show All Forms()
    Public Const HideWindow As Integer = 0                           '0 means to hide this form 
    Public Const LeaveWindow As Integer = -1                         '0 do nothing with this for (but make it background, cause another form is visible)

    'not used 'Public Const SPECIALMARKER As Integer=127           ' this is used as a marker for replacements inside the program

    Public Const SecurityRun As Integer = 1                          ' 1 means they do something (disallow this program from running (just in case), disable all buttons.
    Public Const SecurityDemo As Integer = 2                       ' 2 means not demo
    Public Const SecuritySave As Integer = 3                         ' 3 means read only, they can not make changes to anything.(Or save anything?)
    Public Const SecurityChangeSymbol As Integer = 4                 ' 4 means student they can make changes to the Symbol.)Or save Symbols?
    Public Const Security5 As Integer = 5                            ' 5 is the level they are allowed (A-Z)
    Public Const Security6 As Integer = 6                            ' 6 is the level they are at.(A-Z)
    Public Const Security7 As Integer = 7
    Public Const SecurityFlowChartWindow As Integer = 8              'can display this window
    Public Const SecurityOptionsWindow As Integer = 9                'can display this window
    Public Const SecuritySymbolWindow As Integer = 10                'can display this window
    Public Const SecurityFileInputOutputWindow As Integer = 11       'can display this window
    Public Const SecurityStudent As Integer = 12                     '4 digits 15 and 12 can not be zero, because they tell the professional level of the user
    Public Const SecurityTeacher As Integer = 13                     '
    Public Const SecurityProgrammer As Integer = 14                  '
    Public Const SecurityExpert As Integer = 15                      '4 digits 15 and 12 can not be zero, because they tell the professional level of the user
    Public Const Security16 As Integer = 16


    Public Const StrLen As Integer = 256

    Public Const FollowNumberOfLines As Integer = 50



    '                                           These are the four (future) levels of the program

    Public TimerIndexFlowChartCounter As Integer = 1 ' This is only for the timers routines to know to go to the next Symbol/path

    'todo this should all go away
    Public TimeTrackStart(0) As Long
    Public TimeTracks(0) As Long
    Public TimeTrackName(0) As String
    Public TimeTrackCalled(0) As Long




    Const ConstantALLTables As Integer = 64
    Friend Const ConstantCharterLength As Integer = 16000
    Friend Const ConstantMaxFlowChartScale As Single = 32 'bigger scale makes the picture smaller and smaller 
    Friend Const ConstantMinFlowChartScale As Single = 0.0009765625    '0.0625
    Friend Const ConstantFlowChartScaleChange As Single = 1.5
    Friend Const NUMBEROPTIONS As Integer = 64

    Friend Const MyConstantIgnoreFunctionOperatorKeyWord As String = ChrW(&HFFFC) & ChrW(&HFFFD) & ChrW(&HFFFE)  '

    Friend Const FD As String = ","
    Friend Const COMMA As String = ", "   ' note that comma is a comma and a space, and is only used for displaying stuff
    '|~!@%^&*()_-+={[}]\:;'<,>.?/   ' Available special characters for make syntax between two  RMStart & MyUniverse.SysGen.Constants.RMEnd

    ' So That I can remember which is which Constants
    Friend Const ConstantCOME_FROM As Integer = 1
    Friend Const ConstantBranchToS As Integer = 0
    Friend Const ConstantBufferSizeBeforeChangingSizeOfArray As Integer = 64
    Friend Const ConstantMyErrorCode As Integer = -1




    'Public Options.ListBox_KeyWords(1) As String ' 2020/6/22 Changing to require from input file
    'Public Language_Function(1) As String ' 2020/6/22 Changing to require from input file
    Public Language_Operator(1) As String ' 2020/6/22 Changing to require from input file
    Public Language_Grammar(1) As String ' 2023/4/14 added to make syntax from (simple) BNF definition of
    Public Language_Blocks(1) As String ' 2023/4/14 added to make syntax from (simple) BNF definition of language 


    Public My_keyWord(32) As String
    Friend Const My_KeyConstUnknown As Integer = 0
    Friend Const My_KeyConstUnKnownError As Integer = 1
    Friend Const My_KeyConstName As Integer = 2
    Friend Const My_KeyConstPoint As Integer = 3
    Friend Const My_KeyConstLine As Integer = 4
    Friend Const My_KeyConstUse As Integer = 5
    Friend Const My_KeyConstPath As Integer = 6
    Friend Const My_KeyConstDataType As Integer = 7
    Friend Const My_KeyConstFileName As Integer = 8
    Friend Const My_KeyConstVersion As Integer = 9
    Friend Const My_KeyConstAuthor As Integer = 10
    Friend Const My_KeyConstLanguage As Integer = 11
    Friend Const My_KeyConstStroke As Integer = 12
    Friend Const My_KeyConstError As Integer = 13
    Friend Const My_KeyConstDelete As Integer = 14
    Friend Const My_KeyConstConstant As Integer = 15
    Friend Const My_KeyConstX1 As Integer = 16
    Friend Const My_KeyConstY1 As Integer = 17
    Friend Const My_KeyConstX2 As Integer = 18
    Friend Const My_KeyConstY2 As Integer = 19
    Friend Const My_KeyConstColor As Integer = 20
    Friend Const My_KeyConstMicroCodeText As Integer = 21
    Friend Const My_KeyConstNotes As Integer = 22
    Friend Const My_KeyConstOpcode As Integer = 23
    Friend Const My_KeyConstSyntax As Integer = 24
    Friend Const My_KeyConstOption As Integer = 25
    'Friend Const ? As Integer=26
    Friend Const My_KeyConstLanguageKeyWord As Integer = 27
    Friend Const My_KeyConstRAW As Integer = 28
    'friend const My_KeyConstUnused29 as Integer=29
    'friend const My_KeyConstUnused30 as Integer=30
    'friend const My_KeyConstUnused31 as Integer=31
    'friend const My_KeyConstUnused32 as Integer=32





    ' See Init () for the assignment because what is allowed is sometimes defined by what is in a ComboBox list
    'and it is a variable and not a Constant so that (in the future) it can be changed to allow different input and Output

    'formatAuthor = "/Author={}"
    Public formatAuthor As String = "/Author=name"

    'formatColor = "/Color=ColorName" & FD & " Alpha" & FD & " Red" & FD & " Green" & FD & " Blue" & FD & " Style" & FD & " StartCap" & FD & " EndCap"
    Public formatColor As String = "/Color=Color Name, Alpha, Red, Green, Blue, Style, StartCap, EndCap"

    'formatConstant = "/Constant=name " & FD & " X" & FD & " Y" & FD & " Value"
    Public formatConstant As String = "/Constant=name, X, Y, Value"

    'formatDataType = "/DataType=DataTypeName" & FD & " Number Of s" & FD & " Color Name" & FD & " Color Width" & FD & " Description"
    Public formatDataType As String = "/DataType=DataTypeName, Number Of Bytes, Color Name, Color Width, Description"

    'FormatDelete = "/Delete ... "
    Public FormatDelete As String = "/Delete= (Never used for input or output)"

    'FormatError = "/error=Code" & FD & " name" & FD & " x1" & FD & " y1" & FD & " Name " & FD & " {other things maybe}"
    Public FormatError As String = "/Error   ' Code, name, x1, y1, Name, {other things}"

    'FormatErrorMessage = "/FCCL_ErrorMessage =show/hide, Error #,{error or 1,wrong or 2,warning or 3,information or 4,display or 5,status or 6,flowchart or 7}, Format String ⬂string?⬃ ... "
    Public FormatErrorMessage As String = "/Message = text to be displayed"

    'FormatLanguage_KeyWord = "/Keyword=ReservedWord  {" & FD & "only one word" & FD & " no spaces allowed currently}"
    Public FormatLanguage_KeyWord As String = "/keyword=keyword  or /Keywords=keyword, keyword2, ... "

    'formatLanguage = "/language= Language Name, Dialect"
    Public formatLanguage As String = "/Language=Language class, Language dialect"

    'FormatLanguage_Function = "/Function=FunctionWord  " & FD & "only one function name no (), {}, [] etc " & FD
    Public FormatLanguage_Function As String = "/function=FunctionName  or /Functions = FunctionName1, FunctionName2, . . . "

    'FormatLanguage_Grammar = "/Grammar=GrammarName '::=' {GrammarName{,*,+,?,-}, 'Literal', |, 'character', 'character-character', (character range)} "
    Public FormatLanguage_Grammar As String = "/Grammar=GrammarName '::=' Simple BNF "

    'FormatLanguage_Operator = "/Operator=Operator  {" & FD & "only one operator ie: +" & FD & " no space allowed currently}  OR " & "/Operators=Operator (example +,-,*,&,^ comma delimited)"
    Public FormatLanguage_Operator As String = "/Operator=operator  or  /operators = operator1 , operator2 , operator3 ... "

    'formatLine = "/Line=x1" & FD & " y1" & FD & " x2" & FD & " y2" & FD & " Color"
    Public formatLine As String = "/Line=x1, y1, x2, y2, Color"
    Public formatLines As String = "/Lines=Color, x1, y1, x2, y2, x3, y3, x4, y4 ... "

    'FormatMacroText = "/MicroCodeText=OrderName, Text " & AddRM("replacements") & " text ... "
    Public FormatMacroText As String = "/MicroCodeText=Order section name, Text [replacements] text ... "

    'formatNameOfFile = "/FileName=Device:/Path/FileName.Extension"
    Public formatNameOfFile As String = "/FileName=Device:/Path/FileName.Extension"

    'formatNotes = "/Notes={}"
    Public formatNotes As String = "/Notes={}"

    'formatOpcode = "/OpCode={}"
    Public formatOpcode As String = "/OpCode={}"

    'FormatOption = "/Option=number" & FD & "{on or off}"
    Public FormatOption As String = "/Option=number, {on/off, Yes/No, 1/0, True,False}  or /Option = ComputerLanguage???? "

    'formatPath = "/Path=Name" & FD & " x1" & FD & " y1" & FD & " x2" & FD & " y2" & FD & " Data type"
    Public formatPath As String = "/Path=Name, x1, y1, x2, y2, Data type"

    'formatPoint = "/Point=X" & FD & " Y" & FD & " {Input-Output ... }" & FD & " Data Type" & FD & " Name"
    Public formatPoint As String = "/Point=X, Y, {Input-Output ... }, Data Type, Name"

    'FormatSet_ = "/set={Points,Text,Delimiters,Language, Options, Option, Scale,Grids,Dump}" & vbCrLf &
    '    "/Set=Option, 1-64,{0/1,on/off,true/false}" & vbCrLf &
    '    "/option=Option Number, {On/Off, 1/0, True/false}, Description" & vbCrLf &
    '    "/Set=Scale,625-10000" & vbCrLf &
    '    "/Set=Grids,Lines(1-10),PathsPoints(Lines,250),Symbols pathsPoints,10000) " & vbCrLf &
    '    "/Set=Dump,DumpFile1.txt, DumpFile2.txt, DumpFile3.txt" & vbCrLf &
    '    "/Set=points,Index,X,Y" & vbCrLf &
    '    "/Set=text,Index,X,Y" & vbCrLf &
    '    "/set=Delimiters,Start of marker, end of marker" & vbCrLf &
    '    "/set=language,class, dialect"
    Public FormatSet_ As String = "/set={Points, Text, Delimiters, Language, Options, Option, Scale, Grids, Dump}" & vbCrLf &
"/option=Option Number, {On/Off, 1/0, True/false}, New Description" & vbCrLf &
"/Set=Scale, 625-10000" & vbCrLf &
"/Set=Grids, Lines(1), PathsPoints(250), Symbols pathsPoints, 10000) " & vbCrLf &
"/Set=Dump, DumpFile1.txt, DumpFile2.txt, DumpFile3.txt" & vbCrLf &
"/Set=points, Index, X, Y" & vbCrLf &
"/Set=text, Index, X, Y" & vbCrLf &
"/set=Delimiters, Start of marker, end of marker (no comma between)" & CT & "/set=language, class, dialect"

    'formatStroke = "/Stroke={}"
    Public formatStroke As String = "/Stroke={}"

    'formatSymbolName = "/Name=Symbol Name" & FD & " options"            'Need to get the {/ ... } options from the ComboBox 
    Public formatSymbolName As String = "/Name=Symbol Name, options"

    'FormatSyntax = "/Syntax={keyword" & FD & "special characters" & FD & AddRM("variables")
    '"/Syntax={keyword, special characters" & COMMA & RMS & "variable" & FCCL_WhiteSpace & COMMA & RMS & "quote" & COMMA & RMS & "number, Alphabetics, And so On}"
    Public FormatSyntax As String = "/Syntax={keyword, special characters, variables"

    'formatUse = "/Use=Name" & FD & " X" & FD & " Y" & FD & " rotation" & FD & " future dynamic options"
    Public formatUse As String = "/Use=Name, X, Y, rotation, future dynamic options"

    'formatVersion = "/Version={}"
    Public formatVersion As String = "/Version= "

    Public FormatConstantBranchToNextLine As String = "/ConstantBranchToNextLine = branchto (Internal marker Default ⬂BranchTo⬃)"
    Public FormatConstantDelimiter As String = "/ConstantDelimiter=CharacterCharacterCharacter…' Should be in form ‘0X000D’ …"
    Public FormatConstantDelimiters As String = "/ConstantDelimiters=CharacterCharacterCharacter…’ Should be in form ‘0X000D’ …"
    Public FormatConstantDistanceBetweenControls As String = "/ConstantDistanceBetweenControls=number (Pixel distance between FCCL controls)"
    Public FormatConstantDistanceToMovePaths As String = "/ConstantDistanceToMovePaths=number (min distance between paths to allow movement Default 101)"
    Public FormatConstantMaxPenSize As String = "/ConstantMaxPenSize=number (The is the largest Width of paths and size of a point)"
    Public FormatConstantMinBoxSize As String = "/ConstantMinBoxSize=number (This is the smallest size that a box should be.)"
    Public FormatConstantMinPenSize As String = "/ConstantMinPenSize=number (this is the smallest size of a path and point)"
    Public FormatConstantQuote As String = "/ConstantQuote= character (This string is what starts and stops a quote )"
    Public FormatConstantRecordsBeforeSaveIsAllowed As String = "/ConstantRecordsBeforeSaveIsAllowed= number (This is the least number of flowchart records before a save flowchart is allowed default 0)"
    Public FormatConstantSpacingFactor As String = "/ConstantSpacingFactor=number (This is the number of symbols that is placed going down before it starts at the top with a new column)"
    Public FormatConstantSpecialCharacters As String = "/ConstantSpecialCharacters=string (This is a string of characters where a white space replaces any of these special characters (mainly for filenames)"
    Public FormatConstantSymbolCenter As String = "/ConstantSymbolCenter=number (This is the distance of symbols.  Default 250 which makes the symbols in the box (-250,-250)-(250,250)"
    Public FormatConstantWhiteSpaceD As String = "/ConstantWhiteSpaceD= number, number … (This list of decimal numbers will be the complete list of white space characters)"
    Public FormatConstantWhiteSpaceH As String = "/ConstantWhiteSpaceH= hex number, hexnumber ...(This list of characters will be the complete list of shite space characters)"
    Public Formatdebug As String = "/debug=number, number (First number is the level of debug messages (MsgBox & Log [1=Errors, 2=warnings, 3=notices], [log 4=Info, 5=display, 6=status], [special 7-9]) "
    Public Formatdrilldown As String = "/drilldown=path/file.extension (This will open and read the file)"
    Public Formatdump As String = "/dump=Dump File 1, File 2, File 3"
    Public Formatexit As String = "/exit=  (Will exit the program!  Forced to quit, and nothing is saved.)"
    Public Formatexport As String = "/export=  (This will export the two log files 1 and 2, reserved for future usage )"
    Public FormatFCCL_case As String = "/FCCL_case= {Yes/No, 0/1, True/False, Yes/Ne}  (This is if the computer language is case sensitive)"
    Public FormatFCCL_comment As String = "/FCCL_comment=string (This is the marker for syntax default ⬂comment⬃)"
    Public FormatFCCL_Default_Root As String = "/FCCL_Default_Root=Grammar rule name, Symbol name"
    Public FormatFCCL_Default_Roots As String = "/FCCL_Default_Roots=Grammar rule name 1, Symbol name 1 ,Grammar rule name 2, Symbol name 2 …"
    Public FormatFCCL_DialectName As String = "/FCCL_DialectName = (replaced with /Language)"
    Public FormatFCCL_Dimension As String = "/FCCL_Dimension= strings  (This must have ‘Variable’ and ‘DataType’ in the strings it defines the syntax code text replacement for all paths)"
    Public FormatFCCL_Extensions As String = "/FCCL_Extensions=extentions, … (These are the extensions that the computer language uses.  The First one will be the default of any output)"
    Public FormatFCCL_multiLine As String = "/FCCL_multiLine= character(s)  (This is used as a divider between statements on the same line (as allowed by the computer language) default is : )"
    Public FormatFCCL_Root As String = "/FCCL_Root=grammar rule name, grammar rule name, … (This is a list of grammar rule names that care not called by another grammar rule.)"
    Public FormatFCCL_Roots As String = "/FCCL_Roots=Grammar rule name, Symbol name , rule, symbol, .. (This will make this symbol be displayed when the grammar rule us used for this symbol  - Note that only lines are allowed in these special symbols Under construction))"
    Public FormatFCCL_varchars As String = "/FCCL_varchars= string  (These are characters that are allowed in variable name (in addition to A-Z, a-z, 0-9)"
    Public FormatFcfinish As String = "/Fcfinish=(No longer used)"
    Public Formatfunctions As String = "/functions=list of function names (This is a list of functions (to be treated as keywords, non changeable)"
    Public Formatignore As String = "/ignore=Ignores everything on this line"
    Public Formatimport As String = "/import  = (under construction see drilldown)"
    Public FormatKeywordS As String = "/KeywordS="
    Public Formatlogin As String = "/login= (under construction)"
    Public FormatMarkerAlpha As String = "/MarkerAlpha=MarkerString (This is used internally only default Alpha)"
    Public FormatMarkerBranchToNextLine As String = "/MarkerBranchToNextLine=Markerstring (This is used internally only default BranchTo)"
    Public FormatMarkerCameFromLine As String = "/MarkerCameFromLine=MarkerString (This is used internally only default CameFrom)"
    Public FormatMarkerComment As String = "/MarkerComment=MarkerString (This is used internally only default Comment)"
    Public FormatMarkerNumber As String = "/MarkerNumber=MarkerString (This is used internally only default Numbers)"
    Public FormatMarkerQuotes As String = "/MarkerQuotes=MarkerString (This is used internally only quote)"
    Public FormatMarkerSpecialCharacters As String = "/MarkerSpecialCharacters=MarkerString (This is used internally only default Special)"
    Public FormatMessage As String = "/Message= text  (This will display a message box with what ever text is on the line)"
    Public Formatoperators As String = "/operators="
    Public Formatroute As String = "/route= [start] [, end] (This will try to connect all paths /route=, one path /route=10, or a range of paths /route=1,1000"
    Public Formattranslate As String = "/translate=English, spoken language  (This will replace all text from the english (word or phrase) to a spoken language (word or phrase) Note that this is a word for word translation, so the output would be in the order of the english input)"
    Public FormatUnknown As String = "/Unknown=used internally"
    Public Formatx1 As String = "/x1=not used"
    Public Formatx2 As String = "/x2=not used"
    Public Formaty1 As String = "/y1=not used"
    Public Formaty2 As String = "/y2=not used"
    Public FormatBlock As String = "/Block = begging String ending String”
    Public FormatBlocks As String = "/Blocks  = /Blocks= begging string ending string comma begging string ending string …’Each string is divided in half. "





    '1-8 is unusable
    '9- (  MyUniverse.SysGen.Constants.ConstantFirstLanguage-1) is options
    '( ConstantFirstLanguage to ConstantL astLanguage)is for computer languages that is build into for special rules (as yet unknown)
    '  (  MyUniverse.SysGen.Constants.ConstantLa stLanguage+1 to 99 99 is for messages (MsgBox, and just sending to the text status text box)
    ' The first 64 bits are for the option list on the options window
    Public MyMessageBits(1250) As Integer ' 1250 gives exactly 10,000 bit settings for yes or no

    ' not used?   friend FastFlipFlop(4, 14) As Short

    '
    '    'Flipping instruction X=XX+XY, Y=YX+YY   to flip X=-1+0, Y=0+1 (see The first 0 of each for the default non Flip example)
    '0=default, 1=flip, 2=flop, 3=Rotate90, 4=Rotate180, 5=Rotate270
    ' Flip=sideways, Flop=top2bottom, 
    'Matrix
    '0  1  2  3  4  5 6    7    8    9   10   11
    '1  -1 1  0  1  0
    '0  0  0  1  0  -1
    '0  0  0  -1 -1 1
    '1  1  -1 0  0  0


    Structure MyRecordNames
        Dim PointName As String
        Dim SymbolName As String
        Dim PathName As String
        Dim IsWorldWindow As String
    End Structure


    Structure MyPointStructure
        Dim x As Integer
        Dim y As Integer
        Dim Named As MyRecordNames
    End Structure


    Structure MyLineStructure
        Dim a As MyPointStructure
        Dim b As MyPointStructure
    End Structure

    Structure MyRECTStructure
        Public MyWorldXY As MyLineStructure    'Used for real world XY
        Public MyInputWindowXY As MyLineStructure   'Used for the Window XY
    End Structure


    Structure MyWindowInfoStructure
        Dim MouseStatus As String
        Dim MouseStroke As String
        Dim MouseWorld As MyLineStructure     ' this should hold the size of the total flow chart (But it holds the size of the window)
        Dim MouseWindow As MyLineStructure    ' this should hold the size of the display window
        Dim MyScreen00 As MyPointStructure ' This is the last mouse movement
        Dim PaintThisOrEraseThis As Boolean
        Dim FlowChartClosing As Boolean
    End Structure

    Structure MyDisplayStructure
        Dim x As Integer
        Dim y As Integer
        Dim ColorName As String
        ' DIM   ColorBrush As Brush
        Dim ColorPen As Pen
        'todo need to add here to be able to resize the rectangle that holds the display text size 
        Dim TextWidth As Integer 'current default is 500
        Dim TextHeight As Integer ' current default is 500
    End Structure

    Structure ChangesMadeStructure
        Dim SymbolNameSelected As Boolean 'False if no changed, true if change the selected Symbol 
        Dim SymbolWindowSymbolEdited As Boolean 'True when any changes made to catch before you change/delete,not saved.
    End Structure

    Structure DumpFileNameStructure
        Public OutputFileName1 As String 'dumps only on request, named Symbols, Symbol graphics, FlowChart graphic data
        Public OutputFileName2 As String ' creates new file of normal export then all variables that are changeable at this point
        Public OutputFileName3 As String 'dumps a log with debug 1 to 10
    End Structure



    'This is simply an option for each Symbol, it is up to the MicroTextCode to use it.
    Structure SymbolOptionsStructure
        Dim OptionNames As String
        Dim OptionNumber As Integer
    End Structure


    Structure MySystemStructure
        Dim FCProcessID As Integer
        Dim Dumps As DumpFileNameStructure
        ' DIM   MyNOTaClipBoard As String
        Dim FlowChartOptions() As SymbolOptionsStructure
        Dim SelectionOption As Integer
        Dim WindowsStatus() As String
    End Structure

    Structure SnapStructure
        Dim MySnap As Integer ' min snap (assume 1) (used in Symbol Window only)
        Dim MyPointSnap As Integer ' the grid for points and paths
        Dim MySymbolSnap As Integer ' The grid for placing Symbols on the flow chart (used in the Flow Chart Window only)
    End Structure


    Structure MyFlowChartStructure
        Dim Constants As ConstantsStructure
        Dim Markers As MarkersStructure
        Dim NumberOfButtonsActive As Integer
        Dim Snaps As SnapStructure
        Dim MinBox As Integer  'Min Size of box to select all
        Dim MyFlowChartScale As Single
        Dim MySymbolScale As Single
        Dim Size As MyPointStructure
        ' DIM   ReSize As Int16 ' Used as a flag to not let resize call it's self recursively ( 987 vs anything else)
        Dim DoNotAskToAdd As Boolean
        Dim PlacementBase As MyPointStructure
        Dim PlacementCurrent As MyPointStructure
        Dim PlacementColumn As Integer ' This is the current column (does not move because of indentions turned on
        Dim PlacementNextColumnMin As Integer ' This is always the column one bigger then any current column to start at
        Dim ChangesMade As ChangesMadeStructure
    End Structure

    Structure MarkersStructure
        Dim AlphaNumeric As String
        Dim Alphas As String
        Dim Block As String
        Dim BranchToNextLine As String
        Dim CameFromLine As String
        Dim Comments As String
        Dim DataType As String
        Dim FieldDelimiters As String
        Dim Functions As String
        Dim Grammar As String
        Dim HexRange As String
        Dim KeyWords As String
        Dim Literal As String 'single quoted (for grammar only)
        Dim Markers As String
        Dim Numbers As String
        Dim Operators As String
        Dim Quotes As String 'double quote
        Dim SpecialCharacter As String
        Dim UnicodeClass As String
        Dim Unknowns As String
        Dim WhiteSpaces As String
    End Structure
    Structure ConstantsStructure
        '     DIM   SyntaxMultiLines As String ' not currently allowed
        Dim Grammar As String
        Dim MyCmdModeString As String
        Dim RMEnd As String
        Dim RMStart As String

        Dim ConstantDelimiters As String
        Dim ConstantDistanceBetweenControls As Integer
        Dim ConstantDistanceToMovePaths As Integer
        Dim DrillDown_FileName As String  'ONLY Current File name Device:/Paths/Filename.Extension   '(direction, First-Second Line, X/Y
        Dim ConstantMaxPenSize As Integer
        Dim ConstantMinBoxSize As Integer
        Dim ConstantMinPenSize As Integer
        Dim ConstantQuote As String
        Dim ConstantRecordsBeforeSaveIsAllowed As Integer
        Dim ConstantSpacingFactor As Integer
        Dim ConstantSpecialCharacters As String
        Dim ConstantSymbolCenter As Integer
        Dim ConstantWhiteSpaces As String
    End Structure




    Structure ShowAllWindowsStructure
        Dim F1, F2, F3, F4 As Integer
    End Structure



    Structure GrammarStructure
        Dim DISPLAYER As Integer
        Dim I, J As Integer
        Dim S As String
        Dim T As String
        Dim t1, t2, t3 As Integer
        Dim MyEquals As Integer
    End Structure


    Structure PaintingStructure
        Dim Start As Integer
        Dim Ending As Integer
        Dim PanX, PanY As Integer
    End Structure


    Structure StaticStructure
        Dim Tagged As Integer
        Dim tag As Integer
        Dim LookForX, LookForY As Integer
        Dim FoundX, FoundY As Integer
        Dim MinXY As MyPointStructure     ' Location of total picture
        Dim MaxXY As MyPointStructure
        Dim Hints() As String ' Not static, but a list of the last 10 new hints.
        'This is data file stuff (That should be in a data file)
        Dim Named_TableCount As Integer    'This is one for each Symbol 
        Dim Symbol_TableCount As Integer     ' Number in the MyArray (Points to last)
        Dim FlowChart_TableCount As Integer     ' Number in the MyArray (Points to last)
        Dim DataType_TableCount As Integer ' The number of DataType_Tables in the table
        Dim Color_TableCount As Integer   ' A list of the colors available to use
        Dim SymbolNumber_Counter As Integer
        Dim My_Syntax_Line_Parsed() As String
        Dim My_Code_Line_Parsed() As String
        Dim Path_Names As String ' global that is the current list of the variable names only of the parsed code Line
        Dim Path_NamesCounted As Integer
        Dim LastColor As Integer
        Dim LastHex As String
        Dim LastValue As Integer
        Dim Painting As PaintingStructure
        Dim LastDataType As String
        Dim ShowAllWindows As ShowAllWindowsStructure
        Dim ZeroZero As MyPointStructure
        Dim ZeroZeroZeroZero As MyLineStructure
    End Structure


    Structure IOTypeStructure
        Dim Input As Integer
        Dim Output As Integer
        Dim Both As Integer
        Dim Other As Integer
        Dim Total As Integer
    End Structure

    Structure PointTypeStructure
        Dim MyName As String
        Dim Logic As IOTypeStructure
        Dim Data As IOTypeStructure
        Dim Total As Integer
    End Structure

    Structure UseTypeStructure
        Dim MyName As String
        Dim Total As Integer
    End Structure

    Structure MyPointCountsStructure
        Dim SymbolName As String
        Dim NumberOfPoints As PointTypeStructure
        Dim NumberOfLines As PointTypeStructure
        Dim NumberOfOther As PointTypeStructure
        Dim Total As Integer
    End Structure

    Structure MyPathCounts
        Dim PathName As String
        Dim NumberOfConnectionsToOtherPaths As PointTypeStructure
        Dim NumberOfConnectionsToSymbols As PointTypeStructure
        Dim NumberOfErrors As Integer
        Dim Total As Integer
    End Structure

    Structure MyUseStructure
        Dim IndexUseSymbol As Integer
        Dim NumberOfConnections As MyPointCountsStructure
        Dim Total As Integer
    End Structure
    Structure MySymbolCountsStructure
        Dim Name As String
        Dim Symbol As MyPointCountsStructure
        Dim Path As MyPathCounts
        Dim Uses As MyUseStructure
        Dim Total As Integer
    End Structure

    Structure MySymbolPointPreference
        Dim x As Integer
        Dim y As Integer
    End Structure


    Structure ProgramOptionsStructure
        Dim FCCL_Dimension As String
        'replaced by Options.ListBoxSymbolData.Items.Item(20)         Dim FCCL_Case As Boolean
        'replaced by Options.ListBoxSymbolData.Items.Item(21)         Dim FCCL_Comment As String
        'Dim FCCL_Extension As String
        Dim FCCL_Extensions As String ' contains the extension(s) available
        Dim FCCL_MultiLine As String
        Dim FCCL_LanguageClassName As String
        'Dim FCCL_DialectName As String     ' 
        Dim FCCL_VarChars As String
        Dim FCCL_Order As String
        Dim FCCL_WhiteSpace As String
        Dim FCCL_Roots As String    'This is grammar roots
        Dim FCCL_NotRoots As String     'This is a list of grammar names that are not roots, and have a symbol attached to them
        Dim FlowChartTextBox As String
        Dim SelectedSymbolName As String
        Dim SelectedDataType As String
        Dim SelectedColor As String
        Dim SelectedInputOutput As String
        Dim SelectedRotation As String
        Dim SelectedPathStart As String
        Dim SelectedPathEnd As String
        Dim SelectedPathLineStyle As String
        Dim SelectedNumberOfBytes As String

        Dim SelectedObject As Integer
        Dim HelpURL As String
        Dim SymbolChanged As Boolean 'This is a flag if something changes on the Symbol Window to allow it to be updated (added)
    End Structure

    Structure FlowChartRegisterStructure
        Dim FCRName As String   'name of the program,
        ' DIM   FCRVersion As String    'Version of the program
        ' DIM   FCRCPUid As String      'This should be the computer ID, so that it can be License to a single computer
        ' DIM   FCRKey As String    'This is the key that lets it do more stuff (
        Dim FCRUserLevel As String  'This is the level that the user is allowed up to
        '        So that the program can be made to be used by students by levels (The FlowChartKey should set this level
        Dim FCRUserProfession As String ' This is the level of expertise
        '       This level should be made available via a drop down of the allowed levels of expertise.
        Dim ID As String    ' this will be the cpu id stuff later when i get a square from it.
    End Structure


    Structure MyDirStructure
        Dim Working As String
        Dim Program As String
        Dim Languages As String
        Dim HelpFiles As String
    End Structure


    Structure MyUniverseStructure
        ' DIM   DebugCount() As Integer
        Dim MyDir_s As MyDirStructure
        Dim MyProgramStatus As String
        Dim Paint As Boolean
        Dim FCCLDebugLevel_1 As Integer  'from zero (none) to 9 (all) controls 'level' of debugging messages
        Dim FCCLDebugLevel_2 As Integer ' From debug1 to 3 tells of the level where msgbox()  is displayed (set to 1 to disable all)
        Dim Grammar As Boolean
        Dim Security As String  'This string holds what the user can and can not do (See Security())
        Dim PaidFor As FlowChartRegisterStructure
        Dim MySystem As MySystemStructure
        Dim SysGen As MyFlowChartStructure
        Dim MySS As ImportLineStruct
        Dim MyMouseAndDrawing As MyWindowInfoStructure
        Dim Area As MyRECTStructure
        Dim MyStaticData As StaticStructure
        Dim ProgramOptions As ProgramOptionsStructure
        ' DIM   Languages As LanguageStructure
        Dim SymbolAndPath As MySymbolCountsStructure
        Dim MySymbolPoints() As MySymbolPointPreference
        Dim OptionDisplay() As MyDisplayStructure
        Dim Column() As Integer
    End Structure

    Structure MyNumberOrString
        Dim MyNumber As Integer
        Dim MyString As String
    End Structure

    Structure MyRecordStruct
        Dim Coded As Integer
        Dim X1, Y1 As Integer
        Dim X2, Y2 As MyNumberOrString
        Dim NameOfPoint As String
        Dim a As MyPointStructure
        Dim b As MyPointStructure
    End Structure

    Structure TempsStructure
        Dim TempFormat As String
        Dim TempRecord As Integer
        Dim TempInteger1 As Integer ' no longer temp(s)
        Dim TempString2 As String 'on/off or true/false ... 
        Dim TempInteger As Integer
    End Structure



    Structure TextsStructure
        Dim AllText As String 'This is the entire file, or one Line inputs on the window
        Dim KWord As String ' This is the key
        Dim KPar As String ' This is everything after the= in key=parameters
        Dim LineNumberIn As Integer
    End Structure

    Structure ImportLineStruct
        Dim Inputs As TextsStructure
        Dim Temps As TempsStructure
        Dim LastName As String
        Dim IndexName, IndexSymbol As Integer
        Dim TopMost As Integer
        Dim MyRecord As MyRecordStruct
    End Structure

    Structure ThisArrow
        Dim TempPenWidthSize, ArrowFactor, DirectionIs As Integer
        Dim IndexDataType As Integer '  Used Only For Trying to improve the speed by not sorting
        Dim MinePen As Pen
        Dim MyXY1 As MyPointStructure    ' center point to show direction
        Dim MyXY2 As MyPointStructure    ' shows direction of path into the Symbol
        Dim XY1 As MyPointStructure     ' Used only to display points (as Lines)
        Dim XY2 As MyPointStructure     ' Other end of the Line
        ' DIM   index As Integer   ' Index of this data type
        Dim ColorName, Temp As String
        Dim Input_Output_Both_Direction As Integer
        Dim IO_SizeModifier() As Integer
    End Structure
    Public MyUniverse As MyUniverseStructure
    '- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
    'todo need to convert to this structure Phase 2
    Structure FCCL_Color
        Dim Name As String
        Dim FileName As String
        Dim Alpha As Integer
        Dim Red As Integer
        Dim Green As Integer
        Dim Blue As Integer
        Dim EndCap As Integer
        Dim StartCap As Integer
        Dim Style As Integer
    End Structure


    Public English2(1) As String
    Public English2Word(1) As String


    Structure FCCL_FlowChart
        Dim PathSymbolName As String  ' The name of the /use, the variable name of /Path & /Constant
        Dim Coded As String ' The codes /Use, /Path, /Constant
        Dim X1 As Integer
        Dim Y1 As Integer
        Dim _X2_Rotation As Integer   'X2 for /path, Rotation for /use
        Dim _Y2_Option As Integer   'Y2 for path, future options for /use
        Dim _DataType As String  'The DataType for /Path /Constant

        Dim ISAM_Name As Integer
        Dim ISAM_X1 As Integer 'Holds Indexes to the FlowChart, sorted (Indexed Sequential Access Method
        Dim ISAM_Y1 As Integer
        Dim ISAM_X2 As Integer
        Dim ISAM_Y2 As Integer
    End Structure






    Public MyBits() As Integer = {1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8198, 16384, 32768, 65536, 131072, 262144, 524288, 1048576}
    'the size of MyDirection determines the size of the arrows at points 
    Public MyDirections(16, 2, 2) As Integer   ' This is the matrix to determine the two end points from the center
    Public MyRotation(4, 12) As Integer 'holds how to rotate

    '- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
    ' Programing routines to follow

    ''' <summary>
    ''' variable name into ⬂variable.PATHNAME⬃
    ''' </summary>
    ''' <param name="A">make a variable name into a syntax for </param>
    ''' <returns></returns>
    Public Function MakePathName(A As String) As String
        Return AddRM(NameOfPointOnly(A) & ".PathName")
    End Function

    Friend Function MyLeft(MyString As String, Number As Integer) As String
        If Number < 1 Or Number > Len(MyString) Then Return ""
        Return Mid(MyString, 1, Number) 'Return MyLeft(MyString, Number)
    End Function
    Friend Function MyRight(MyString As String, Number As Integer) As String
        If Len(MyString) = 0 Or Number > Len(MyString) Then Return ""
        Return Mid(MyString, Len(MyString) - Number + 1)
    End Function

    'Routine  This returns a pen color by name (cause I can't make my own from RGB() to work, cause I lazy right now)
    Friend Function MyGetPen(ByRef SourceForm As Source, PassedColor As String, PassedDataType As String) As Pen     'Converts from Red/Green/Blue/Alpha to Color structure into globalMyGetPen_Static
        'GetMyPen is a global that is changed and passed back.
        'todo this (and get brushes) needs to be changed to use the color table instead of MicroSoft named colors
        Dim ColorORDataTypeName As String
        Dim IndexColor As Integer
        Dim A, R, G, B As Integer
        Dim Width As Integer
        Dim Z As Color 'temp debug


        If Len(PassedColor) = 0 And Len(PassedDataType) = 0 Then
            If MyOptionTest(25) = True Then
                Return Pens.Black
            Else
                Return Pens.Red
            End If
        End If

        ColorORDataTypeName = FindColorFromDataType(Trim(PassedDataType))
        If Len(PassedColor) > 0 Then    ' This is if it was a color name
            Width = 1
            ColorORDataTypeName = Trim(PassedColor)
        Else
            'This is if it was a data type name passed
            ColorORDataTypeName = Trim(ColorORDataTypeName)
            Width = FindWidthFromDataType(SourceForm, Trim(PassedDataType))
        End If

        If MyUniverse.MyMouseAndDrawing.PaintThisOrEraseThis = False Then
            MyGetPen = New Pen(Color.FromArgb(0, 0, 0, 0), Width)
            Return MyGetPen
            'Return Pens.White 'todo this should be the background color of the image, what ever it is set to 
        End If

        IndexColor = BinarySearch4Index(Options.ListBoxColors, PassedColor)
        If IndexColor = ConstantMyErrorCode Then Return Pens.Red
        A = Color_TableAlpha(IndexColor)
        R = Color_TableRed(IndexColor)
        G = Color_TableGreen(IndexColor)
        B = Color_TableBlue(IndexColor)

        Z = Color.FromArgb(A, R, G, B)
        MyGetPen = New Pen(Color.FromArgb(A, R, G, B), Width)
        Return MyGetPen

    End Function

    Function MySign(A As Integer) As Integer   'Returns the sign value
        If A > 0 Then Return 1
        If A < 0 Then Return -1
        Return 0
    End Function


    'Routine  This returns an absolute value (ie: never negative)
    Friend Function MyABS(A As Integer) As Integer   'Returns the absolute value
        If A > 0 Then Return A
        Return -A
    End Function




    Friend Function MyABS64(A As Int64) As Int64   'Returns the absolute value
        If A > 0 Then Return A
        Return -A
    End Function

    'routine to get the max value (dumb, should be a default function ! )
    Friend Function MyMax(a As Integer, b As Integer) As Integer
        If a > b Then Return a
        Return b
    End Function


    'Routine This returns the minium of the two (long) values
    Friend Function MyMin(a As Integer, b As Integer) As Integer
        If a < b Then Return a
        Return b
    End Function


    Friend Function MyMinMaxLine_Not_Used(A As MyLineStructure, B As MyLineStructure) As MyLineStructure
        Dim X, Y, Z As MyLineStructure
        X = MyMinMaxP(A.a, A.b)
        Y = MyMinMaxP(B.a, B.b)
        Z.a = MyMinMaxP(X.a, Y.a).a
        Z.b = MyMinMaxP(X.b, Y.b).b
        Return Z
    End Function
    Friend Function MyMinMaxP(A As MyPointStructure, B As MyPointStructure) As MyLineStructure
        Dim RTN As MyLineStructure = Nothing
        RTN.a.x = MyMin(A.x, B.x)
        RTN.a.y = MyMin(A.y, B.y)
        RTN.b.x = MyMax(A.x, B.x)
        RTN.b.y = MyMax(A.y, B.y)
        Return RTN
    End Function

    'Routine This returns the number forced to be between 
    'This routine returns  Min <= A <= Max
    Friend Function MyMinMax(A As Integer, MinimumValue As Integer, maximinValue As Integer) As Integer
        If A < MinimumValue Then Return MinimumValue
        If A > maximinValue Then Return maximinValue
        Return A
    End Function





    'This makes sure that the file counters of where you are is inside the bounds of the arrays


    '
    'One of many routines that returns the top of the data in the array
    Friend Function NewTopOfFile(ByRef lb As ListBox) As Integer
        NewTopOfFile = TopOfListBox(lb) + 1
    End Function

    '
    'This is to keep track of the top of the USED arrays (as opposed to the size of the array)
    Friend Function TopOfListBox(LB As ListBox) As Integer
        Return LB.Items.Count - 1
    End Function


    Friend Sub MySendToFront(F As Form)
        F.Visible = True
        F.BringToFront()
        F.MinimizeBox = False
        'DoEvent(5, "To Front")
    End Sub

    Friend Sub MySendToBack(F As Form)
        '            F.Visible=False
        F.BringToFront()
        F.SendToBack()
        'F.MinimizeBox=True
        'DoEvent(6, "To Back")
    End Sub

    Friend Function MyRotated(ByRef SourceForm As Source, IndexSymbol As Integer, IndexFlowChart As Integer) As MyPointStructure
        Dim RotationName As String
        Dim InputXY As MyPointStructure
        Dim OffsetXY As MyPointStructure

        InputXY = MyUniverse.MyStaticData.ZeroZero
        OffsetXY = MyUniverse.MyStaticData.ZeroZero
        RotationName = FlowChart_Table_Rotation(SourceForm, IndexFlowChart)
        If IndexSymbol = 0 Then
            InputXY.x = 0
            InputXY.y = 0
            SetNameOfPoint(InputXY)
        Else
            InputXY.x = Symbol_TableX1(IndexSymbol)
            InputXY.y = Symbol_TableY1(IndexSymbol)
            SetNameOfPoint(InputXY, Symbol_Table_NameOfPoint(IndexSymbol))
        End If
        OffsetXY.x = FlowChart_TableX1(SourceForm, IndexFlowChart)
        OffsetXY.y = FlowChart_TableY1(SourceForm, IndexFlowChart)
        Select Case FlowChart_TableCode(SourceForm, IndexFlowChart)
            Case My_keyWord(My_KeyConstUse)
                SetNameOfPoint(OffsetXY, "", FlowChart_TableSymbol_Name(SourceForm, IndexFlowChart))
            Case "/path"
                SetNameOfPoint(OffsetXY, "", "", FlowChart_TablePathName(SourceForm, IndexFlowChart))
            Case Else
                SetNameOfPoint(OffsetXY, "??10" & FlowChart_TableCode(SourceForm, IndexFlowChart), "??11" & FlowChart_TableCode(SourceForm, IndexFlowChart), "???" & FlowChart_TableCode(SourceForm, IndexFlowChart))
        End Select
        MyRotated = MyRotated_x(InputXY, OffsetXY, RotationName)
    End Function

    Friend Function MyRotated_1(IndexSymbol As Integer, OffsetXY As MyPointStructure, RotationName As String) As MyPointStructure
        Dim InputXY As MyPointStructure
        InputXY = MyUniverse.MyStaticData.ZeroZero
        InputXY.x = Symbol_TableX1(IndexSymbol)
        InputXY.y = Symbol_TableY1(IndexSymbol)
        SetNameOfPoint(InputXY, Symbol_Table_NameOfPoint(IndexSymbol))
        MyRotated_1 = MyRotated_x(InputXY, OffsetXY, RotationName)
    End Function


    Friend Function MyRotated_1a(IndexSymbol As Integer, RotationName As String) As MyPointStructure
        Dim InputXY As MyPointStructure
        InputXY = MyUniverse.MyStaticData.ZeroZero
        InputXY.x = Symbol_TableX1(IndexSymbol)
        InputXY.y = Symbol_TableY1(IndexSymbol)
        SetNameOfPoint(InputXY, Symbol_Table_NameOfPoint(IndexSymbol))
        MyRotated_1a = MyRotated_x(InputXY, MyUniverse.MyStaticData.ZeroZero, RotationName)
    End Function




    Friend Function MyRotated_2(ByRef SourceForm As Source, IndexSymbol As Integer, IndexFlowChart As Integer, RotationName As String) As MyPointStructure
        Dim InputXY As MyPointStructure
        Dim OffsetXY As MyPointStructure
        InputXY = MyUniverse.MyStaticData.ZeroZero
        OffsetXY = MyUniverse.MyStaticData.ZeroZero

        InputXY.x = Symbol_Table_X2(IndexSymbol)
        InputXY.y = Symbol_Table_Y2(IndexSymbol)
        SetNameOfPoint(InputXY, Symbol_Table_NameOfPoint(IndexSymbol))
        OffsetXY.x = FlowChart_TableX1(SourceForm, IndexFlowChart)
        OffsetXY.y = FlowChart_TableY1(SourceForm, IndexFlowChart)
        SetNameOfPoint(OffsetXY, "", FlowChart_TablePathName(SourceForm, IndexFlowChart), FlowChart_TablePathName(SourceForm, IndexFlowChart).ToString)
        MyRotated_2 = MyRotated_x(InputXY, OffsetXY, RotationName)
        If MyDebug(A_ERROR) Then logA(2715, RotationName, MyShowPoint(InputXY), MyShowPoint(OffsetXY), MyShowPoint(MyRotated_2))
    End Function

    Friend Function MyRotated_2d(IndexSymbol As Integer, OffsetXY As MyPointStructure, RotationName As String) As MyPointStructure
        Dim InputXY As MyPointStructure
        InputXY = MyUniverse.MyStaticData.ZeroZero
        InputXY.x = Symbol_Table_X2(IndexSymbol)
        InputXY.y = Symbol_Table_Y2(IndexSymbol)
        SetNameOfPoint(InputXY, Symbol_Table_NameOfPoint(IndexSymbol))
        MyRotated_2d = MyRotated_x(InputXY, OffsetXY, RotationName)
    End Function


    Friend Function FlipFlop(WhichOne As Integer, Index As Integer) As Integer
        If WhichOne = MyMinMax(WhichOne, 1, 4) Then
            If Index = MyMinMax(Index, 0, 16) Then
                Return MyRotation(WhichOne, Index)
            End If
        End If
        Return MyRotation(WhichOne, 1)
    End Function
    Friend Sub SaveRotation(Index As Integer, InputString As String)
        MyRotation(1, Index) = PopValue(InputString)
        MyRotation(2, Index) = PopValue(InputString)
        MyRotation(3, Index) = PopValue(InputString)
        MyRotation(4, Index) = PopValue(InputString)
    End Sub


    Friend Function MyRotated_x(InputXY As MyPointStructure, OffsetXY As MyPointStructure, RotationName As String) As MyPointStructure
        Dim R As Integer
        MyRotated_x = MyUniverse.MyStaticData.ZeroZero
        R = MyEnumValue(RotationName, Options.ListBoxRotation) 'SplashWindowText)
        If R < 0 Or R > 16 Then
            logA(1273, R.ToString, RotationName)
            R = 1
        End If
        MyRotated_x.x = InputXY.x * FlipFlop(1, R) + InputXY.y * FlipFlop(2, R)
        MyRotated_x.y = InputXY.x * FlipFlop(3, R) + InputXY.y * FlipFlop(4, R)
        MyRotated_x.x += OffsetXY.x
        MyRotated_x.y += OffsetXY.y
        SetNameOfPoint(MyRotated_x, InputXY.Named.PathName, InputXY.Named.SymbolName, InputXY.Named.PathName)
    End Function


    Friend Function AddNewSymbol(ByRef SourceForm As Source, SymbolName As String, CodeLine As String) As Integer
        Dim IndexNamed, IndexSymbol As Integer
        If MyDebug(A_DISPLAY) Then logA(2422, SymbolName)
        If CodeLine = "" Or SymbolName = "" Then
            Return ConstantMyErrorCode
        End If
        'First make sure that we are not changing the name to something already there
        IndexNamed = BinarySearch4Index(Options.ListBoxSymbols, SymbolName)

        'todo need to add a message that you cant rename to something that already exist.
        If IndexNamed = ConstantMyErrorCode Then 'Name already there so DoNot add it again
            'IndexNamed =
            IndexNamed = AddNewNamedRecord(SourceForm, SymbolName, CodeLine)
            If MyDebug(A_INFORMATION) Then logA(2227, IndexNamed.ToString, CodeLine, SymbolName)
        End If

        IndexSymbol = CInt(FindInSymbolList(SourceForm, SymbolName))
        If IndexSymbol <= 0 Then
            ' add in the name record for this Symbol
            'NewTopOfFile(SourceForm,  "Symbol")
            InsertSymbolLineRecord(SourceForm, NewTopOfFile(Options.ListBoxSymbolKeyWordGraphics), MyUniverse.MyStaticData.ZeroZeroZeroZero, SymbolName, "/name", "NotUsed")
            logA(2106, MyShowNamedAndSymbolRecords(SourceForm, False, IndexSymbol))
        End If
        '
        AddSymbolToDropDown(SymbolName)
        Return IndexSymbol
    End Function



    '<0 it is before the first
    '=0 matches first 
    '1-99 between the two
    '100 matched with highest
    '>100 is higher than hi
    Friend Function PercentSearch(FirstString As String, SearchingForString As String, HighestString As String) As Integer
        Dim A1, B1, C1, A2, B2, C2, I As Integer
        I = 1
        If Len(FirstString) = 0 Then Return 1
        If Len(HighestString) = 0 Then Return 100
        If MyStrComp(FirstString, SearchingForString) = 0 Then Return 1 'return matched
        If MyStrComp(SearchingForString, HighestString) = 0 Then Return 100
        'todo this should never happed, and need to add an error message
        If MyStrComp(FirstString, HighestString) > 0 Then Return 101
        While MyStrComp(Mid(FirstString, I, 1), Mid(SearchingForString, I, 1)) = 0 And
                    MyStrComp(Mid(HighestString, I, 1), Mid(SearchingForString, I, 1)) = 0
            I += 1
        End While
        If I = 0 Then Return -1
        If I >= Len(FirstString) Then Return -1
        If I >= Len(SearchingForString) Then Return -1
        If I >= Len(HighestString) Then Return -1
        A1 = AscW(Mid(FirstString, I, 1))
        B1 = AscW(Mid(SearchingForString, I, 1))
        C1 = AscW(Mid(HighestString, I, 1))
        If B1 < A1 Then Return -1 ' searching is before the first one.
        If B1 > C1 Then Return 101
        A2 = C1 - A1 ' total distance
        B2 = B1 - A1 'from first to searching
        C2 = C1 - B1 ' from searching to end
        If A2 < 1 Then Return 1
        If B2 = A2 Then
            While MyStrComp(Mid(HighestString, I, 1), Mid(SearchingForString, I, 1)) = 0
                I += 1
            End While
            If MyStrComp(Mid(HighestString, I, 1), Mid(SearchingForString, I, 1)) > 0 Then Return 99
            If MyStrComp(Mid(HighestString, I, 1), Mid(SearchingForString, I, 1)) < 0 Then Return 101
            Return 100
        End If
        Return MyMinMax(CInt(B2 / A2 * 100), 0, 101)
    End Function

    Friend Sub AddSortedList(ThisTable As String, WhatStringToAdd As String)
        Select Case ThisTable
            Case "Color"
                Options.ListBoxColors.Items.Add(WhatStringToAdd)
            Case Else
                MsgBox("another place to re-write")
        End Select
    End Sub

    Friend Function MyRandom(Highest As Integer) As Integer
        Return MyMinMax(CInt(Rnd() * Highest), 1, Highest)
    End Function

    Friend Function MyRnd(NumberOfCharacters As Integer) As String
        Return MyRight(Strings.Replace((Rnd() * 10000).ToString & Rnd().ToString, ".", ""), NumberOfCharacters)
    End Function



    Friend Function FileNameOnly(P As String) As String
        FileNameOnly = P
        While InStr(FileNameOnly, "\") <> 0
            FileNameOnly = Mid(FileNameOnly, MyInStr("\", FileNameOnly) + 1, Len(FileNameOnly))
        End While
        If MyDebug(A_STATUS) Then logA(1101, FileNameOnly, P)
    End Function

    Friend Function ProgramBuzzy(A As String) As Boolean
        Dim Debug1 As String = MyUniverse.MyProgramStatus
        If MyUniverse.MyProgramStatus = "Dead" Then Return False
        If MyUniverse.MyProgramStatus = A Then Return True
        If A = "" And MyUniverse.MyProgramStatus = "" Then Return True
        If MyUniverse.MyProgramStatus = "" Then Return True
        If A = "Painting" And MyUniverse.MyProgramStatus = "Begin" Then Return True
        If A = "Begin" And MyUniverse.MyProgramStatus = "Alive" Then Return False
        If A = "Alive" And MyUniverse.MyProgramStatus = "Painting" Then Return True
        If A = "Alive" And MyUniverse.MyProgramStatus = "Begin" Then Return False
        If A = "Painting" And MyUniverse.MyProgramStatus = "Alive" Then Return False
        'If A="Buzzy" And MyUniverse.MyProgramStatus="DECOMPILE" Then Return True
        If MyUniverse.MyProgramStatus = "Dead" Then Return False
        Return False
    End Function




    Friend Function CheckThisPathName(ByRef SourceForm As Source, PathName As String, IndexFlowChart As Integer) As String
        Dim MyPathName As String
        MyPathName = NameOfPointOnly(FlowChart_TablePathName(SourceForm, IndexFlowChart))
        PathName = NameOfPointOnly(PathName)
        If FlowChart_TableCode(SourceForm, IndexFlowChart) <> "/Path" Then
            Return ""
        End If
        If Len(PathName) = 0 Then
            If FlowChart_TableCode(SourceForm, IndexFlowChart) = "/path" Then
                PathName = MyPathName
            Else
                ' removed not needed ?PathName=FlowChart_TableDataType(SourceForm , IndexFlowChart)
                Return MakePathName("vNOT_PATH_" & MyRnd(6)) 'todo ??? 7))
            End If
            If Len(PathName) = 0 Then
                PathName = MyPathName
            End If
        End If
        If PathName <> MyPathName Then
            MsgBox("Fix this here")
            If MyOptionTest(25) = True Then
                'todo needs to fix this problem
            Else
                'do nothing
            End If
        End If
        Return PathName
    End Function

    Friend Sub SetDefaults()
        MyUniverse.SysGen.Constants.ConstantWhiteSpaces = ChrW(&H9) & ChrW(&HA) & ChrW(&HB) & ChrW(&HC) & ChrW(&HD) & ChrW(&H20) & ChrW(&H85) & ChrW(&HA0) &
                ChrW(&H1680) & ChrW(&H180E) & ChrW(&H2000) & ChrW(&H2001) & ChrW(&H2002) & ChrW(&H2003) & ChrW(&H2004) &
                ChrW(&H2005) & ChrW(&H2006) & ChrW(&H2007) & ChrW(&H2008) & ChrW(&H2009) & ChrW(&H200A) & ChrW(&H200B) &
                ChrW(&H200C) & ChrW(&H200D) & ChrW(&H2028) & ChrW(&H202F) & ChrW(&H205F) & ChrW(&H2060) & ChrW(&H3000) & ChrW(&HFEFF)
        'MyUniverse.SysGen.Constants.ConstantWhiteSpaces = VBSpace & vbCr & vbLf & Strings.Chr(9) & vbVerticalTab & vbFormFeed
        MyUniverse.SysGen.Constants.ConstantDelimiters = "=" & FD & MyUniverse.SysGen.Constants.ConstantWhiteSpaces  ' White Space

        MyUniverse.ProgramOptions.SelectedColor = "Black"
        MyUniverse.ProgramOptions.SelectedDataType = "Logic"
        MyUniverse.ProgramOptions.SelectedInputOutput = "Both"
        MyUniverse.ProgramOptions.SelectedRotation = "Default"
        MyUniverse.ProgramOptions.SelectedSymbolName = "Start"

        MyUniverse.ProgramOptions.SelectedPathStart = "Flat"
        MyUniverse.ProgramOptions.SelectedPathEnd = "Flat"
        MyUniverse.ProgramOptions.SelectedPathLineStyle = "Solid"
        MyUniverse.ProgramOptions.SelectedNumberOfBytes = "4"

        MyUniverse.MySystem.FlowChartOptions(0).OptionNames = "Symbol option 0"
        MyUniverse.MySystem.FlowChartOptions(1).OptionNames = "Symbol option 1"
        MyUniverse.MySystem.FlowChartOptions(2).OptionNames = "Symbol option 2"
        MyUniverse.MySystem.FlowChartOptions(3).OptionNames = "Symbol option 3"
        MyUniverse.MySystem.FlowChartOptions(4).OptionNames = "Symbol option 4"
        MyUniverse.MySystem.FlowChartOptions(5).OptionNames = "Symbol option 5"
        MyUniverse.MySystem.FlowChartOptions(6).OptionNames = "Symbol option 6"
        MyUniverse.MySystem.FlowChartOptions(7).OptionNames = "Symbol option 7"
        MyUniverse.MySystem.FlowChartOptions(8).OptionNames = "Symbol option 8"
        MyUniverse.MySystem.FlowChartOptions(9).OptionNames = "Symbol option 9"
        MyUniverse.MySystem.FlowChartOptions(10).OptionNames = "Symbol option 10"

        MyUniverse.ProgramOptions.SymbolChanged = False



        Options.ListBoxSymbolData.Items.Item(20) = False

        If MyIsNothing(MyUniverse.ProgramOptions.FCCL_Dimension) Then 'default
            MyUniverse.ProgramOptions.FCCL_Dimension = " DIM   Variable AS DataType" 'default
        End If
        If MyIsNothing(MyUniverse.ProgramOptions.FCCL_MultiLine) Then 'default
            MyUniverse.ProgramOptions.FCCL_MultiLine = ":" 'default
        End If
        If MyIsNothing(Options.ListBoxSymbolData.Items.Item(21).ToString) Then
            Options.ListBoxSymbolData.Items.Item(21) = "'"       'Chr(34).ToString
        End If
        If MyIsNothing(ThisExtension(Options.ListBoxSymbolData.Items.Item(25).ToString, 1)) Then
            Options.ListBoxSymbolData.Items.Item(25) = ".txt"
        End If
        If MyIsNothing(MyUniverse.ProgramOptions.FCCL_VarChars) Then
            MyUniverse.ProgramOptions.FCCL_VarChars = "_."
        End If
        If MyIsNothing(Options.ListBoxSymbolData.Items.Item(23).ToString) Then
            Options.ListBoxSymbolData.Items.Item(23) = "Generic"
        End If
        If MyIsNothing(MyUniverse.SysGen.Markers.BranchToNextLine) Then
            MyUniverse.SysGen.Markers.BranchToNextLine = AddRM("BranchTo")
        End If
        If MyIsNothing(MyUniverse.SysGen.Markers.CameFromLine) Then
            MyUniverse.SysGen.Markers.CameFromLine = AddRM("CameFrom")
        End If

        If MyIsNothing(MyUniverse.ProgramOptions.FCCL_WhiteSpace) Then
            MyUniverse.ProgramOptions.FCCL_WhiteSpace = VBSpace
        End If


        MyUniverse.ProgramOptions.HelpURL = "FILE:\\" & MyUniverse.MyDir_s.HelpFiles & "\FlowChartHelpFiles/FlowChartHelp012.html"
        MyUniverse.SysGen.Constants.ConstantQuote = Chr(34) ' changed 20231212 VBSpace & Chr(34) & VBSpace ' Put white space around quotes 2020 08 20
        MyUniverse.SysGen.Markers.AlphaNumeric = AddRM("AlphaNumeric")
        MyUniverse.SysGen.Markers.Alphas = AddRM("Alpha")
        MyUniverse.SysGen.Markers.Block = AddRM("Block")
        MyUniverse.SysGen.Markers.Comments = AddRM("Comment")
        MyUniverse.SysGen.Markers.DataType = AddRM("DataType")
        MyUniverse.SysGen.Markers.FieldDelimiters = AddRM("FieldDelimiter")
        MyUniverse.SysGen.Markers.Functions = AddRM("Function")
        MyUniverse.SysGen.Markers.Grammar = AddRM("Grammar")
        MyUniverse.SysGen.Markers.HexRange = AddRM("HexRange")
        MyUniverse.SysGen.Markers.KeyWords = AddRM("KeyWord")
        MyUniverse.SysGen.Markers.Markers = AddRM("Markers")
        MyUniverse.SysGen.Markers.Literal = AddRM("Literal")
        MyUniverse.SysGen.Markers.Numbers = AddRM("Numbers")
        MyUniverse.SysGen.Markers.Operators = AddRM("Operator")
        MyUniverse.SysGen.Markers.Quotes = AddRM("quote") '<"">
        MyUniverse.SysGen.Markers.SpecialCharacter = AddRM("Special")
        MyUniverse.SysGen.Markers.UnicodeClass = AddRM("Unicode")
        MyUniverse.SysGen.Markers.Unknowns = AddRM("unknown")
        MyUniverse.SysGen.Markers.WhiteSpaces = AddRM("WhiteSpace")

    End Sub



    ' This is to isolate the actual data from the program (So that it can be converted later versions)
    Friend Function MyKeyword2String(Keyword As Integer) As String
        If Keyword < 0 Or Keyword > MySizeOf(My_keyWord) Then Return ""
        Return My_keyWord(Keyword)
    End Function



    'Returns the number of the character string
    Friend Function MyKeyword2Number(Keyword As String) As Integer      'My_keyWord are now always in order, so I need to change this to a binary search (Cause the list can be in the thounsands)
        For MyKeyword2Number = CByte(LBound(My_keyWord)) To CByte(MySizeOf(My_keyWord))
            If My_keyWord(MyKeyword2Number) = Trim(Keyword) Then
                Return MyKeyword2Number
            End If
        Next
        MyKeyword2Number = CByte(LBound(My_keyWord)) ' all ways points to unknown?
        'A I N F O 2 (35)
    End Function


    'This fills temp MyArrays with a Symbols information
    ' changed on 20200711
    'This will return the index to to the Symbol graphics for this Symbol name
    Friend Function CorrectingIndexes(ByRef SourceForm As Source, SymbolName As String) As Integer
        Dim IndexNamed, IndexSymbol As Integer
        'Dim Index As Integer 'todo debug only needs to remove
        'log_X(4089, SymbolName)
        IndexNamed = BinarySearch4Index(Options.ListBoxSymbols, SymbolName)
        If IndexNamed <= ConstantMyErrorCode Or IndexNamed = 0 Then
            'A I N F O 2 (5)
            Return ConstantMyErrorCode ' This name is not a valid Symbol name in the table, so ignore it
        End If ' we have a valid Symbol, that should have graphics with it.
        'If there is a short cut then
        ' Get the short cut
        CorrectingIndexes = Named_TableSymbolIndexes(IndexNamed) 'Named_TableSymbolIndexes(SymbolName, IndexNamed)
        If CorrectingIndexes > 0 Then ' then it might be valid
            If Symbol_TableCoded_String(CorrectingIndexes) = "/name" Then ' it is the first of the Symbol graphics then every thing is ok
                If Symbol_TableSymbolName(CorrectingIndexes) = SymbolName Then
                    ' We have matching names, and it is the start of the Symbol graphics with a /name
                    'A I N F O 2 (-6)
                    Return CorrectingIndexes        ' This is a good record
                    'else we have to find/update it
                End If ' Pointing to the start of the wrong Symbol So Fix it
            Else
                logA(1334, SymbolName, Symbol_TableCoded_String(CorrectingIndexes), MyShowSymbolRecord(SourceForm, False, CorrectingIndexes))
            End If ' Pointing to something other than the start of the Symbol so fix it
            'Is the short cut valid
        End If ' We have a valid named Symbol, but not graphics (or the graphics point got lost) so fix it
        For CorrectingIndexes = 1 To TopOfListBox(Options.ListBoxSymbolKeyWordGraphics)
            If Symbol_TableCoded_String(CorrectingIndexes) = "/name" Then ' it is the first of the Symbol graphics then every thing is ok
                If Symbol_TableSymbolName(CorrectingIndexes) = SymbolName Then ' we also have a match so save it
                    If MyDebug(A_INFORMATION) Then
                        logA(2424, CorrectingIndexes.ToString, Named_TableSymbolIndexes(IndexNamed).ToString, SymbolName)
                    End If
                    Named_TableSymbolIndexes(IndexNamed, CorrectingIndexes)
                    'todo the pointers are not correct here!
                    Return CorrectingIndexes
                End If
            End If
        Next CorrectingIndexes
        'IndexSymbol = NewTopOfFile(SourceForm,  SourceForm, "Symbol")
        'Named_TableSymbolIndexes(IndexNamed, IndexSymbol) ' an error as it has no Symbol graphics, only a name
        If IndexNamed <= 0 And MyOptionTest(25) = True Then
            Named_TableSymbolIndexes(IndexNamed, AddNewSymbol(SourceForm, SymbolName, "ErrorBlinkStyle Missing 1599"))
        Else
            IndexSymbol = FindInSymbolList(SourceForm, SymbolName)
            If IndexSymbol <= 0 Then
                IndexSymbol = NewTopOfFile(Options.ListBoxSymbolKeyWordGraphics)
                Symbol_TableSymbolName(IndexSymbol, SymbolName)
                Symbol_TableCode(SourceForm, IndexSymbol, "/Name")
                Symbol_TableX1(IndexSymbol, 100 * IndexSymbol)
                Symbol_TableY1(IndexSymbol, 100 * IndexSymbol)
                Symbol_Table_X2(IndexSymbol, 0)
                Symbol_Table_Y2(IndexSymbol, 0)
                Symbol_Table_NameOfPoint(IndexSymbol, "notused" & CStr(IndexSymbol))
                'InsertSymbolLineRecord(SourceForm ,IndexSymbol, MyUniverse.MyStaticData.ZeroZeroZeroZero, SymbolName, "/name", "notused" & CStr(IndexSymbol))
            End If
            Return FindInSymbolList(SourceForm, SymbolName)
        End If
        CorrectingIndexes = ConstantMyErrorCode
    End Function


    Friend Function ReplaceWithActualControlCharacter(A As String) As String
        Dim RTN As String
        RTN = A
        RTN.Replace("CRLF", vbCrLf)
        RTN.Replace("FL_NUL", Chr(0))
        RTN.Replace("FL_SOH", Chr(1))
        RTN.Replace("FL_STX", Chr(2))
        RTN.Replace("FL_ETX", Chr(3))
        RTN.Replace("FL_EOT", Chr(4))
        RTN.Replace("FL_ENQ", Chr(5))
        RTN.Replace("FL_ACK", Chr(6))
        RTN.Replace("FL_BEL", Chr(7))
        RTN.Replace("FL_BS", Chr(8))
        RTN.Replace("FL_TAB", Chr(9))
        RTN.Replace("FL_LF", Chr(10))
        RTN.Replace("FL_VT", Chr(11))
        RTN.Replace("FL_FF", Chr(12))
        RTN.Replace("FL_CR", Chr(13))
        RTN.Replace("FL_SO", Chr(14))
        RTN.Replace("FL_SI", Chr(15))
        RTN.Replace("FL_DLE", Chr(16))
        RTN.Replace("FL_DC1", Chr(17))
        RTN.Replace("FL_DC2", Chr(18))
        RTN.Replace("FL_DC3", Chr(19))
        RTN.Replace("FL_DC4", Chr(20))
        RTN.Replace("FL_21", Chr(21))
        RTN.Replace("FL_SYN", Chr(22))
        RTN.Replace("FL_ETB", Chr(23))
        RTN.Replace("FL_CAN", Chr(24))
        RTN.Replace("FL_EM", Chr(25))
        RTN.Replace("FL_SUB", Chr(26))
        RTN.Replace("FL_ESC", Chr(27))
        RTN.Replace("FL_FS", Chr(28))
        RTN.Replace("FL_GS", Chr(29))
        RTN.Replace("FL_RS", Chr(30))
        RTN.Replace("FL_US", Chr(31))
        Return RTN
    End Function

    Friend Function FlowChart_Replacement_Text(ByRef SourceForm As Source, IndexFlowChart As Integer) As String ', MyString As String) As String
        Dim MyStringTemp As String
        Dim EditedString As String
        Dim FindingString As String
        Dim RePlacementString As String
        Dim temp As String
        Dim IndexNamed, FDLen, Z As Integer
        FDLen = Len(MyUniverse.SysGen.Constants.RMStart)
        'Find the Symbol
        IndexNamed = BinarySearch4Index(Options.ListBoxSymbols, FlowChart_TableSymbol_Name(SourceForm, IndexFlowChart))
        If IndexNamed < 1 Then
            Return Nothing
        End If
        EditedString = Named_TableSyntax(IndexNamed)
        MyStringTemp = MyShowAndUpDateProperties(SourceForm, IndexFlowChart)
        While Len(MyStringTemp) > 1
            Z = MyFirstOne(MyStringTemp, "?/")
            MyStringTemp = Mid(MyStringTemp, Z, Len(MyStringTemp))
            temp = Pop(MyStringTemp, MyUniverse.SysGen.Constants.ConstantDelimiters)
            FindingString = Mid(temp, 2, Len(temp))
            RePlacementString = Pop(MyStringTemp, "/") 'MyUniverse.SysGen.Constants.ConstantDelimiters)
            temp = EditedString
            EditedString = MyReplace(EditedString, FindingString, RePlacementString)
            If temp <> EditedString Then
                logA(2110, temp, EditedString)
            End If
        End While
        Return EditedString
    End Function


    Friend Function MyDeCompileOneLine(ByRef SourceForm As Source, IndexFlowChart As Integer, X As Integer, Y As Integer, TPar As String) As Integer
        Dim SymbolName As String
        Dim IndexNamed As Integer
        MyUniverse.SysGen.PlacementColumn = Indents(SourceForm, TPar)
        TPar = MyTrim(TPar)
        'If MyDebug(A_INFORMATION) = True Then
        logA(2957, MyUniverse.MySS.Inputs.LineNumberIn.ToString, TPar)
        If TPar = "" Then
            Return ConstantMyErrorCode
        End If
        logA(1085, IndexFlowChart.ToString, MyShowFlowChartRecord(SourceForm, False, IndexFlowChart))
        DisplayStatus(3208, X.ToString, Y.ToString, TPar)
        DoEvent(1, "DeCompile")
        DoEvent(21, "DeCompile")
        MyUniverse.MySS.Inputs.LineNumberIn += 1
        OLD.DisplayStatus(3209, MyUniverse.MySS.Inputs.LineNumberIn.ToString)
        '''''ShowAllWindows(ShowWindow, HideWindow, HideWindow, HideWindow)
        '
        'find out if this symbol already exist 
        IndexNamed = FindSymbolSyntax(SourceForm, TPar)
        If IndexNamed > ConstantMyErrorCode Then
            SymbolName = Named_TableSymbolName(IndexNamed)
        Else
            'todo this should be making a symbol
            'todo need to make the symbol name related to the syntax
            SymbolName = MakeNewName(SourceForm, "SYMBOL_", TPar)   'Nothing
            IndexNamed = AddNewSymbol(SourceForm, SymbolName, TPar)
            MakeSymbolOutLine(SourceForm, SymbolName)
            MakeSymbolPoints(X, Y, SymbolName, TPar)
            If MyOptionTest(34) Then
                PanToWorldXY(SourceForm, X, Y - 500)
            End If
        End If
        If IndexNamed <= 0 Then
            IndexNamed = MakeSymbolFromSyntax(SourceForm, TPar)
            If IndexNamed > 0 Then
                SymbolName = Named_TableSymbolName(IndexNamed)
                'todo to speed up DoEvent(210)
                PaintEachOne(SourceForm, TopOfListBox(SourceForm.ListBoxFlowChart) - 1)
                PaintEachOne(SourceForm, TopOfListBox(SourceForm.ListBoxFlowChart))
                PaintEachOne(SourceForm, TopOfListBox(SourceForm.ListBoxFlowChart) + 1)
                'todo to speed up DoEvent(211)

            Else
                logA(2251, TPar)
                If MyOptionTest(25) = True Then
                Else
                End If
            End If
            'todo  the Symbol is added twice here,.,
            MyPlacement(SourceForm, True)
            MakeUseANDPath(SourceForm, TPar, SymbolName, IndexNamed)
            PaintEachOne(SourceForm, TopOfListBox(SourceForm.ListBoxFlowChart) - 3)
            PaintEachOne(SourceForm, TopOfListBox(SourceForm.ListBoxFlowChart) - 2)
            PaintEachOne(SourceForm, TopOfListBox(SourceForm.ListBoxFlowChart) - 1)
            PaintEachOne(SourceForm, TopOfListBox(SourceForm.ListBoxFlowChart))
            SelectInToolStripDropDownButton(Options.ListBoxRotation, Named_TableSymbolName(IndexNamed))
        Else
            MakeUseANDPath(SourceForm, TPar, SymbolName, IndexNamed)
            TPar = "" ' End of this Line?
            PaintAll(SourceForm, TopOfListBox(SourceForm.ListBoxFlowChart) - 1, TopOfListBox(SourceForm.ListBoxFlowChart) + 1)
        End If
        'should we be searching for keyLine, or SymbolName? (Changed to SymbolName 2020 08 17 for no reason
        If MyDebug(A_DISPLAY) Then logA(1204, SymbolName)
        IndexNamed = BinarySearch4Index(Options.ListBoxSymbols, SymbolName)
        If IndexNamed < 1 Then
            logA(2252, SymbolName)
            If MyOptionTest(25) = True Then
                If Len(SymbolName) = 0 Then
                    SymbolName = "MissingSymbolName" & MyRnd(6)
                    AddNewSymbol(SourceForm, SymbolName, TPar) ' todo this needs to create the named, or Symbol graphics
                Else
                    logA(1205, MyShowNamedRecord(False, IndexNamed))
                    AddNewSymbol(SourceForm, SymbolName, TPar) ' todo this needs to create the named, or Symbol graphics
                End If
            End If
        Else
            AddSymbolToDropDown(Named_TableSymbolName(IndexNamed))
            SelectInToolStripDropDownButton(Options.ListBoxRotation, Named_TableSymbolName(IndexNamed))
        End If

        OLD.Clear_Window(Library.PictureBox1)



        CheckAllSymbolsOnFlowChart(SourceForm)
        If SymbolOnTopOfSymbol(SourceForm, TopOfListBox(SourceForm.ListBoxFlowChart) - 1, TopOfListBox(SourceForm.ListBoxFlowChart)) = True Then
            OLD.Clear_Window(Library.PictureBox1)
        End If
        If SymbolOnTopOfSymbol(SourceForm, TopOfListBox(SourceForm.ListBoxFlowChart) - 1, TopOfListBox(SourceForm.ListBoxFlowChart) + 1) = True Then
            OLD.Clear_Window(Library.PictureBox1)
        End If
        'Dump2(SourceForm  )
        Return TopOfListBox(sBNF.sBNF_Grammar)
    End Function

    Friend Sub MyDeCompileLine(ByRef SourceForm As Source, tall As String) ' Converts each Line of source code into a FlowChart (and Symbol if required)
        Dim TPar As String
        Dim MyErrors As Integer
        Dim OldStatus As String
        Dim IndexFlowChart As Integer
        logA(4093, Mid(tall, 1, 64))
        tall = MyTrim(tall)
        If Len(tall) < 1 Then
            Return
        End If
        If MyLeft(MyTrim(tall), 1) = "/" Then
            If MyLeft(tall, 2) <> "//" Then   'For C code Lines starting with a comment
                ImportLineOrFile(SourceForm, tall)
                Return
            End If
        End If
        OldStatus = MyUniverse.MyProgramStatus
        MyUniverse.MyProgramStatus = "DECOMPILE"

        If MyOptionTest(36) Then
            While Len(tall) > 0
                TPar = PopLine(tall)
                MyUniverse.SysGen.PlacementColumn = Indents(Source, TPar)
                TPar = MyTrim(TPar)
                MyPlacement(SourceForm, True)
                IndexFlowChart = AddNEWFlowChartRecordPath(SourceForm, TPar, "/RAW", MyUniverse.SysGen.PlacementCurrent.x, MyUniverse.SysGen.PlacementCurrent.y, 0, 0, "ERROR")
                If MyDebug(A_INFORMATION) Then logA(2101, MyShowFlowChartRecord(SourceForm, False, IndexFlowChart))
            End While
            Return
        End If



        MyErrors = 1000000 'number of Lines of code or errors '9,223,372,036,854,775,807 ' This should be enough to avoid a forever loop
        '''''MyReSort("Named", TopOfFile(SourceForm, "named"))
        While MyErrors > 0  ' will exit when the end of file is reached.
            'DoEvent(2691)
            MyErrors -= 1
            TPar = PopLine(tall)
            While Len(tall) > 0 Or Len(TPar) <> 0
                While TPar = "" And tall <> ""
                    If Len(TPar) = 0 Then TPar = PopLine(tall)
                    'todo need to save the whitespace (for indenting the flowchart to match the source code)
                    MyUniverse.SysGen.PlacementColumn = Indents(Source, TPar)
                    TPar = MyTrim(TPar)
                End While
                MyDeCompileOneLine(SourceForm, ConstantMyErrorCode, MyUniverse.SysGen.PlacementCurrent.x, MyUniverse.SysGen.PlacementCurrent.y, TPar)
            End While
            If Len(tall) <= 0 Then
                MyUniverse.MyProgramStatus = OldStatus
                CheckAllSymbolsOnFlowChart(SourceForm)
                Return ' to avoid error count
            End If
        End While
        '''''ReSortSymbolList()
        CheckAllSymbolsOnFlowChart(SourceForm)
        MyUniverse.MyProgramStatus = OldStatus
        MyUniverse.ProgramOptions.FCCL_Roots = ""
        MyUniverse.ProgramOptions.FCCL_NotRoots = ""
        GetNewRoots(SourceForm)
    End Sub


    ' friend Function Syntax2MicroCodeText(IndexFlowChart As Integer) As String
    'todo 
    '   DIM   IndexNamed As Integer
    '      IndexNamed=FindInNamedList(FlowChart_TableSymbol_Name(SourceForm  ,  IndexFlowChart))
    '  Return CompileEachSymbol(IndexFlowChart)
    '  End Function



    Friend Function Raw2Symbol(ByRef SourceForm As Source, FlowChartIndex As Integer) As Integer
        Dim tPar As String
        Dim X, Y As Integer
        If FlowChart_TableCode(SourceForm, FlowChartIndex) <> "/raw" Then
            Return ConstantMyErrorCode
        End If
        tPar = FlowChart_TablePathName(SourceForm, FlowChartIndex)
        X = FlowChart_TableX1(SourceForm, FlowChartIndex)
        Y = FlowChart_TableY1(SourceForm, FlowChartIndex)
        MyUniverse.SysGen.PlacementColumn = Indents(Source, tPar)
        MyPlacement(SourceForm, True)
        If MyDebug(A_INFORMATION) Then logA(2103, MyShowPoint(MyUniverse.SysGen.PlacementCurrent), tPar)
        'this needs to not create another record, but instead replace the /raw with a /use
        Return MyDeCompileOneLine(SourceForm, FlowChartIndex, X, Y, tPar)
    End Function

    Friend Function MicroCodeText2Syntax(ByRef SourceForm As Source, Array() As String, MicroCodeText As String) As String
        Dim SSS As SourceSyntaxStructure = Nothing
        SSS.SourceCodeLine = MicroCodeText
        SSS.GrammarLine = ""
        SSS.SyntaxLine = ""
        ParseAll(SSS)
        Return MakeStatementSyntax(SourceForm, SSS.Source)
    End Function


    Friend Function ReCompileThisSymbol(ByRef SourceForm As Source, Syntax As String, IndexFlowChart As Integer) As String
        Dim Marker, ReplaceWith, Question, Answers As String
        Dim i, j, k, l As Integer
        Question = Syntax
        Answers = MyShowAndUpDateProperties(SourceForm, IndexFlowChart)
        i = MyInStr(MyUniverse.SysGen.Constants.RMStart, Question)
        j = MyInStr(MyUniverse.SysGen.Constants.RMEnd, Question)
        While i > 0
            If i > 0 Then
                If j > 0 Then
                    Marker = Mid(Question, i, j - i + Len(MyUniverse.SysGen.Constants.RMEnd))
                    k = MyInStr(Marker, Answers)
                    If k <> 0 Then
                        l = MyInStr("=", Answers, k)
                        i = MyInStr("/", Answers, l)
                        ReplaceWith = Mid(Answers, l, i - l)
                    Else
                        Question = Question.Replace(Marker, " Error ")
                        If MyDebug(A_INFORMATION) Then logA(2735, Marker, Mid(Answers, i, j - i + 1))
                    End If
                End If
            End If
            i = MyInStr(MyUniverse.SysGen.Constants.RMStart, Question)
            j = MyInStr(MyUniverse.SysGen.Constants.RMEnd, Question)
        End While
        Return Question
    End Function




    Friend Sub MyCompile(ByRef SourceForm As Source) ' Converts from a FlowChart into Source Code
        Dim IndexFlowChart As Integer
        Dim IndexNamed As Integer
        Dim IndexSymbol As Integer
        Dim IndexNetLinks As Integer
        Dim OutputFileName As String
        Dim MyCode As String
        Dim Temp As String
        Dim Connections As String

        MyUniverse.MySS = FillImportLine()

        '''''ShowAllWindows(ShowWindow, HideWindow, HideWindow, HideWindow)
        Clear_Window_Only(SourceForm.FlowChartPictureBox)
        OutputFileName = XOpenFile("compile", "Saving the compiled source For " & MyUniverse.SysGen.Constants.DrillDown_FileName & "." & ThisExtension(Options.ListBoxSymbolData.Items.Item(25).ToString, 1)) ' 2020 08 10 , DrillDownFileName)
        If OutputFileName = Nothing Then Return
        If Dir(OutputFileName) = "" Then ' need to create the file if it does not exist then you can ... 
            'System.IO.File.Create(OutputFileName)
            Using Writer As System.IO.StreamWriter = System.IO.File.CreateText(OutputFileName)
            End Using
        End If
        Using mywriter As New StreamWriter(OutputFileName)
            If MyOptionTest(59) Then
                Clear_Window_Only(SourceForm.FlowChartPictureBox)
                For IndexNetLinks = 1 To SourceForm.ListBoxVariables.Items.Count - 1
                    'todo need to make this into a valid statement to define a variable's data type ( DIM   X as DataType, Datatype X; )
                    logA(2262, MyShowNetLinks(SourceForm, IndexNetLinks))
                    Temp = Net_TableLinks(IndexNetLinks)
                    MyCode = MyUniverse.ProgramOptions.FCCL_Dimension
                    MyCode = Strings.Replace(MyCode, "DataType", FlowChart_TableDataType(SourceForm, PopNonZeroValue(Temp)), 1, 10)
                    MyCode = Strings.Replace(MyCode, "Variable", Net_TablePathNames(IndexNetLinks), 1, 10)
                    MyWriteLine1(mywriter, MyCode)
                    MyWriteLine1(mywriter, MyShowNetLinks(SourceForm, IndexNetLinks))
                    While Len(Temp) > 0
                        IndexFlowChart = PopValue(Temp)
                        PaintAll(SourceForm, IndexFlowChart, IndexFlowChart)
                    End While
                Next IndexNetLinks
            End If

            For IndexFlowChart = 1 To TopOfListBox(SourceForm.ListBoxFlowChart)
                PaintAll(SourceForm, IndexFlowChart, IndexFlowChart)
                Connections = MyShowAndUpDateProperties(SourceForm, IndexFlowChart) ',MyUniverse.MySS.Inputs.LineNumberIn,FlowChart_tablePathSymbolName(SourceForm, IndexFlowChart))
                '''''ReSetScrollBars(IndexFlowChart)
                Select Case FlowChart_TableCode(SourceForm, IndexFlowChart)
                    Case My_keyWord(My_KeyConstUse)
                        IndexNamed = BinarySearch4Index(Options.ListBoxSymbols, FlowChart_TableSymbol_Name(SourceForm, IndexFlowChart))
                        IndexSymbol = Named_FileSymbolName_ISAM(IndexNamed)
                        ' Added 3/16/19 for check of replacements
                        MyCode = CompileEachSymbol(SourceForm, IndexFlowChart)
                        'CheckBoxOutputLineNumbers
                        If MyOptionTest(16) = True Then
                            MyCode = MyCode & Options.ListBoxSymbolData.Items.Item(21).ToString & " Line " & MyUniverse.MySS.Inputs.LineNumberIn
                        Else
                        End If
                        MyWriteLine1(mywriter, MyCode)
                        MyUniverse.MySS.Inputs.LineNumberIn += 1
                        OLD.DisplayStatus(3212, MyUniverse.MySS.Inputs.LineNumberIn.ToString)
                        MyPlacement(SourceForm, True)'Third place it should add
                    Case "/path"
                        RouterConnectPath(SourceForm, IndexFlowChart)
                    Case "/error"
                    Case "/constant"
                    Case "/Delete"
                    Case Else
                        logA(2231, FlowChart_TableCode(SourceForm, IndexFlowChart), IndexFlowChart.ToString)
                End Select
            Next
        End Using
        'FileClose(MyWriter)
        'End Using
        OLD.Clear_Window(SourceForm.FlowChartPictureBox)
    End Sub



    'Routine 'Compile' is where it starts checking, then makes the text Output
    Friend Function CompileEachSymbol(ByRef SourceForm As Source, IndexFlowChart As Integer) As String
        'Get the links between the Symbols (path names)

        'Replace the code with the names of the paths (And other information)
        CompileEachSymbol = CompileThisSymbol(SourceForm, IndexFlowChart) ' Write out this Symbol then get the next one to do
        If MyDebug(A_STATUS) Then logA(2134, CompileEachSymbol & vbCrLf)
    End Function


    Friend Function RouterMakePaths(ByRef SourceForm As Source, IndexFlowChart1 As Integer, IndexFlowChart2 As Integer) As Boolean
        Dim SymbolNamed As String 'Links,DataTypeIs 
        Dim X1, Y1, X2, Y2 As Integer
        Dim NetIndex1, NetIndex2 As Integer
        Dim NetLinks1, NetLinks2 As String
        Dim A1, A2 As String
        Dim InNetLinksAt As Integer
        If IndexFlowChart1 = IndexFlowChart2 Then
            Return False ' do not make a path from itself to itself
        End If
        logA(2345, "Router make paths " & MyShowFlowChartRecord(SourceForm, False, IndexFlowChart1) & CT & MyShowFlowChartRecord(SourceForm, False, IndexFlowChart2))

        'must be /paths
        If FlowChart_TableCode(SourceForm, IndexFlowChart1) <> "/path" Then
            Return False
        End If
        If FlowChart_TableCode(SourceForm, IndexFlowChart2) <> "/path" Then
            Return False
        End If

        NetIndex1 = FlowChart_TablePathNumber(SourceForm, IndexFlowChart1)
        NetIndex2 = FlowChart_TablePathNumber(SourceForm, IndexFlowChart2)
        NetLinks1 = Net_TableLinks(IndexFlowChart1)
        NetLinks2 = Net_TableLinks(IndexFlowChart2)

        If NetLinks1 = "" And NetLinks2 = "" And NetIndex1 < 0 And NetIndex2 < 0 Then
            'todo need to put a message in here that there is a problem all oer the place, well between these two 
            Return False
        End If

        If NetLinks1 = "" Or NetLinks2 = "" Then
            logA(2903, NetLinks1, NetLinks2)
            If MyOptionTest(25) = True Then
            Else
            End If
        End If

        'error two nets are the same, so should delete one
        If IndexFlowChart1 <> IndexFlowChart2 Then
            If NetLinks1 = NetLinks2 Then
                logA(2904, MyShowNetLinks(SourceForm, NetIndex1), MyShowNetLinks(SourceForm, NetIndex2), MyShowFlowChartRecord(SourceForm, True, IndexFlowChart1), MyShowFlowChartRecord(SourceForm, True, IndexFlowChart2))
                If MyOptionTest(25) = True Then
                Else
                End If
            Else
                logA(2905, MyShowNetLinks(SourceForm, IndexFlowChart1), MyShowNetLinks(SourceForm, IndexFlowChart2))
                If MyOptionTest(25) = True Then
                Else
                End If
                Return False 'cause the paths are already connected
            End If
        Else
            logA(2906, MyShowFlowChartRecord(SourceForm, False, IndexFlowChart1), MyShowFlowChartRecord(SourceForm, False, IndexFlowChart2))
            If MyOptionTest(25) = True Then
            Else
            End If
        End If


        InNetLinksAt = IndexFlowChart1
        If InNetLinksAt < 0 Then
            logA(1207, InNetLinksAt.ToString, IndexFlowChart1.ToString, MyShowFlowChartRecord(SourceForm, False, IndexFlowChart1))
            MakeNewNetLinks(SourceForm, IndexFlowChart1, Net_TablePathNames(FlowChart_TablePathNumber(SourceForm, IndexFlowChart1)))
        End If

        If NetLinks1 <> NetLinks2 Then
            'we should be combine two deferent named nets together?
            logA(2907, IndexFlowChart1.ToString, IndexFlowChart2.ToString, MyShowNetLinks(SourceForm, NetIndex1), MyShowNetLinks(SourceForm, NetIndex2))
            If MyOptionTest(25) = True Then
            Else
            End If
            SymbolNamed = FlowChart_TablePathName(SourceForm, IndexFlowChart1) & "&" & FlowChart_TablePathName(SourceForm, IndexFlowChart1)
        Else
            SymbolNamed = FlowChart_TablePathName(SourceForm, IndexFlowChart1)
        End If

        ' Must have the same name (maybe, or else it is an error , it is an error, )
        If FlowChart_TablePathName(SourceForm, IndexFlowChart1) <> FlowChart_TablePathName(SourceForm, IndexFlowChart2) Then Return False

        'From the second point in one
        X1 = FlowChart_TableX2(SourceForm, IndexFlowChart1)
        Y1 = FlowChart_TableY2(SourceForm, IndexFlowChart1)
        'To the second point in the other
        X2 = FlowChart_TableX2(SourceForm, IndexFlowChart2)
        Y2 = FlowChart_TableY2(SourceForm, IndexFlowChart2)
        ' should also clean the two of them out 
        A1 = Net_TableLinks(IndexFlowChart1)
        A2 = Net_TableLinks(IndexFlowChart2)
        MyDrawWindowPath(SourceForm, MyLine1(SourceForm, X1, Y1, X2, Y2), "")
        MyShowAndUpDateProperties(SourceForm, TopOfListBox(SourceForm.ListBoxFlowChart)) ', LineNumber, SymbolNamed)
        AddNEWFlowChartRecordPath(SourceForm, SymbolNamed, "/path", X1, Y1, X2, Y2, "debugging") ')
        Return True
    End Function


    Friend Sub MyShowWorldRouter(ByRef SourceForm As Source, XY1 As MyLineStructure, XY2 As MyLineStructure)
        Dim T As MyLineStructure
        'This should make a world showing the line being routed
        T = Nothing

        T.a.x = XY1.a.x : T.a.y = XY1.a.y : T.b.x = XY2.a.x : T.b.y = XY2.a.y
        If MyOptionTest(34) Then
            PanToWorldXYXY(SourceForm, T.a.x, T.a.y, T.b.x, T.b.y)
            PaintAll(SourceForm, 1, TopOfListBox(SourceForm.ListBoxFlowChart))
            MyDrawWorldPaths(SourceForm, XY1, XY2)
            MyDrawWorldPath(SourceForm, XY2, RandomColor(SourceForm))
            T.a.x = XY1.a.x : T.a.y = XY1.a.y : T.b.x = XY2.b.x : T.b.y = XY2.b.y
            MyDrawWorldPath(SourceForm, XY2, RandomColor(SourceForm))
            T.a.x = XY1.b.x : T.a.y = XY1.b.y : T.b.x = XY2.a.x : T.b.y = XY2.a.y
            MyDrawWorldPath(SourceForm, XY2, RandomColor(SourceForm))
            T.a.x = XY1.b.x : T.a.y = XY1.b.y : T.b.x = XY2.b.x : T.b.y = XY2.b.y
            MyDrawWorldPath(SourceForm, XY2, RandomColor(SourceForm))

            MyDrawWorldPath(SourceForm, XY1, "debugging")
            MyDrawWorldPath(SourceForm, XY2, "debugging")
        End If
        Return
    End Sub




    'todo it is not getting CommandLine.* when starting 'bug
    Friend Function MyShowAndUpDateProperties(ByRef SourceForm As Source, IndexFlowChart As Integer) As String '/Use fills in information /Path adds to net number list and saves net number into links
        ' DIM   LocalIndex As Integer
        Dim RTN As String
        Dim IndexNamed, IndexSymbol, IndexPath As Integer
        Dim MY_DataTypeName, My_RotationName, My_Input_Output_Both, MyPathName As String
        Dim My_DataTypeIndex As Integer
        Dim ThisPointName, ThisSymbolName As String ' holds the name
        Dim Temp As String
        Dim SymbolXY As MyPointStructure
        Dim MyPathX, MyPathY As Integer
        ' DIM   Debug1 As Boolean

        RTN = ""

        'todo which one?  
        'The following causes the links to be save twice in size
        Select Case FlowChart_TableCode(SourceForm, IndexFlowChart)
            Case "/delete"
                Return RTN
            Case My_keyWord(My_KeyConstUse)  ' Find all of the points of a Symbol (And Put them Together in FCStatus)
                IndexNamed = AddInTable(Options.ListBoxSymbols, FlowChart_TableSymbol_Name(SourceForm, IndexFlowChart))
                If IndexNamed = ConstantMyErrorCode Then ' We can not find the index, so we should add it.
                    Return RTN
                End If
                IndexSymbol = CorrectingIndexes(SourceForm, FlowChart_TableSymbol_Name(SourceForm, IndexFlowChart))
                ThisSymbolName = FlowChart_TableSymbol_Name(SourceForm, IndexFlowChart)
                RTN = ""
                Temp = vbCrLf & "/" & ThisSymbolName & ".name" & "=" & PrintAbleNull(ThisSymbolName) ' This Symbol name
                RTN &= Temp ' I am doing this twice, because I throw away the first one.
                RTN &= Temp

                Temp = vbCrLf & "/" & ThisSymbolName & ".index" & "=" & PrintAbleNull(IndexFlowChart.ToString)
                RTN &= Temp
                Temp = vbCrLf & "/" & ThisSymbolName & ".x" & "=" & FlowChart_TableX1(SourceForm, IndexFlowChart).ToString
                RTN &= Temp
                Temp = vbCrLf & "/" & ThisSymbolName & ".y" & "=" & FlowChart_TableY1(SourceForm, IndexFlowChart).ToString
                RTN &= Temp
                'rotation
                Temp = vbCrLf & "/" & ThisSymbolName & ".Rotation" & "=" & FlowChart_Table_Rotation(SourceForm, IndexFlowChart)
                RTN &= Temp
                Temp = vbCrLf & "/" & ThisSymbolName & ".DataType" & "=" & PrintAbleNull(FlowChart_TableDataType(SourceForm, IndexFlowChart))
                RTN &= Temp
                Temp = vbCrLf & "/" & ThisSymbolName & ".OpCode" & "=" & PrintAbleNull(Named_TableOpCode(IndexNamed))
                RTN &= Temp
                Temp = vbCrLf & "/" & ThisSymbolName & ".notes" & "=" & PrintAbleNull(Named_TableNotes(IndexNamed))
                RTN &= Temp
                Temp = vbCrLf & "/" & ThisSymbolName & ".FileName" & "=" & PrintAbleNull(Named_TableNameOfFile(IndexNamed))
                RTN &= Temp
                Temp = vbCrLf & "/" & ThisSymbolName & ".Author" & "=" & PrintAbleNull(Named_TableAuthor(IndexNamed))
                RTN &= Temp
                Temp = vbCrLf & "/" & ThisSymbolName & ".Version" & "=" & PrintAbleNull(Named_TableVersion(IndexNamed))
                RTN &= Temp
                Temp = vbCrLf & "/" & ThisSymbolName & ".Stroke" & "=" & PrintAbleNull(Named_TableStroke(IndexNamed))
                RTN &= Temp
                Temp = vbCrLf & "/" & ThisSymbolName & ".Indexes" & "=" & Named_TableSymbolIndexes(IndexNamed)
                RTN &= Temp

                If IndexSymbol > 0 Then
                    If Symbol_TableCoded_String(IndexSymbol) = "/name" Then
                        My_RotationName = FlowChart_Table_Rotation(SourceForm, IndexFlowChart)
                        Temp = vbCrLf & "/" & ThisSymbolName & ".name" & "=" & PrintAbleNull(Symbol_TableSymbolName(IndexSymbol))
                        RTN &= Temp
                        Temp = vbCrLf & "/" & ThisSymbolName & ".xa" & "=" & MyRotated(SourceForm, IndexSymbol, IndexFlowChart).x
                        RTN &= Temp
                        Temp = vbCrLf & "/" & ThisSymbolName & ".ya" & "=" & MyRotated(SourceForm, IndexSymbol, IndexFlowChart).y
                        RTN &= Temp
                        Temp = vbCrLf & "/" & ThisSymbolName & ".rotation" & "=" & PrintAbleNull(My_RotationName)
                        RTN &= Temp
                        If MyStrComp(Symbol_TableSymbolName(IndexSymbol), FlowChart_TableSymbol_Name(SourceForm, IndexFlowChart)) = 0 Then ' Making sure that is right
                            Temp = vbCrLf & "/" & ThisSymbolName & ".code" & "=" & PrintAbleNull(VBSpace & NoRM(Named_TableMicroCodeText(IndexSymbol)) & VBSpace)
                            RTN &= Temp & "***"
                            IndexSymbol += 1
                            While Symbol_TableCoded_String(IndexSymbol) <> "/name" And IndexSymbol <= TopOfListBox(Options.ListBoxSymbols)
                                Select Case Symbol_TableCoded_String(IndexSymbol)
                                    Case "/point"
                                        If MyDebug(A_STATUS) Then logA(1650, IndexSymbol.ToString, MyShowSymbolGraphic(False, IndexSymbol))
                                        '''''  FixSyxtaxCode(IndexNamed)
                                        ThisPointName = NameOfPointOnly(Symbol_Table_NameOfPoint(IndexSymbol))
                                        Temp = vbCrLf & "/" & ThisPointName & ".name" & "=" & PrintAbleNull(ThisPointName)
                                        RTN &= vbCrLf & "\\" & Temp
                                        Temp = vbCrLf & "/" & ThisPointName & ".index" & "=" & PrintAbleNull(IndexSymbol.ToString)
                                        RTN &= Temp
                                        My_RotationName = FlowChart_Table_Rotation(SourceForm, IndexFlowChart)
                                        My_Input_Output_Both = Symbol_Table_InputOutput(IndexSymbol)
                                        MY_DataTypeName = Symbol_Table_DataType(IndexSymbol)
                                        My_DataTypeIndex = FindDataTypeIndex(MY_DataTypeName)
                                        Temp = vbCrLf & "/" & ThisPointName & ".name" & "=" & PrintAbleNull(Symbol_Table_NameOfPoint(IndexSymbol))
                                        RTN &= Temp
                                        SymbolXY.x = MyRotated(SourceForm, IndexSymbol, IndexFlowChart).x
                                        SymbolXY.y = MyRotated(SourceForm, IndexSymbol, IndexFlowChart).y
                                        Temp = vbCrLf & "/" & ThisPointName & ".x" & "=" & PrintAbleNull(MyRotated(SourceForm, IndexSymbol, IndexFlowChart).x.ToString)
                                        MyPathX = MyRotated(SourceForm, IndexSymbol, IndexFlowChart).x
                                        RTN &= Temp
                                        Temp = vbCrLf & "/" & ThisPointName & ".y" & "=" & PrintAbleNull(MyRotated(SourceForm, IndexSymbol, IndexFlowChart).y.ToString)
                                        MyPathY = MyRotated(SourceForm, IndexSymbol, IndexFlowChart).y
                                        RTN &= Temp
                                        Temp = vbCrLf & "/" & ThisPointName & ".IO" & "=" & PrintAbleNull(My_Input_Output_Both)
                                        RTN &= Temp
                                        Temp = vbCrLf & "/" & ThisPointName & ".Rotation" & "=" & PrintAbleNull(My_RotationName)
                                        RTN &= Temp
                                        Temp = vbCrLf & "/" & ThisPointName & ".DataType" & "=" & PrintAbleNull(MY_DataTypeName)
                                        RTN &= Temp

                                        IndexPath = FindPathNameAt(SourceForm, MyPoint1XY(MyPathX, MyPathY))
                                        If IndexPath > 0 Then
                                            MyPathName = FlowChart_TablePathName(SourceForm, IndexPath) 'data type
                                            'PathX=MyRotated_1(IndexSymbol, IndexPath, My_RotationName).X
                                            'PathY=MyRotated_1(IndexSymbol, IndexPath, My_RotationName).Y
                                            ' 2020  07 16 change it to have not rotation aor Symbol (Cause Im calling the wrong subroutine.) 

                                            If MyDistance(MyPoint1XY(FlowChart_TableX1(SourceForm, IndexPath), FlowChart_TableY1(SourceForm, IndexPath)), MyPoint2XY(SymbolXY.x, SymbolXY.y)) < MyDistance(MyPoint1XY(FlowChart_TableX2(SourceForm, IndexPath), FlowChart_TableY2(SourceForm, IndexPath)), MyPoint2XY(SymbolXY.x, SymbolXY.y)) Then
                                                MyPathX = FlowChart_TableX1(SourceForm, IndexPath)
                                                MyPathY = FlowChart_TableY1(SourceForm, IndexPath)
                                            Else
                                                MyPathX = FlowChart_TableX2(SourceForm, IndexPath)
                                                MyPathY = FlowChart_TableY2(SourceForm, IndexPath)
                                            End If
                                            'PathX=MyRotated_1(0, IndexPath, "default").X
                                            'PathY=MyRotated_1(0, IndexPath, "default").Y
                                            Temp = vbCrLf & "/" & ThisPointName & ".PathName" & "=" & PrintAbleNull(MyPathName)
                                            RTN &= Temp
                                            'Temp=vbCrLf & "/" &  ThisPointName & ".Name") & "=" & PrintAbleNull(MyPathName)
                                            'RTN &= Temp
                                            Temp = vbCrLf & "/" & ThisPointName & ".Variable" & "=" & PrintAbleNull(MyPathName)
                                            RTN &= Temp
                                            Temp = vbCrLf & "/" & ThisPointName & ".PathX" & "=" & PrintAbleNull(MyPathX.ToString)
                                            RTN &= Temp
                                            Temp = vbCrLf & "/" & ThisPointName & ".pathY" & "=" & PrintAbleNull(MyPathY.ToString)
                                            RTN &= Temp
                                            'todo This is not the distance from the Symbol to the path
                                            Temp = vbCrLf & "/" & ThisPointName & ".Distance =" & MyDistance(MyRotated_1(IndexSymbol, FlowChart2Point(SourceForm, IndexFlowChart), My_RotationName), MyPoint2XY(FlowChart_TableX1(SourceForm, IndexFlowChart), FlowChart_TableY1(SourceForm, IndexFlowChart)))
                                            RTN &= vbCrLf & "\\" & Temp
                                            Temp = vbCrLf & "/" & ThisPointName & ".Distance" & "=" & MyDistance(MyPoint2XY(MyPathX, MyPathY), MyPoint2XY(FlowChart_TableX1(SourceForm, IndexFlowChart), FlowChart_TableY1(SourceForm, IndexFlowChart)))
                                            RTN &= vbCrLf & "\\" & Temp
                                            Temp = vbCrLf & "/" & ThisPointName & ".DataTypeName" & "=" & MY_DataTypeName
                                            RTN &= Temp
                                            Temp = vbCrLf & "/" & ThisPointName & ".DataTypeDescription" & "=" & DataType_TableDescription(My_DataTypeIndex)
                                            RTN &= Temp
                                            Temp = vbCrLf & "/" & ThisPointName & ".Bytes" & "=" & DataType_TableNumberOfBytes(My_DataTypeIndex)
                                            RTN &= Temp

                                            Temp = vbCrLf & "/" & ThisPointName & ".DataTypeColor" & "=" & FindColorFromDataType(DataType_TableName(My_DataTypeIndex))
                                            If MyDebug(A_INFORMATION) Then logA(2136, IndexFlowChart.ToString, Temp)
                                            RTN &= Temp
                                            Temp = vbCrLf & "/" & ThisPointName & ".Width" & "=" & DataType_TableWidth(My_DataTypeIndex)
                                            RTN &= Temp
                                        Else 'no path connected
                                            Temp = vbCrLf & "/" & MakeNewName(SourceForm, "Errored_", "No Path Connected") & ".PathName" & "=NULL)"
                                            RTN &= vbCrLf & "\\" & Temp
                                        End If
                                    Case "/line" ' Ignore
                                    Case Else
                                        logA(2908, MyShowNamedAndSymbolRecords(SourceForm, True, IndexSymbol), Symbol_TableCoded_String(IndexSymbol))
                                        If MyOptionTest(25) = True Then
                                        Else
                                        End If
                                End Select
                                IndexSymbol += 1
                            End While
                        End If
                    End If
                End If
                RTN &= "/BranchTo=BranchToNextLine " '& (1 + IndexFlowChart).ToString
    'Change the /path links to point to Net_TableLinks() number of this net link
            Case "/path" 'Find all of the Lines of a path (And put them together in FCStatus)
                RouterConnectPath(SourceForm, IndexFlowChart)
                FindAllPaths_2(SourceForm, IndexFlowChart) ', LineNumber, PathName) 'By Path Name
                RouterConnectPath(SourceForm, IndexFlowChart)
            Case "/constant" 'I'm ignoring this for now.
                If FlowChart_Table(SourceForm, IndexFlowChart) < 1 Then
                    logA(1210, IndexFlowChart.ToString, MyShowFlowChartRecord(SourceForm, False, IndexFlowChart))
                    MakeNewNetLinks(SourceForm, IndexFlowChart, FlowChart_TablePathName(SourceForm, IndexFlowChart))
                End If
            Case "/error"
                Dump3(2909, "BUG ? : MyShowAndUpDateProperties " & MyShowFlowChartRecord(SourceForm, False, IndexFlowChart))    ' Not sure if this is a bug
                'FlowChart_TableCompiledMacroCodeText(IndexFlowChart , "/error" & Comma &  FlowChart_TableX1(SourceForm, IndexFlowChart ) & Comma &  FlowChart_TableY1(SourceForm    , SourceForm    , IndexFlowChart ) & Comma &  FlowChart_TableDataType(SourceForm , IndexFlowChart ) & Comma &  FlowChart_TablePathName(SourceForm, IndexFlowChart ))
                If MyOptionTest(25) = True Then
                Else
                End If
            Case "/RAW"
                Raw2Symbol(SourceForm, IndexFlowChart)
                FlowChart_TableCode(SourceForm, IndexFlowChart, "/Delete")
                Dump2(SourceForm) 'todo remove this
            Case Else
                logA(2910, FlowChart_TableCode(SourceForm, IndexFlowChart), CStr(IndexFlowChart), MyShowFlowChartRecord(SourceForm, False, IndexFlowChart))
        End Select

        'RTN &= "/MarkerAlphaNumeric=" & MyUniverse.SysGen.Markers.AlphaNumeric
        'RTN &= "/MarkerAlphas=" & MyUniverse.SysGen.Markers.Alphas
        'RTN &= "/MarkerBlock=" & MyUniverse.SysGen.Markers.Block
        'RTN &= "/MarkerBranchToNextLine=" & MyUniverse.SysGen.Markers.BranchToNextLine
        'RTN &= "/MarkerCameFromLine=" & MyUniverse.SysGen.Markers.CameFromLine
        'RTN &= "/MarkerComments=" & MyUniverse.SysGen.Markers.Comments
        'RTN &= "/MarkerDataType=" & MyUniverse.SysGen.Markers.DataType
        'RTN &= "/MarkerFieldDelimiters=" & MyUniverse.SysGen.Markers.FieldDelimiters
        'RTN &= "/MarkerFunctions=" & MyUniverse.SysGen.Markers.Functions
        'RTN &= "/MarkerGrammar=" & MyUniverse.SysGen.Markers.Grammar
        'RTN &= "/MarkerKeyWords=" & MyUniverse.SysGen.Markers.KeyWords
        'RTN &= "/MarkerNumbers=" & MyUniverse.SysGen.Markers.Numbers
        'RTN &= "/MarkerOperators=" & MyUniverse.SysGen.Markers.Operators
        'RTN &= "/MarkerSpecialCharacters=" & MyUniverse.SysGen.Markers.SpecialCharacter
        'RTN &= "/MarkerQuotes=" & MyUniverse.SysGen.Markers.Quotes
        'RTN &= "/MarkerUnknowns=" & MyUniverse.SysGen.Markers.Unknowns
        'RTN &= "/MarkerWhiteSpaces=" & MyUniverse.SysGen.Markers.WhiteSpaces

        RTN &= "/ConstantDelimiters=" & MyUniverse.SysGen.Constants.ConstantDelimiters
        RTN &= "/ConstantDistanceBetweenControls=" & MyUniverse.SysGen.Constants.ConstantDistanceBetweenControls
        RTN &= "/ConstantDistanceToMovePaths=" & MyUniverse.SysGen.Constants.ConstantDistanceToMovePaths
        RTN &= "/DrillDown_FileName=" & MyUniverse.SysGen.Constants.DrillDown_FileName
        RTN &= "/ConstantMaxPenSize=" & MyUniverse.SysGen.Constants.ConstantMaxPenSize
        RTN &= "/ConstantMinBoxSize=" & MyUniverse.SysGen.Constants.ConstantMinBoxSize
        RTN &= "/ConstantMinPenSize=" & MyUniverse.SysGen.Constants.ConstantMinPenSize
        RTN &= "/ConstantQuote=" & MyUniverse.SysGen.Constants.ConstantQuote
        RTN &= "/ConstantRecordsBeforeSaveIsAllowed=" & MyUniverse.SysGen.Constants.ConstantRecordsBeforeSaveIsAllowed
        RTN &= "/ConstantSpacingFactor=" & MyUniverse.SysGen.Constants.ConstantSpacingFactor
        RTN &= "/ConstantSpecialCharacters=" & MyUniverse.SysGen.Constants.ConstantSpecialCharacters
        RTN &= "/ConstantSymbolCenter=" & MyUniverse.SysGen.Constants.ConstantSymbolCenter
        RTN &= "/ConstantWhiteSpaces=" & MyUniverse.SysGen.Constants.ConstantWhiteSpaces
        Return RTN
    End Function

    Friend Sub MyMouseWheel(e As MouseEventArgs) 'catches the mouse wheel to zoom in or out
        If e.Delta() > 0 Then
            MyZoomIn()
        ElseIf e.Delta < 0 Then
            MyZoomOut()
        End If
    End Sub


    Friend Sub LimitScale()
        If MyUniverse.SysGen.MyFlowChartScale < ConstantMinFlowChartScale Then
            MyUniverse.SysGen.MyFlowChartScale = ConstantMinFlowChartScale '1/16
            'todo   '   DisplayStatus(3214,FlowChartWindow.LabelProgramStatus.Text, CStr(MyUniverse.SysGen.MyFlowChartScale))
        End If
        If MyUniverse.SysGen.MyFlowChartScale > ConstantMaxFlowChartScale Then
            MyUniverse.SysGen.MyFlowChartScale = ConstantMaxFlowChartScale
            DisplayStatus(99999, "FlowChart Scale limit is " & CStr(MyUniverse.SysGen.MyFlowChartScale))
        End If
        'todo need to also limit the Symbol scale from 1 to 4?
        If MyUniverse.SysGen.MySymbolScale > 8 Then
            MyUniverse.SysGen.MySymbolScale = 2
            DisplayStatus(99999, "Symbol Scale limit is " & MyUniverse.SysGen.MySymbolScale.ToString)
        End If
        If MyUniverse.SysGen.MySymbolScale < 1 Then
            MyUniverse.SysGen.MySymbolScale = 1
            DisplayStatus(99999, "Symbol Scale limit is " & MyUniverse.SysGen.MySymbolScale.ToString)
        End If
    End Sub


    'Routine Makes the pictures bigger
    Friend Sub MyZoomIn()
        MyUniverse.SysGen.MyFlowChartScale *= ConstantFlowChartScaleChange
        LimitScale()

        MyButtonsEnableRules(115)
    End Sub

    'Routine makes the picture smaller
    Friend Sub MyZoomOut() ' steps scale down
        MyUniverse.SysGen.MyFlowChartScale /= ConstantFlowChartScaleChange
        LimitScale()

    End Sub



    Friend Function FillMyPoint() As MyPointStructure
        FillMyPoint.x = 0
        FillMyPoint.y = 0
        FillMyPoint.Named.PathName = ""
        FillMyPoint.Named.SymbolName = ""
        FillMyPoint.Named.PointName = ""
        FillMyPoint.Named.IsWorldWindow = ""
    End Function

    Friend Function Rectangle2MyLine(XYXY As Rectangle) As MyLineStructure
        Rectangle2MyLine = Nothing
        Rectangle2MyLine.a.x = XYXY.X
        Rectangle2MyLine.a.y = XYXY.Y
        Rectangle2MyLine.b.x = XYXY.Width
        Rectangle2MyLine.b.y = XYXY.Height
        Return Rectangle2MyLine
    End Function

    Friend Sub QuickDrawLineWorld(ByRef SourceForm As Source, x1 As Integer, y1 As Integer, x2 As Integer, y2 As Integer, CLR As Pen)
        Dim XY1, XY2 As Point
        Dim XXYY As MyPointStructure = Nothing
        XXYY.x = x1
        XXYY.y = y1
        XXYY = Copy2WorldXY(SourceForm, "/", XXYY)
        XY1.X = XXYY.x
        XY2.X = XXYY.y

        XXYY.x = x2
        XXYY.y = y2
        XXYY = Copy2WorldXY(SourceForm, "/", XXYY)
        XY2.X = XXYY.x
        XY2.X = XXYY.y
        SourceForm.CreateGraphics.DrawLine(CLR, XY1, XY2)
    End Sub

    Friend Sub QuickDrawLine(ByRef SourceForm As Source, x1 As Integer, y1 As Integer, x2 As Integer, y2 As Integer, CLR As Pen)
        Dim XY1, XY2 As Point
        'todo need to test if inside window
        If InSideMyFlowChartWindow(SourceForm, MyLine1(SourceForm, x1, y1, x2, y2)) = False Then
            Return
        End If
        XY1 = MyPointStruct2Point(x1, y1)
        XY2 = MyPointStruct2Point(x2, y2)
        'XY1.X=x1
        'XY1.Y=y1
        'XY2.X=x2
        'XY2.Y=y2
        If MyDebug(A_STATUS) Then logA(1595, MyShowLineXYXY(x1, y1, x2, y2))
        SourceForm.CreateGraphics.DrawLine(CLR, XY1, XY2)
    End Sub



    Friend Function CenterOf2Lines(A As MyLineStructure, B As MyLineStructure) As MyPointStructure
        CenterOf2Lines = Nothing
        CenterOf2Lines.x = CInt((A.a.x + A.b.x + B.a.x + B.b.x) / 4)
        CenterOf2Lines.y = CInt((A.a.y + A.b.y + B.a.y + B.b.y) / 4)
        CenterOf2Lines.Named = A.a.Named
        Return CenterOf2Lines
    End Function


    Friend Sub PanToWorldXYXY(ByRef SourceForm As Source, x1 As Integer, Y1 As Integer, X2 As Integer, Y2 As Integer)
        PanToWorldXY(SourceForm, CInt((x1 + X2) / 2), CInt((Y1 + Y2) / 2))
        'MyReSizeWorld( SourceForm   ,MyLine1(SourceForm, x1, Y1, X2, Y2))
        Return
    End Sub


    Friend Sub PanToWorldPP(ByRef SourceForm As Source, A As MyPointStructure, B As MyPointStructure)
        PanToWorldXYXY(SourceForm, A.x, A.y, B.x, B.y)
    End Sub

    Friend Sub PanToWindowXY(ByRef SourceForm As Source, X As Integer, Y As Integer)
        Dim XY As MyPointStructure
        XY = Copy2WorldXY(SourceForm, "/", MyPoint1XY(X, Y))
        PanToWorldXY(SourceForm, XY.x, XY.y)
    End Sub

    Friend Sub PanToWorldLine(ByRef SourceForm As Source, XY As MyLineStructure)
        PanToWorldXYXY(SourceForm, XY.a.x, XY.a.y, XY.b.x, XY.b.y)
    End Sub

    Friend Sub PanToWorldXY(ByRef SourceForm As Source, X As Integer, Y As Integer)
        Dim XYa, XYb As MyPointStructure
        If FMBRecurse("PanToWorld") > 10 Then Return
        'If MyUniverse.MyMouseAndDrawing.MyScreen00.x=X - CInt( SourceForm  .Width / MyUniverse.SysGen.MyFlowChartScale / 2) And            MyUniverse.MyMouseAndDrawing.MyScreen00.y=Y - CInt( SourceForm  .Height / MyUniverse.SysGen.MyFlowChartScale / 2) Then
        If MyUniverse.MyMouseAndDrawing.MyScreen00.x = X And
                MyUniverse.MyMouseAndDrawing.MyScreen00.y = Y Then
            Return ' do nothing, because it still at the same place
        Else
            XYa = Copy2WorldXY(SourceForm, "/", MyPoint1XY(X, Y))
            XYb = Copy2WorldXY(SourceForm, "/", MyPoint1XY(CInt(SourceForm.FlowChartPictureBox.Width / MyUniverse.SysGen.MyFlowChartScale / 2), CInt(SourceForm.FlowChartPictureBox.Height / MyUniverse.SysGen.MyFlowChartScale / 2)))
            MyUniverse.MyMouseAndDrawing.MyScreen00.x = X - CInt(SourceForm.FlowChartPictureBox.Width / MyUniverse.SysGen.MyFlowChartScale / 2)
            MyUniverse.MyMouseAndDrawing.MyScreen00.y = Y - CInt(SourceForm.FlowChartPictureBox.Height / MyUniverse.SysGen.MyFlowChartScale / 2)

            'MyUniverse.MyMouseAndDrawing.MyScreen00.x=X - CInt( SourceForm.flowchartpicturebox .Width / MyUniverse.SysGen.MyFlowChartScale / 2)
            'MyUniverse.MyMouseAndDrawing.MyScreen00.y=Y - CInt( SourceForm.flowchartpicturebox .Height / MyUniverse.SysGen.MyFlowChartScale / 2)
            OLD.Clear_Window(SourceForm.FlowChartPictureBox)
            Return
        End If
    End Sub

    Friend Function MyShowPanTo(ByRef SourceForm As Source, X As Integer, Y As Integer) As String
        Dim RTN As String = ""
        RTN &= " XYWorld " & MyShowPoint(X, Y) & COMMA
        RTN &= " XY window " & MyShowPoint(Copy2WindowXY(SourceForm, MyPoint1XY(X, Y)))
        RTN &= " XY Root " & MyShowPoint(MyUniverse.MyMouseAndDrawing.MyScreen00.x, MyUniverse.MyMouseAndDrawing.MyScreen00.y)
        RTN &= " XY 00 " & MyShowPoint(Copy2WorldXY(SourceForm, "/path", MyPoint1XY(0, 0))) & COMMA
        RTN &= " XY ctr " & MyShowPoint(Copy2WorldXY(SourceForm, "/path", MyPoint1XY(CInt(SourceForm.FlowChartPictureBox.Width / 2), CInt(SourceForm.FlowChartPictureBox.Height / 2)))) & COMMA
        RTN &= " XY size " & MyShowPoint(Copy2WorldXY(SourceForm, "/path", MyPoint1XY(SourceForm.FlowChartPictureBox.Width, SourceForm.FlowChartPictureBox.Height))) & COMMA
        Return RTN
    End Function

    Friend Function Pt(A As MyPointStructure, B As MyPointStructure) As String
        Pt = ""
        If A.x < B.x Then Pt &= "<"
        If A.x = B.x Then Pt &= "="
        If A.x > B.x Then Pt &= ">"
        If A.y < B.y Then Pt &= "<"
        If A.y = B.y Then Pt &= "="
        If A.y > B.y Then Pt &= ">"
    End Function

    'This should express how these two lines (rectangles) are related
    '1 they are not on top of each other
    '2 line 1 is inside line 2
    '3 line2 is inside line 1'
    '4 they are on top (or touching)  but neither covers the other
    Friend Function SameSpace(A As MyLineStructure, B As MyLineStructure) As String
        Dim Temp As String = ""
        ' DIM   RTN As Integer=3
        Temp &= Pt(A.a, B.a)
        Temp &= Pt(A.b, B.a)
        Temp &= Pt(A.a, B.b)
        Temp &= Pt(A.b, B.b)
        Return Temp
    End Function


    Friend Function MinMaxIt(A As MyLineStructure, B As MyLineStructure) As MyLineStructure
        MinMaxIt = Nothing
        'MIN
        MinMaxIt.a.x = MyMin(A.a.x, A.b.x)
        MinMaxIt.a.x = MyMin(MinMaxIt.a.x, B.a.x)
        MinMaxIt.a.x = MyMin(MinMaxIt.a.x, B.b.x)

        MinMaxIt.a.y = MyMin(A.a.y, A.b.y)
        MinMaxIt.a.y = MyMin(MinMaxIt.a.y, B.a.y)
        MinMaxIt.a.y = MyMin(MinMaxIt.a.y, B.b.y)
        'MAX
        MinMaxIt.b.x = MyMax(A.a.x, A.b.x)
        MinMaxIt.b.x = MyMax(MinMaxIt.a.x, B.a.x)
        MinMaxIt.b.x = MyMax(MinMaxIt.a.x, B.b.x)

        MinMaxIt.b.y = MyMax(A.a.y, A.b.y)
        MinMaxIt.b.y = MyMax(MinMaxIt.a.y, B.a.y)
        MinMaxIt.b.y = MyMax(MinMaxIt.a.y, B.b.y)

    End Function

    'This should pan to have this XYXY as the display area (less 1/2 the distance of a symbol center)
    Friend Sub MyReSizeWorld(ByRef SourceForm As Source, XY As MyLineStructure)
        Dim I As Integer
        Dim Flag As Boolean = False
        For I = -MyUniverse.SysGen.Constants.ConstantSymbolCenter To MyUniverse.SysGen.Constants.ConstantSymbolCenter Step MyUniverse.SysGen.Constants.ConstantSymbolCenter
            If InSideMyFlowChartWindow(SourceForm, XY.a.x + I, XY.a.y) = False Then Flag = True
            If InSideMyFlowChartWindow(SourceForm, XY.a.x, XY.a.y + I) = False Then Flag = True
            If InSideMyFlowChartWindow(SourceForm, XY.a.x, XY.a.y) = False Then Flag = True
            If InSideMyFlowChartWindow(SourceForm, XY.b.x + I, XY.b.y) = False Then Flag = True
            If InSideMyFlowChartWindow(SourceForm, XY.b.x, XY.b.y + I) = False Then Flag = True
            If InSideMyFlowChartWindow(SourceForm, XY.b.x, XY.b.y) = False Then Flag = True
        Next
        While Flag = True
            'PanToWorldXY( DrawingArea  , XY.a, XY.b)
            WW3_My_Draw_Line_Or_Path(SourceForm, XY, RandomColor(SourceForm), 4)
            Flag = False
            MyZoomOut()
            PanToWorldXYXY(SourceForm, XY.a.x, XY.a.y, XY.b.x, XY.b.y)
            WW3_My_Draw_Line_Or_Path(SourceForm, XY, RandomColor(SourceForm), 4)
            For I = -MyUniverse.SysGen.Constants.ConstantSymbolCenter To MyUniverse.SysGen.Constants.ConstantSymbolCenter Step MyUniverse.SysGen.Constants.ConstantSymbolCenter
                If InSideMyFlowChartWindow(SourceForm, XY.a.x + I, XY.a.y) = False Then Flag = True
                If InSideMyFlowChartWindow(SourceForm, XY.a.x, XY.a.y + I) = False Then Flag = True
                If InSideMyFlowChartWindow(SourceForm, XY.a.x, XY.a.y) = False Then Flag = True
                If InSideMyFlowChartWindow(SourceForm, XY.b.x + I, XY.b.y) = False Then Flag = True
                If InSideMyFlowChartWindow(SourceForm, XY.b.x, XY.b.y + I) = False Then Flag = True
                If InSideMyFlowChartWindow(SourceForm, XY.b.x, XY.b.y) = False Then Flag = True
            Next
        End While
    End Sub




    'Routine just save where the mouse went down at.
    Friend Sub MyMouseDown(e As MouseEventArgs) 'saves xy for mouse button pushed down
        MyUniverse.Area.MyInputWindowXY.a.x = e.X
        MyUniverse.Area.MyInputWindowXY.a.y = e.Y
        MyUniverse.MyMouseAndDrawing.MouseStroke = "" 'New Symbol
    End Sub

    Friend Sub MyPlacement(ByRef SourceForm As Source, AddOrNot As Boolean)
        'XY1 is the base, XY2 is the indent offset 
        Dim X1, Y1, X2, Y2, s, maxXY1 As Integer
        X1 = MyUniverse.SysGen.PlacementBase.x
        Y1 = MyUniverse.SysGen.PlacementBase.y
        s = MyUniverse.SysGen.Constants.ConstantSymbolCenter * 2
        maxXY1 = MyUniverse.SysGen.Snaps.MySymbolSnap * 100

        If X1 < MyUniverse.SysGen.Snaps.MySymbolSnap Then
            X1 = MyUniverse.SysGen.Snaps.MySymbolSnap
        End If
        If Y1 < s Then
            Y1 = MyUniverse.SysGen.Snaps.MySymbolSnap
        End If


        If AddOrNot = True Then
            Y1 += MyUniverse.SysGen.Snaps.MySymbolSnap
            Y2 = Y1
            If MyUniverse.SysGen.PlacementColumn > 0 Then
                X2 = X1 + MyUniverse.SysGen.Snaps.MySymbolSnap * MyUniverse.SysGen.PlacementColumn
                If X2 >= MyUniverse.SysGen.PlacementNextColumnMin Then
                    MyUniverse.SysGen.PlacementNextColumnMin = X2 + MyUniverse.SysGen.Snaps.MySymbolSnap * 2
                End If
            End If
        End If
        If Y1 > maxXY1 Then
            X1 = MyUniverse.SysGen.PlacementNextColumnMin  ' MyUniverse.SysGen.Snaps.MySymbolSnap               ' Move over 
            MyUniverse.SysGen.PlacementNextColumnMin = X1 + MyUniverse.SysGen.Snaps.MySymbolSnap * 2
            Y1 = s * 2
        End If
        'MyUniverse.SysGen.Placement=MySymbolSnap(MyPoint1XY(x - CInt( DrawingArea .Width / 20), y - CInt( DrawingArea .Height / 20)))
        'DOC only move the screen to where a /use is added if the debugLevel is at 4
        MyUniverse.SysGen.PlacementBase.x = X1
        MyUniverse.SysGen.PlacementBase.y = Y1
        MyUniverse.SysGen.PlacementCurrent.x = X2
        MyUniverse.SysGen.PlacementCurrent.y = Y2

        If MyOptionTest(34) Then
            PanToWorldXY(SourceForm, X2, Y2) 'should pan to this xy location to be the center of the picture window
            MyDrawLine(SourceForm, MyUniverse.SysGen.PlacementBase.x, MyUniverse.SysGen.PlacementBase.y, MyUniverse.SysGen.PlacementCurrent.x, MyUniverse.SysGen.PlacementCurrent.y, RandomColor(SourceForm))
            MyDrawLine(SourceForm, MyUniverse.SysGen.PlacementBase.x, MyUniverse.SysGen.PlacementBase.y, MyUniverse.SysGen.PlacementCurrent.x, MyUniverse.SysGen.PlacementCurrent.y, RandomColor(SourceForm))
        End If
    End Sub


    Friend Function MySnapIndex(ByRef SourceForm As Source, IndexFlowChart As Integer) As MyLineStructure ', XY As Integer)
        MySnapIndex = MySnapXYXY(Source, FlowChart_TableCode(SourceForm, IndexFlowChart),
                                     FlowChart_TableX1(SourceForm, IndexFlowChart),
                                     FlowChart_TableY1(SourceForm, IndexFlowChart),
                                     FlowChart_TableX2(SourceForm, IndexFlowChart),
                                     FlowChart_TableY2(SourceForm, IndexFlowChart))
        MySnapIndex.a.Named.PathName = FlowChart_Table_Path_SymbolName(SourceForm, IndexFlowChart)
        MySnapIndex.b.Named.PathName = FlowChart_Table_Path_SymbolName(SourceForm, IndexFlowChart)
        MySnapIndex.a.Named.PointName = FlowChart_TableCode(SourceForm, IndexFlowChart)
    End Function

    Friend Function MySnapXYXY(ByRef SourceForm As Source, FlowChartCOde As String, X1 As Integer, Y1 As Integer, X2 As Integer, Y2 As Integer) As MyLineStructure
        'IndexFlowChart As Integer) As MyLineStructure
        Dim XY As MyLineStructure
        MySnapXYXY = Nothing
        XY = Nothing
        MySnapXYXY.a.Named.SymbolName = "S_Unknown_" & MyRandom(8)
        'XYZ.a.x=FlowChart_TableX1(SourceForm, IndexFlowChart)
        'XYZ.a.y=FlowChart_TableY1(SourceForm    , SourceForm    , IndexFlowChart)
        XY.a.Named.PathName = "Path_Unknown_" & MyRandom(10)
        XY.a.x = X1
        XY.a.y = Y1
        MySnapXYXY.a.Named.IsWorldWindow = WorldOrWindow(MySnapXYXY.a)
        MySnapXYXY.b.Named.IsWorldWindow = WorldOrWindow(MySnapXYXY.b)

        Select Case FlowChartCOde 'FlowChart_TableCode(SourceForm ,  IndexFlowChart)
            Case My_keyWord(My_KeyConstUse)
                Return MyLineXY(MySymbolSnap(MyPoint1XY(X1, Y1)), MyUniverse.MyStaticData.ZeroZero)
            Case "/path"
                XY.b.x = X2 'FlowChart_TableX2(SourceForm, IndexFlowChart)
                XY.b.y = Y2 'FlowChart_TableY2(SourceForm, IndexFlowChart)
                MySnapXYXY = MyPathSnap(XY)
            Case "/error", "/unknown", "/raw", "/constant", Nothing
                Return MyLineXY(MyPoint1XY(X1, Y1), MyUniverse.MyStaticData.ZeroZero)
                    'todo need to get rid of this 
            Case "/point"
                logA(2912, MyShowPoint(X1, Y1))
                If MyOptionTest(25) = True Then
                Else
                End If
            Case "/delete"
                Return MyUniverse.MyStaticData.ZeroZeroZeroZero
            Case Else
                logA(2913, FlowChartCOde, MyShowPoint(X1, Y1), MyShowPoint(X2, Y2))
                If MyOptionTest(25) = True Then
                Else
                End If
                Return MyLineXY(MyPoint1XY(X1, Y1), XY.b) ' no snap
        End Select
    End Function

    'todo need to also have a SnapToLine+-1, SnapToSymbol-1000
    Friend Sub AllPaths2PointSnap(ByRef SourceForm As Source) ' moves all path ends to connect to something
        Dim IndexFlowChart, JIndex As Integer
        Dim XY As MyPointStructure
        XY = Nothing
        For IndexFlowChart = 1 To TopOfListBox(SourceForm.ListBoxFlowChart)
            MyShowAndUpDateProperties(SourceForm, IndexFlowChart) ', 0, FlowChart_tablePathSymbolName(SourceForm, IndexFlowChart))
            Select Case FlowChart_TableCode(SourceForm, IndexFlowChart)
                Case MyKeyword2Number("/path").ToString  'KeyConstPath
                    XY.x = FlowChart_TableX1(SourceForm, IndexFlowChart)
                    XY.y = FlowChart_TableY1(SourceForm, IndexFlowChart)
                    JIndex = MyFindPoint(SourceForm, XY, IndexFlowChart)
                    XY.x = FlowChart_TableX2(SourceForm, IndexFlowChart)
                    XY.y = FlowChart_TableY2(SourceForm, IndexFlowChart)
                    JIndex = MyFindPoint(SourceForm, XY, IndexFlowChart)
                Case Else
                    logA(1952, FlowChart_TableCode(SourceForm, IndexFlowChart))
            End Select
        Next
    End Sub


    Friend Function FMB_CheckColorNameToLight(ColorName As String) As Integer 'returns 0 if ok, or 1 if not ok
        Dim ToLight1 As Integer = 127
        Dim ToLight2 As Integer = 500
        Dim IndexColor As Integer
        IndexColor = BinarySearch4Index(Options.ListBoxColors, ColorName)

        If Color_TableRed(IndexColor) < ToLight1 Or
                Color_TableGreen(IndexColor) < ToLight1 Or
                Color_TableBlue(IndexColor) < ToLight1 Then
            Return 1
        End If

        If Color_TableRed(IndexColor) +
                Color_TableGreen(IndexColor) +
                Color_TableBlue(IndexColor) > ToLight2 Then
            Return 1
            'Else
        End If
        Return 0 ' color is ok
    End Function

    Friend Function RandomColor(ByRef SourceForm As Source) As String
        Const ToLight1 As Integer = 127
        Const ToLight2 As Integer = 500
        'Const DebugLevel As Integer = A_STATUS

        If TopOfFile(SourceForm, "Color") > 8 Then
            MyUniverse.MyStaticData.LastColor = MyMinMax((MyUniverse.MyStaticData.LastColor + 1) Mod TopOfFile(SourceForm, "Color"), 1, TopOfFile(SourceForm, "Color"))
        Else
            MyUniverse.MyStaticData.LastColor = 1
        End If

        FMB_CheckColorNameToLight(Color_TableName(MyUniverse.MyStaticData.LastColor))


        If Color_TableRed(MyUniverse.MyStaticData.LastColor) < ToLight1 Or
                Color_TableGreen(MyUniverse.MyStaticData.LastColor) < ToLight1 Or
                Color_TableBlue(MyUniverse.MyStaticData.LastColor) < ToLight1 Then
        Else
            Return RandomColor(SourceForm)
        End If

        If Color_TableRed(MyUniverse.MyStaticData.LastColor) + Color_TableGreen(MyUniverse.MyStaticData.LastColor) + Color_TableBlue(MyUniverse.MyStaticData.LastColor) > ToLight2 Then
            Return RandomColor(SourceForm)
        End If
        Return Color_TableName(MyUniverse.MyStaticData.LastColor)
    End Function 'random color ()


    'Routine Most everything is done in mouse up button
    Friend Sub MyMouseMove(ByRef SourceForm As Source, e As MouseEventArgs)
        Dim XY As MyPointStructure
        Dim XY2 As MyPointStructure
        Dim What As String
        If ProgramBuzzy("Begin") Then Return
        If SourceForm.Parent.Name = "?????" Then
            What = "/path"
        Else
            What = "/Line"
        End If


        'todo is this necessary '''XY=Nothing
        XY2 = Nothing
        XY2.x = e.X
        XY2.y = e.Y

        If MyOptionTest(35) Then
            MyUniverse.Area.MyInputWindowXY.b.x = e.X
            MyUniverse.Area.MyInputWindowXY.b.y = e.Y
            MyUniverse.Area.MyWorldXY.a = Copy2WorldXY(SourceForm, What, MyUniverse.Area.MyInputWindowXY.a)
            MyUniverse.Area.MyWorldXY.b = Copy2WorldXY(SourceForm, What, MyUniverse.Area.MyInputWindowXY.b)
            MyDrawLineXY_XY(SourceForm, MyUniverse.Area.MyInputWindowXY, RandomColor(SourceForm)) 'Erase the last Line
        End If

        ' This is here only to remind me to do something about it.
        Select Case (e.Button)
            Case MouseButtons.Left

            Case MouseButtons.Right

            Case MouseButtons.Middle

            Case MouseButtons.None

            Case MouseButtons.XButton1

            Case MouseButtons.XButton1
            Case Else
                logA(1840, e.Button.ToString)
        End Select

        Select Case LCase(Trim(MyUniverse.SysGen.Constants.MyCmdModeString))
            Case "CmdMoveHand" ' This should move the pictures to where the mouse is let go.
    'todo need to add a bit map move of the picture1 bit map image.(phase 2)
            Case "CmdAddPath" ' do nothing (later draw Line where Line should go (and delete the previous Line))
                XY = Copy2WorldXY(SourceForm, "/path", XY2)
                Select Case (e.Button)
                    Case MouseButtons.Left ' Draw a following Line only if you use the left button
                        MyDrawLineXY_XY(SourceForm, MyUniverse.Area.MyWorldXY, "WHITE") 'Erase the last Line
                        MyUniverse.Area.MyInputWindowXY.b.x = e.X
                        MyUniverse.Area.MyInputWindowXY.b.y = e.Y
                        MyUniverse.Area.MyWorldXY.a = Copy2WorldXY(SourceForm, "/path", MyUniverse.Area.MyInputWindowXY.a)
                        MyUniverse.Area.MyWorldXY.b = Copy2WorldXY(SourceForm, "/path", MyUniverse.Area.MyInputWindowXY.b)
                        'MakePathOrthogonal(MyUniverse.Area)
                        MyDrawLineXY_XY(SourceForm, MyUniverse.Area.MyWorldXY, "Black")   ' width should/can only be one 
                    Case MouseButtons.Right ' Reserved for /Stroke
                    Case MouseButtons.Middle
                    Case MouseButtons.None
                    Case MouseButtons.XButton1
                    Case MouseButtons.XButton1
                    Case Else
                        logA(1961, e.Button.ToString)
                End Select
            Case "CmdDelete"
            Case "CmdAddSymbol" ' do nothing (We should be in the select Symbol mode just before this
            Case "CmdAddPoint"
            Case "CmdAddLine"
            Case "cmdCheck"
            Case "cmdDelErr"
            Case "cmdDelNotUsed"
            Case "cmdDUMP"
            Case "cmdFlowChartWindow"
            Case "cmdSymbolWindow"
            Case "CmdMove"
                MyUniverse.SysGen.Constants.MyCmdModeString = MyUniverse.SysGen.Constants.MyCmdModeString
            Case Nothing, "", "?"
                If MyDebug(A_NOTICE) Then
                    If MyComparePoint(MyUniverse.Area.MyWorldXY.a, MyUniverse.Area.MyWorldXY.b) = False Then
                        MyDrawLineXY_XY(SourceForm, MyUniverse.Area.MyWorldXY, RandomColor(SourceForm)) 'todo remove this
                        'todo need to change this to the 'background color"
                        MyDrawLineXY_XY(SourceForm, MyUniverse.Area.MyWorldXY, "lightGray") 'Erase the last Line
                        MyUniverse.Area.MyInputWindowXY.b.x = e.X
                        MyUniverse.Area.MyInputWindowXY.b.y = e.Y
                        MyUniverse.Area.MyWorldXY.a = Copy2WorldXY(SourceForm, What, MyUniverse.Area.MyInputWindowXY.a)
                        MyUniverse.Area.MyWorldXY.b = Copy2WorldXY(SourceForm, What, MyUniverse.Area.MyInputWindowXY.b)
                        MyDrawLineXY_XY(SourceForm, MyUniverse.Area.MyWorldXY, RandomColor(SourceForm)) 'Erase the last Line
                    End If
                End If
            Case Else
                logA(1102, MyUniverse.SysGen.Constants.MyCmdModeString)
                If MyOptionTest(25) = True Then
                Else
                End If
        End Select
    End Sub


    Friend Sub FlashLine_NotUsed(ByRef SourceForm As Source, NewXY As MyPointStructure)
        Dim Temp As MyLineStructure
        Dim What As String
        'todo get rid of not used stuff (After making sure it's not called.
        If SourceForm.Parent.Name = OLD.FLOWCHARTNAME Then
            What = "/path"
        Else
            What = "/Line"
        End If
        Temp = MyUniverse.Area.MyWorldXY
        MyDrawLineXY_XY(SourceForm, Temp, "WHITE") 'Erase the last Line
        Temp.b = Copy2WorldXY(SourceForm, What, NewXY)
        MyDrawLineXY_XY(SourceForm, MyUniverse.Area.MyWorldXY, RandomColor(SourceForm)) 'Erase the last Line
    End Sub

    'Routine This is the major routines to do everything the user wanted with the mouse button UP .
    Friend Sub MyMouseUp(ByRef SourceForm As Source, e As MouseEventArgs)
        Dim IndexNamed, IndexSymbol, IndexFlowChart As Integer
        Dim TempDebug As String
        Dim Temp As MyPointStructure
        Temp = Nothing
        MyUniverse.Area.MyInputWindowXY.b.x = e.X 'Where the mouse button is up
        MyUniverse.Area.MyInputWindowXY.b.y = e.Y

        'Convert the mouse down and mouse up to be in real world (vs Window world) numbers
        ' This is now failing, and always returns -500,-500
        If MyUniverse.SysGen.MinBox < MyUniverse.SysGen.Constants.ConstantMinBoxSize Then MyUniverse.SysGen.MinBox = MyUniverse.SysGen.Constants.ConstantMinBoxSize
        Select Case LCase(Trim(MyUniverse.SysGen.Constants.MyCmdModeString))
            Case "", Nothing
            Case "CmdMoveHand"
                logA(1104, MyUniverse.SysGen.MyFlowChartScale.ToString, MyShowPoint(MyUniverse.Area.MyInputWindowXY.a), MyShowPoint(MyUniverse.Area.MyInputWindowXY.b), CStr(MyDistance(MyUniverse.Area.MyInputWindowXY.a, MyUniverse.Area.MyInputWindowXY.b)))
                logA(1106, MyUniverse.Area.MyInputWindowXY.a.x.ToString, MyUniverse.Area.MyInputWindowXY.b.x.ToString, ((MyUniverse.Area.MyInputWindowXY.b.x - MyUniverse.Area.MyInputWindowXY.a.x) * MyUniverse.SysGen.MyFlowChartScale).ToString)
                If MyOptionTest(25) = True Then
                Else
                End If
                Temp.x = MyUniverse.MyMouseAndDrawing.MyScreen00.x + (MyUniverse.Area.MyInputWindowXY.a.x - MyUniverse.Area.MyInputWindowXY.b.x) * 4
                Temp.y = MyUniverse.MyMouseAndDrawing.MyScreen00.y + (MyUniverse.Area.MyInputWindowXY.a.y - MyUniverse.Area.MyInputWindowXY.b.y) * 4
                Temp = Copy2WorldXY(SourceForm, "/", Temp)

                'Reset to Window coordinate ..
                MyUniverse.MyMouseAndDrawing.MyScreen00 = Copy2WindowXY(SourceForm, Temp)
                'todo is this necessary '''Temp=MyUniverse.MyMouseAndDrawing.MyScreen00  'hack to watch for debug
                Clear_Window_Only(SourceForm.FlowChartPictureBox)
                PaintAll(SourceForm, TopOfListBox(SourceForm.ListBoxFlowChart) - 2, TopOfListBox(SourceForm.ListBoxFlowChart))
            Case "CmdAddPath"
                MyUniverse.Area.MyWorldXY = Copy2WorldXYXY(SourceForm, "/path", MyUniverse.Area.MyInputWindowXY) 'Mouse button down
                '
                'Search for the closest point First and then connect it
                IndexFlowChart = NewFlowChartRecord(SourceForm)
                'FlowChart_TablePathName(Sourceform, IndexFlowChart , makenewname(SourceForm ,  "Path1", 0))   'unnamed path
                If Len(OLD.INPUTTEXTBOX) = 0 Then
                    OLD.INPUTTEXTBOX = FindPathNameAtLine(SourceForm)
                    If Len(OLD.INPUTTEXTBOX) = 0 Then
                        OLD.INPUTTEXTBOX = InputBox(Translate("Enter the path name"), Translate("Unnamed path"))
                        If Len(OLD.INPUTTEXTBOX) = 0 Then
                            OLD.INPUTTEXTBOX = MakeNewName(SourceForm, "Path", "AutoPath")
                            If Len(OLD.INPUTTEXTBOX) = 0 Then
                                OLD.INPUTTEXTBOX = "Path_Name_Error" & MyRnd(4)
                                logA(1107, OLD.INPUTTEXTBOX)
                                If MyOptionTest(25) = True Then
                                Else
                                End If
                            End If
                        End If
                    End If
                End If
                FlowChart_tablePathSymbolName(SourceForm, IndexFlowChart, OLD.INPUTTEXTBOX)

                FlowChart_TableCode(SourceForm, IndexFlowChart, MyKeyword2Number("/path").ToString)
                MyUniverse.Area.MyWorldXY = MyPathSnap(MyUniverse.Area.MyWorldXY)
                FlowChart_TableX1(SourceForm, IndexFlowChart, MyUniverse.Area.MyWorldXY.a.x)
                FlowChart_TableY1(SourceForm, IndexFlowChart, MyUniverse.Area.MyWorldXY.a.y)
                FlowChart_TableX2(SourceForm, IndexFlowChart, MyUniverse.Area.MyWorldXY.b.x)
                FlowChart_TableY2(SourceForm, IndexFlowChart, MyUniverse.Area.MyWorldXY.b.y)
                FlowChart_TableDataType(SourceForm, IndexFlowChart, MyUniverse.ProgramOptions.FlowChartTextBox) 'No Information

                MakePathOrthogonal(SourceForm, IndexFlowChart)
                'Paint the original end of table record then 
                PaintAll(SourceForm, IndexFlowChart - 1, IndexFlowChart + 1)
                ' assume that MakePathOrthogonal adds a record at the end of the table, if not, still no harm? just slower
                PaintAll(SourceForm, TopOfListBox(SourceForm.ListBoxFlowChart) - 1, TopOfListBox(SourceForm.ListBoxFlowChart) + 1)
            Case "CmdAddSymbol"

                MyUniverse.Area.MyWorldXY.a = Copy2WorldXY(SourceForm, My_keyWord(My_KeyConstUse), MyUniverse.Area.MyInputWindowXY.a) 'Mouse button down
                MyUniverse.Area.MyWorldXY.b = Copy2WorldXY(SourceForm, My_keyWord(My_KeyConstUse), MyUniverse.Area.MyInputWindowXY.b) ' Mouse button up

                '
                If MyUniverse.ProgramOptions.SelectedSymbolName = "" Then
                    '''''ShowAllWindows(HideWindow, ShowWindow, HideWindow, ShowWindow)
                    FlowChart_tablePathSymbolName(SourceForm, TopOfListBox(SourceForm.ListBoxFlowChart), MakeNewName(SourceForm, "UseA", "UnknowSymbol" & MyRnd(6)))
                    Return
                Else
                End If
                IndexFlowChart = NewFlowChartRecord(SourceForm)
                FlowChart_TableCode(SourceForm, IndexFlowChart, MyKeyword2Number(My_keyWord(My_KeyConstUse)).ToString) 'KeyConstUse) '"/use")
                FlowChart_tablePathSymbolName(SourceForm, IndexFlowChart, MyUniverse.ProgramOptions.SelectedSymbolName) '
                FlowChart_TableCode(SourceForm, IndexFlowChart, MyKeyword2Number(My_keyWord(My_KeyConstUse)).ToString) 'KeyConstUse) '"/use")

                MyUniverse.Area.MyWorldXY.a = MySymbolSnap(MyUniverse.Area.MyWorldXY.a)
                MyUniverse.Area.MyWorldXY.b = MySymbolSnap(MyUniverse.Area.MyWorldXY.b)

                FlowChart_TableX1(SourceForm, IndexFlowChart, MyUniverse.Area.MyWorldXY.a.x)
                FlowChart_TableY1(SourceForm, IndexFlowChart, MyUniverse.Area.MyWorldXY.a.y)
                FlowChart_Table_Rotation(SourceForm, IndexFlowChart, MyUniverse.ProgramOptions.SelectedRotation) 'Rotation is assumed to be none for now
                FlowChart_TableOption(SourceForm, IndexFlowChart) ' Future options

                PaintAll(SourceForm, IndexFlowChart - 1, IndexFlowChart + 1)

            Case "CommandAddConstant"
                MyUniverse.Area.MyWorldXY.a = Copy2WorldXY(SourceForm, "/Constant", MyUniverse.Area.MyInputWindowXY.a) 'Mouse button down
                MyUniverse.Area.MyWorldXY.b = Copy2WorldXY(SourceForm, "/Constant", MyUniverse.Area.MyInputWindowXY.b) ' Mouse button up

                '

                IndexFlowChart = NewFlowChartRecord(SourceForm)
                FlowChart_TableCode(SourceForm, IndexFlowChart, "/Constant")


                MyUniverse.Area.MyWorldXY.a = MyPointSnap(MyUniverse.Area.MyWorldXY.a)
                'Why am I snapping to grid the second XY??????? ' Hack need to see what I am doing here.
                MyUniverse.Area.MyWorldXY.b = MyPointSnap(MyUniverse.Area.MyWorldXY.b)

                FlowChart_TableX1(SourceForm, IndexFlowChart, MyUniverse.Area.MyWorldXY.a.x)
                FlowChart_TableY1(SourceForm, IndexFlowChart, MyUniverse.Area.MyWorldXY.a.y)
                FlowChart_TableDataType(SourceForm, IndexFlowChart, MyUniverse.ProgramOptions.SelectedDataType)

                'I do not need another record!
                'IndexFlowChart=NewFlowChartRecord(SourceForm )
                FlowChart_TableX2(SourceForm, IndexFlowChart, MyUniverse.Area.MyWorldXY.b.x)
                FlowChart_TableY2(SourceForm, IndexFlowChart, MyUniverse.Area.MyWorldXY.b.y)

                PaintAll(SourceForm, IndexFlowChart - 1, IndexFlowChart + 1)

            Case "CmdAddLine"
                MyUniverse.Area.MyWorldXY.a = Copy2WorldXY(SourceForm, "/Line", MyUniverse.Area.MyInputWindowXY.a) 'Mouse button down
                MyUniverse.Area.MyWorldXY.b = Copy2WorldXY(SourceForm, "/Line", MyUniverse.Area.MyInputWindowXY.b) ' Mouse button up

                '
                IndexNamed = AddInTable(Options.ListBoxSymbols, MyUniverse.ProgramOptions.SelectedSymbolName)
                IndexSymbol = Named_TableSymbolIndexes(IndexNamed)

                If IndexSymbol = ConstantMyErrorCode Then
                    IndexSymbol = CorrectingIndexes(SourceForm, MyUniverse.ProgramOptions.SelectedSymbolName)
                    If IndexSymbol < 1 Then
                        InsertSymbolLineRecord(SourceForm, NewTopOfFile(SourceForm, "Symbol"), MyUniverse.MyStaticData.ZeroZeroZeroZero, MyUniverse.ProgramOptions.SelectedSymbolName, "/name", "NOTUSED")
                    Else
                        InsertSymbolLineRecord(SourceForm, NewTopOfFile(SourceForm, "Symbol"), MyUniverse.Area.MyWorldXY, MyUniverse.ProgramOptions.SelectedSymbolName, "/Line", RandomColor(SourceForm))
                    End If
                Else
                    InsertSymbolLineRecord(SourceForm, IndexSymbol + 1, MyUniverse.Area.MyWorldXY, Named_TableSymbolName(IndexNamed), "/Line",
                                           Options.ListBoxColors.ToString)
                End If
            Case "CmdAddPoint" 'Places a point on the Symbol Window, NOT a Symbol on the FlowChart Window
                MyUniverse.Area.MyWorldXY.a = Copy2WorldXY(SourceForm, "/point", MyUniverse.Area.MyInputWindowXY.a) 'Mouse button down
                MyUniverse.Area.MyWorldXY.b = Copy2WorldXY(SourceForm, "/point", MyUniverse.Area.MyInputWindowXY.b) ' Mouse button up
                IndexNamed = AddInTable(Options.ListBoxSymbols, MyUniverse.ProgramOptions.SelectedSymbolName)
                IndexSymbol = Named_TableSymbolIndexes(IndexNamed)
                '''''  FixSyxtaxCode(IndexNamed)
                If IndexSymbol <= 0 Then
                    IndexSymbol = CorrectingIndexes(SourceForm, MyUniverse.ProgramOptions.SelectedSymbolName)
                    If IndexSymbol < 1 Then
                        ' Add a missing name record to the table
                        InsertSymbolLineRecord(SourceForm, NewTopOfFile(SourceForm, "Symbol"), MyUniverse.Area.MyWorldXY, Named_TableSymbolName(IndexNamed), "/name", "NOTUSED")
                        IndexSymbol = CorrectingIndexes(SourceForm, MyUniverse.ProgramOptions.SelectedSymbolName)
                    Else
                    End If
                Else
                    If Symbol_TableCoded_String(IndexSymbol) <> "/name" Then ' We have  a wrong Indexes
                        CorrectingIndexes(SourceForm, MyUniverse.ProgramOptions.SelectedSymbolName)
                    End If
                End If

                NumberOfGraphicsInASymbol(SourceForm, FindInSymbolList(SourceForm, MyUniverse.ProgramOptions.SelectedSymbolName), 0) 'Get Symbol info only
                ' This makes sure that the names of the points, and the color of the Lines are in the list box 
                TempDebug = MyUniverse.ProgramOptions.SelectedInputOutput
                If PrintAbleNull(TempDebug) = PrintAbleNull(Nothing) Then
                    TempDebug = "Both"
                End If

                MyUniverse.Area.MyWorldXY.b.x = MyEnumValue(Pop(TempDebug, MyUniverse.SysGen.Constants.ConstantDelimiters), Options.ListBoxInputOutput)

                TempDebug = MyUniverse.ProgramOptions.SelectedInputOutput

                MyUniverse.Area.MyWorldXY.b.x = MyEnumValue(Pop(MyUniverse.ProgramOptions.SelectedInputOutput, MyUniverse.SysGen.Constants.ConstantDelimiters), Options.ListBoxInputOutput)
                MyUniverse.Area.MyWorldXY.b.y = BinarySearch4Index(Options.ListBoxDataTypes, MyUniverse.ProgramOptions.SelectedDataType)
                'todo bug in that this is not giving the correct name, and needs to be written
                InsertSymbolLineRecord(SourceForm, IndexSymbol + 1, MyUniverse.Area.MyWorldXY, MyUniverse.ProgramOptions.SelectedSymbolName, "/point",
                                       Library.ListBoxPointNameList.Text)
                '''''  FixSyxtaxCode(IndexNamed)
            Case "CmdMove"
                MyCmdMove(SourceForm)
            Case "CmdDelete"
                MyUniverse.Area.MyWorldXY.a = Copy2WorldXY(SourceForm, "/", MyUniverse.Area.MyInputWindowXY.a) 'Mouse button down
                MyUniverse.Area.MyWorldXY.b = Copy2WorldXY(SourceForm, "/", MyUniverse.Area.MyInputWindowXY.b) ' Mouse button up
                Select Case LCase(SourceForm.FlowChartPictureBox.Parent.Name)
                    Case "FlowChartWindow"
                        MyUniverse.ProgramOptions.SelectedObject = MyFindPoint(SourceForm, MyUniverse.Area.MyWorldXY.a, 0)
                        PaintErase(SourceForm, MyUniverse.ProgramOptions.SelectedObject)
                        FlowChart_TableCode(SourceForm, MyUniverse.ProgramOptions.SelectedObject, "/delete") 'Delete Mark Only
                        PaintAll(SourceForm, MyUniverse.ProgramOptions.SelectedObject - 1, MyUniverse.ProgramOptions.SelectedObject + 1)
                    Case "SymbolWindow"
                        MyUniverse.ProgramOptions.SelectedObject = MyFindPoint(SourceForm, MyUniverse.Area.MyWorldXY.a, 0)
                        'PaintErase( SourceForm.FlowChartPictureBox  , MyUniverse.ProgramOptions.SelectedObject)
                        Symbol_TableCode(SourceForm, MyUniverse.ProgramOptions.SelectedObject, "/delete") 'Delete Mark Only
                        IndexNamed = BinarySearch4Index(Options.ListBoxSymbols, MyUniverse.ProgramOptions.SelectedSymbolName) '
                        If IndexFlowChart = ConstantMyErrorCode Then
                        Else
                            'Named_TableSymbolIndexes( IndexFlowChart , 0) ' Delete the old Indexes (for now)
                            IndexFlowChart = CorrectingIndexes(SourceForm, MyUniverse.ProgramOptions.SelectedSymbolName)
                            OLD.Clear_Window(SourceForm.FlowChartPictureBox)
                        End If
                        ' IndexFlowChart =MyUniverse.SysGen.Constants.ConstantSymbolCenter + MyUniverse.SysGen.Constants.ConstantSymbolCenter
                        ''''PaintEach(Library.PictureBox1, MyPoint1XY(MyUniverse.SysGen.Constants.ConstantSymbolCenter, MyUniverse.SysGen.Constants.ConstantSymbolCenter), MyUniverse.ProgramOptions.SelectedSymbolName, "Default")'
        ' We should be turning off the item
                    Case "optionsWindow"
                    Case Else
                        logA(1974, SourceForm.FlowChartPictureBox.Parent.Name)
                End Select
            Case "cmdCheck"
            Case "cmdDelErr"
            Case "cmdDelNotUsed"
            Case "cmdDUMP"
            Case "cmdFlowChartWindow"
            Case "cmdSymbolWindow"
            Case Else
                logA(1283, MyUniverse.SysGen.Constants.MyCmdModeString)
        End Select
    End Sub



    Friend Sub MyCmdMove(ByRef SourceForm As Source)
        Select Case LCase(SourceForm.Parent.Name)
            Case "FlowChartWindow"
                'Get the closest object (/path could be either end of the path)
                MyUniverse.ProgramOptions.SelectedObject = MyFindPoint(SourceForm, MyUniverse.Area.MyWorldXY.a, 0)
                'We should flash this object 
                If MyUniverse.ProgramOptions.SelectedObject > ConstantMyErrorCode Then
                    PaintAll(SourceForm, MyUniverse.ProgramOptions.SelectedObject, MyUniverse.ProgramOptions.SelectedObject)
                    Select Case LCase(FlowChart_TableCode(SourceForm, MyUniverse.ProgramOptions.SelectedObject))
                        Case "/path"
                            ' need to find the closest end to change
                            MyUniverse.Area.MyWorldXY = MySnapIndex(SourceForm, MyUniverse.ProgramOptions.SelectedObject)
                            If MyABS(MyUniverse.Area.MyWorldXY.a.x - FlowChart_TableX1(SourceForm, MyUniverse.ProgramOptions.SelectedObject)) +
       MyABS(MyUniverse.Area.MyWorldXY.a.y - FlowChart_TableY1(SourceForm, MyUniverse.ProgramOptions.SelectedObject)) >
       MyABS(MyUniverse.Area.MyWorldXY.a.x - FlowChart_TableX2(SourceForm, MyUniverse.ProgramOptions.SelectedObject)) +
       MyABS(MyUniverse.Area.MyWorldXY.a.y - FlowChart_TableY2(SourceForm, MyUniverse.ProgramOptions.SelectedObject)) Then
                                PaintErase(SourceForm, MyUniverse.ProgramOptions.SelectedObject)
                                FlowChart_TableX2(SourceForm, MyUniverse.ProgramOptions.SelectedObject, MyUniverse.Area.MyWorldXY.b.x)
                                FlowChart_TableY2(SourceForm, MyUniverse.ProgramOptions.SelectedObject, MyUniverse.Area.MyWorldXY.b.y)
                            Else
                                PaintErase(SourceForm, MyUniverse.ProgramOptions.SelectedObject)
                                FlowChart_TableX1(SourceForm, MyUniverse.ProgramOptions.SelectedObject, MyUniverse.Area.MyWorldXY.b.x)
                                FlowChart_TableY1(SourceForm, MyUniverse.ProgramOptions.SelectedObject, MyUniverse.Area.MyWorldXY.b.y)
                            End If
                        Case My_keyWord(My_KeyConstUse)
                            MoveSymbolAndAllPaths(SourceForm, MyUniverse.ProgramOptions.SelectedObject, MyPoint1XY(MyUniverse.Area.MyWorldXY.b.x - MyUniverse.Area.MyWorldXY.a.x, MyUniverse.Area.MyWorldXY.b.y - MyUniverse.Area.MyWorldXY.a.y))
        'Case My_keyWord(My_KeyConstUse)
        '    PaintErase( SourceForm.FlowChartPictureBox  , MyUniverse.ProgramOptions.SelectedObject)
        '    FlowChart_TableX1(SourceForm, MyUniverse.ProgramOptions.SelectedObject, MySymbolSnap(MyUniverse.Area.MyWorldXY.b.x))
        '    FlowChart_TableY1(SourceForm    , SourceForm    , MyUniverse.ProgramOptions.SelectedObject, MySymbolSnap(MyUniverse.Area.MyWorldXY.b.y))
                        Case "/Constant"
                            PaintErase(SourceForm, MyUniverse.ProgramOptions.SelectedObject)
                            MyUniverse.Area.MyWorldXY.b = MyPointSnap(MyUniverse.Area.MyWorldXY.b)
                            FlowChart_TableX1(SourceForm, MyUniverse.ProgramOptions.SelectedObject, MyUniverse.Area.MyWorldXY.b.x)
                            FlowChart_TableY1(SourceForm, MyUniverse.ProgramOptions.SelectedObject, MyUniverse.Area.MyWorldXY.b.y)
                        Case Else
                            logA(1110, FlowChart_TableCode(SourceForm, MyUniverse.ProgramOptions.SelectedObject), MyShowFlowChartRecord(SourceForm, False, MyUniverse.ProgramOptions.SelectedObject))
                            'move to where the mouse button let up
                            If MyOptionTest(25) = True Then
                            Else
                            End If
                    End Select

                    'redisplay 1 (We should be turning off the old location)
                    PaintAll(SourceForm, MyUniverse.ProgramOptions.SelectedObject, MyUniverse.ProgramOptions.SelectedObject)
                Else
                    PaintAll(SourceForm, TopOfListBox(SourceForm.ListBoxFlowChart) - 1, TopOfListBox(SourceForm.ListBoxFlowChart) + 1)
                    logA(1111, MyShowALine(MyUniverse.Area.MyWorldXY))
                    If MyOptionTest(25) = True Then
                    Else
                    End If
                End If
            Case "SymbolWindow" 'Move
                'Get the closest object (/path could be either end of the path)
                MyUniverse.ProgramOptions.SelectedObject = MyFindSymbolPoint(SourceForm, MyUniverse.Area.MyWorldXY.a, MyUniverse.ProgramOptions.SelectedSymbolName)
                'We should flash this object 
                'PaintAll( SourceForm.FlowChartPictureBox , MyStaticData.SelectedObject, MyStaticData.SelectedObject)
                Select Case LCase(Symbol_TableCoded_String(MyUniverse.ProgramOptions.SelectedObject))
                    Case "/Line"
                        ' need to find the closest end to change
                        If MyABS(MyUniverse.Area.MyWorldXY.a.x - Symbol_TableX1(MyUniverse.ProgramOptions.SelectedObject)) + MyABS(MyUniverse.Area.MyWorldXY.a.y - Symbol_TableY1(MyUniverse.ProgramOptions.SelectedObject)) > MyABS(MyUniverse.Area.MyWorldXY.a.x - Symbol_Table_X2(MyUniverse.ProgramOptions.SelectedObject)) + MyABS(MyUniverse.Area.MyWorldXY.a.y - Symbol_Table_Y2(MyUniverse.ProgramOptions.SelectedObject)) Then

                            Symbol_Table_X2(MyUniverse.ProgramOptions.SelectedObject, MyUniverse.Area.MyWorldXY.b.x)
                            Symbol_Table_Y2(MyUniverse.ProgramOptions.SelectedObject, MyUniverse.Area.MyWorldXY.b.y)
                        Else
                            Symbol_TableX1(MyUniverse.ProgramOptions.SelectedObject, MyUniverse.Area.MyWorldXY.b.x)
                            Symbol_TableY1(MyUniverse.ProgramOptions.SelectedObject, MyUniverse.Area.MyWorldXY.b.y)
                        End If
                    Case "/point"
                        'move to where the mouse button let up
                        Symbol_TableX1(MyUniverse.ProgramOptions.SelectedObject, MyUniverse.Area.MyWorldXY.b.x)
                        Symbol_TableY1(MyUniverse.ProgramOptions.SelectedObject, MyUniverse.Area.MyWorldXY.b.y)
                    Case Else
                        logA(1112, Symbol_TableCoded_String(MyUniverse.ProgramOptions.SelectedObject), MyShowSymbolGraphic(False, MyUniverse.ProgramOptions.SelectedObject))
                        If MyOptionTest(25) = True Then
                        Else
                        End If
                End Select
                'redisplay 1 (We should be turning off the old location)
                PaintAll(SourceForm, MyUniverse.ProgramOptions.SelectedObject, MyUniverse.ProgramOptions.SelectedObject)
            Case Else
                logA(1983, SourceForm.Parent.Name)
        End Select
    End Sub


    Friend Sub SelectInToolStripDropDownButton(CB As ListBox, WhatToSelect As String)
        Dim I As Integer
        Dim Temp As String
        If MyIsNothing(WhatToSelect) Then
            Return
        End If
        'CB.items.Find(WhatToSelect, True) ' undone not sure if this will work yet
        If CB.Items.Count < 1 Then
            Return
        End If
        For I = 0 To CB.Items.Count - 1
            Temp = CB.Items.Item(I).ToString
            If Temp = WhatToSelect Then
                MsgBox("Halt and check this")
                '''''CB.Items.Item(I).Select()
                CB.Text = WhatToSelect
                Return
            End If
            'todo need to make sure that there is a comma FD there (should pop() it
            If MyLeft(Temp, Len(WhatToSelect & FD)) = WhatToSelect & FD Then
                MsgBox("Halt and check this")
                '''''CB.Items.Item(I).Select()
                CB.Text = WhatToSelect
                Return
            End If
        Next
        logA(1118, WhatToSelect, CB.Name)
        'todo need to check if something was selected, and if not then select as close as you can get (ie, what to select="both", but the button has "Both,3" or "Both, 3")
        If MyOptionTest(25) = True Then
        Else
        End If
    End Sub






    'This should return something always.
    'If it is not in the list then it will return the one before where it should have gone

    '
    'Gives the Indexes to the index of the ISAM 

    Friend Function IsMyDigit(A As String) As Boolean
        Dim Z As String
        Z = MyUnicode.UnicodeClassCode(A)
        Select Case (Z)
            Case "Nd", "Nl", "No"
                Return True
            Case Else
                Return False
        End Select
        If MyLeft(A, 1) >= "0" And MyLeft(A, 1) <= "9" Then
            Return True
        End If
        Return False
    End Function

    Friend Function PowerOf3(K As String) As Boolean
        Dim j1, j2, j3, j4 As Integer

        If K = "" Then Return False
        j1 = CInt(Fix(Val(Mid(K, 1, 1))))
        j2 = CInt(Fix(Val(Mid(K, 2, 1))))
        j3 = CInt(Fix(Val(Mid(K, 3, 1))))
        j4 = j1 + j2 + j3
        If j4 Mod 3 = 0 Then Return True
        If j4 = 3 Then Return True
        If j4 = 6 Then Return True
        If j4 = 9 Then Return True
        If Len(K.ToString) < 2 Then Return False
        If PowerOf3(j4.ToString) = True Then Return True
        Return False
    End Function


    Friend Function SK(I As Integer, A As String) As String
        Dim K As String
        K = Mid(A, I, 1)
        If PopValue(K) > 3 Then
            Mid(A, I, 1) = "Y"
        Else
            Mid(A, I, 1) = "N"
        End If
        Return A
    End Function



    'todo needs to save the key in the registry
    Friend Function SecurityKey(ByRef X As String) As String
        Dim K As String
        Dim I As Integer
        'for security key
        '1 must be 16 digits long
        If Len(X) <> 16 Then
            ' A I N F O 2 (53)
            Return X
        End If

        '2 They must all be digits.
        For I = 1 To 16
            If IsMyDigit(Mid(X, I, 1)) = False Then
                ' A I N F O 2 (52)
                Return X
            End If
        Next

        '3 digits they must add up to 9
        For I = 1 To 14 Step 3
            K = Mid(X, I, 1) & Mid(X, I + 1, 1) & Mid(X, I + 2, 1)
            If PowerOf3(K) = False Then
                Return X
            End If
        Next I

        If X = "1234567891234560" Then Return X

        For I = 1 To 16
            X = SK(I, X)
        Next
        'byte 1 means they do something (disallow this program from running (just in case), disable all buttons (except maybe the select a computer language? may be not )
        'Byte 2 means not demo, they can input or Output
        'byte 3 means read only, they can not make changes to anything.(Or save anything?)
        'byte 4 means student they can make changes to the Symbol.)Or save Symbols?
        'byte 5 is the level they are allowed (A-Z)
        'byte 6 is the level they are at.(A-Z)
        Return X
    End Function


    Friend Function ProgrammerLevel(Level As Integer) As Integer
        'This will return if this option is on(1) or off (0) or the level of this option (student, beginning, etc)
        'SecurityRun=1            'they can run this program (ie they must enter something valid - Student,Teacher, Expert ... )
        'SecurityDemo=2           'demo mode
        'SecuritySave=3           'read only, they can not save anything
        'SecurityChangeSymbol '= 4  'they can make changes to the Symbol.
        'Security5=5              '
        'Security6=6              '
        'Security7=7              '
        'SecurityFlowChartWindow 8  'disables access to flowchart window
        'SecurityOptionsWindow=9  'disables access to option window
        'SecuritySymbolWindow=10  'disables access to Symbol Window
        'SecurityFileInputOutputWindow=11'disables access to File I/O
        'Security12=12           'digits 15 and 12 can not be zero, because they tell the professional level of the user
        'Security13=13
        'Security14=14
        'Security15=15           'digits 15 and 12 can not be zero, because they tell the professional level of the
        If Level > Len(MyUniverse.Security) Then Return 0
        If MyDebug(A_FMB) Then
            logA(2135, Level.ToString, MyUniverse.Security.ToString, Mid(MyUniverse.Security, Level, 1), MyUniverse.Security)
        End If
        Select Case Mid(MyUniverse.Security, Level, 1)
            Case "N", "n"
                Return 0
            Case "Y", "y"
                Return 1
                    'future security options
            Case "a", "A"
                Return 2
            Case "b", "B"
                Return 3
            Case "c", "C"
                Return 4
            Case "d", "D"
                Return 5
            Case "e", "E"
                Return 6
            Case "f", "F"
                Return 7
            Case "g", "G"
                Return 8
            Case "h", "H"
                Return 9
            Case "i", "I"
                Return 10
            Case "j", "J"
                Return 11
            Case Else
                Return Asc(Mid(MyUniverse.Security, Level, 1))
        End Select
    End Function



    'The string is a list of the items that can be done. (See list in Programmer level)
    Friend Function SetSecurityOption() As String
        Dim X As String
        SetSecurityOption = "NNNNNNNNNYYNNNNN"
        MyUniverse.PaidFor.FCRName = My.Application.Info.ProductName.ToString
        'MyUniverse.PaidFor.FCRVersion=My.Application.Info.Version.ToString
        'MyUniverse.PaidFor.FCRCPUid=CPUID1.CPU_ID() 'For now it is junk (Maybe the username, or some such junk

        'MyUniverse.PaidFor.FCRKey=CStr(My.Computer.Registry.GetValue("HKEY_CURRENT_USER\Software\FlowChart", "Key", "Needs FlowChart To Be Registered"))
        MyUniverse.PaidFor.FCRUserProfession = CStr(My.Computer.Registry.GetValue("HKEY_CURRENT_USER\Software\FlowChart", "TopLevel", "Needs FlowChart To Be Registered"))
        'MyUniverse.PaidFor.FCRUserLevel=CStr(My.Computer.Registry.GetValue("HKEY_CURRENT_USER\Software\FlowChart", "AtLevel", "Needs FlowChart To Be Registered"))

        If Mid(MyUniverse.PaidFor.FCRUserProfession, 3, 1) >= "A" And Mid(MyUniverse.PaidFor.FCRUserProfession, 3, 1) <= "Z" Then
            Mid(SetSecurityOption, 7, 1) = Mid(MyUniverse.PaidFor.FCRUserProfession, 3, 1)
        End If

        If Mid(MyUniverse.PaidFor.FCRUserLevel, 3, 1) >= "A" And Mid(MyUniverse.PaidFor.FCRUserLevel, 3, 1) <= "Z" Then
            Mid(SetSecurityOption, 7, 1) = Mid(MyUniverse.PaidFor.FCRUserLevel, 3, 1)
        End If
        If MyUniverse.PaidFor.FCRName <> CStr(My.Computer.Registry.GetValue("HKEY_CURRENT_USER\Software\FlowChart", "Name", "Needs FlowChart To Be Registered")) Then
            X = InputBox("This copy of Flow Chart has not been registered for this machine " & vbCr & "Student" & FD & "Teacher" & FD & "Programmer" & FD & "Expert", "Enter programmer Level for " & Environment.UserName, "Student")
            'bug I never save this so it always comes here
            'todo save this into the register
            '"YNNYYNYYYNYYNNNN" '
            '"YNYYYNYYYYYYYNNN" '
            '"YNYYYNYYYYYYYYNN" '
            '"YNYYYNYYYYYYYYYN" '

            Select Case LCase(X)
                Case "student"
                    '"YNNYYNYYYNYYNNNN" '
                    Return "YNYYYNYYYYYYYYYN" 'not allowed: save files, or symbol window, or change program options
                Case "teacher"
                    Return "YNYYYNYYYYYYYNNN" 'CAN SAVE
                Case "programmer"
                    '       123456789 123456
                    Return "YNYYYNYYYYYYYYNN" '
                Case "expert"
                    Return "YNYYYNYYYYYYYYYN" '
                Case Else
                    'todo need to add reading from a file the things any other programmer level has entered.
                    Return SecurityKey(X) '
            End Select
            Return SecurityKey(X) 'hack
        End If
    End Function


    Friend Function UseNetLinksNumber(ByRef SourceForm As Source, IndexFlowChart As Integer) As Integer
        MsgBox("Watch here")
        Return IndexFlowChart
        '''''Dim I As Integer
        '''''I = BinarySearch4Index(SourceForm.ListBoxVariables, IndexFlowChart)
        '''''If I > 0 Then
        '''''Return I
        '''''End If
        '''''Return ConstantMyErrorCode
    End Function


    'returns the index of this index, and puts in this name as a pathname
    Friend Function MakeNewNetLinks(ByRef SourceForm As Source, IndexFlowChart As Integer, PathName As String) As Integer '
        Dim IndexNet As Integer
        If Len(PathName) = 0 Then
            logA(1154, MyShowFlowChartRecord(SourceForm, False, IndexFlowChart), PathName)
            If MyOptionTest(25) = True Then
                PathName = MakeNewName(SourceForm, "Var_2_", FlowChart_Table_Path_SymbolName(SourceForm, IndexFlowChart))
                FlowChart_tablePathSymbolName(SourceForm, IndexFlowChart, PathName)
            Else
                PathName = MakeNewName(SourceForm, "Var1_", FlowChart_Table_Path_SymbolName(SourceForm, IndexFlowChart))
                FlowChart_tablePathSymbolName(SourceForm, IndexFlowChart, PathName)
            End If
        End If
        PathName = CheckThisPathName(SourceForm, PathName, IndexFlowChart)
        If Len(PathName) = 0 Then
            Return 0
        End If
        IndexNet = UseNetLinksNumber(SourceForm, IndexFlowChart)
        If IndexNet > 0 Then
            Return IndexNet
        End If

        For IndexNet = LBound(Net_FilePathNames) To MySizeOf(Net_FilePathNames)
            If PathName = Net_FilePathNames(IndexNet) Then
                Return IndexNet
            End If
        Next IndexNet


        ReDim Preserve Net_FileLinks()(SourceForm.ListBoxVariables.count - 1 + 1)
        ReDim Preserve Net_FilePathNames(MySizeOf(Net_FilePathNames) + 1)
        ReDim Preserve Net_FileDataType(MySizeOf(Net_FileDataType) + 1)
        IndexNet = SourceForm.ListBoxVariables.count - 1
        Net_TableLinks(IndexNet, Net_TableLinks(IndexNet) & FD & IndexFlowChart & FD)
        Net_TablePathNames(IndexNet, PathName)
        Net_FileDataType(IndexNet) = FlowChart_TableDataType(SourceForm, IndexFlowChart)

        Return IndexNet
    End Function


    Friend Function MyShowColumns(Input As String) As String
        ' make this comma delimited string into a string in columns (size of each column in columns)
        Dim I As Integer
        Dim RTN As String = ""
        Dim T As String
        T = Input
        I = 1
        While Len(T) > 0 And I < MySizeOf(MyUniverse.Column)
            RTN &= Spaced(MyUniverse.Column(I), MyTrim(Pop(T, FD & CT & vbCr & vbLf)))
            I += 1
        End While
        Return RTN
    End Function


    Friend Function MyShowUniverse() As String
        Dim R As String = ""
        R &= MyUniverse.Area.MyInputWindowXY.a.x.ToString
        R &= MyUniverse.Area.MyInputWindowXY.a.y.ToString
        R &= MyUniverse.Area.MyInputWindowXY.a.Named.PathName
        R &= MyUniverse.Area.MyInputWindowXY.a.Named.PointName
        R &= MyUniverse.Area.MyInputWindowXY.a.Named.SymbolName
        R &= MyUniverse.Area.MyInputWindowXY.a.Named.IsWorldWindow.ToString

        R &= MyUniverse.Area.MyInputWindowXY.b.x.ToString
        R &= MyUniverse.Area.MyInputWindowXY.b.y.ToString
        R &= MyUniverse.Area.MyInputWindowXY.b.Named.PathName
        R &= MyUniverse.Area.MyInputWindowXY.b.Named.PointName
        R &= MyUniverse.Area.MyInputWindowXY.b.Named.SymbolName
        R &= MyUniverse.Area.MyInputWindowXY.b.Named.IsWorldWindow.ToString

        R &= MyUniverse.Area.MyWorldXY.a.x.ToString
        R &= MyUniverse.Area.MyWorldXY.a.y.ToString
        R &= MyUniverse.Area.MyWorldXY.a.Named.PathName
        R &= MyUniverse.Area.MyWorldXY.a.Named.PointName
        R &= MyUniverse.Area.MyWorldXY.a.Named.SymbolName
        R &= MyUniverse.Area.MyWorldXY.a.Named.IsWorldWindow.ToString

        R &= MyUniverse.Area.MyWorldXY.b.x.ToString
        R &= MyUniverse.Area.MyWorldXY.b.y.ToString
        R &= MyUniverse.Area.MyWorldXY.b.Named.PathName
        R &= MyUniverse.Area.MyWorldXY.b.Named.PointName
        R &= MyUniverse.Area.MyWorldXY.b.Named.SymbolName
        R &= MyUniverse.Area.MyWorldXY.b.Named.IsWorldWindow.ToString

        R &= MyUniverse.FCCLDebugLevel_1.ToString
        R &= MyUniverse.FCCLDebugLevel_2.ToString
        R &= MyUniverse.Grammar.ToString
        R &= MyUniverse.MyDir_s.Languages
        R &= MyUniverse.MyDir_s.Program
        R &= MyUniverse.MyDir_s.Working
        R &= MyUniverse.MyMouseAndDrawing.FlowChartClosing.ToString
        R &= MyUniverse.MyMouseAndDrawing.MouseStatus
        R &= MyUniverse.MyMouseAndDrawing.MouseStroke
        R &= MyUniverse.MyMouseAndDrawing.MyScreen00.x.ToString
        R &= MyUniverse.MyMouseAndDrawing.MyScreen00.y.ToString
        R &= MyUniverse.MyMouseAndDrawing.MouseWindow.a.x.ToString
        R &= MyUniverse.MyMouseAndDrawing.MouseWindow.a.y.ToString
        R &= MyUniverse.MyMouseAndDrawing.MouseWindow.b.x.ToString
        R &= MyUniverse.MyMouseAndDrawing.MouseWindow.b.y.ToString
        R &= MyUniverse.MyMouseAndDrawing.MouseWorld.a.x.ToString
        R &= MyUniverse.MyMouseAndDrawing.MouseWorld.a.y.ToString
        R &= MyUniverse.MyMouseAndDrawing.MouseWorld.b.x.ToString
        R &= MyUniverse.MyMouseAndDrawing.MouseWorld.b.y.ToString
        R &= MyUniverse.MyMouseAndDrawing.PaintThisOrEraseThis.ToString
        R &= MyUniverse.MyProgramStatus
        R &= MyUniverse.MySS.LastName
        R &= MyUniverse.MySS.IndexName.ToString
        R &= MyUniverse.MySS.IndexSymbol.ToString
        R &= MyUniverse.MySS.TopMost.ToString
        R &= MyUniverse.MySS.Inputs.AllText
        R &= MyUniverse.MySS.Inputs.KWord
        R &= MyUniverse.MySS.Inputs.KPar
        R &= MyUniverse.MySS.Inputs.LineNumberIn.ToString
        R &= MyUniverse.MySS.MyRecord.Coded.ToString
        R &= MyUniverse.MySS.MyRecord.X1.ToString
        R &= MyUniverse.MySS.MyRecord.Y1.ToString
        R &= MyUniverse.MySS.MyRecord.X2.ToString
        R &= MyUniverse.MySS.MyRecord.Y2.ToString
        R &= MyUniverse.MySS.MyRecord.NameOfPoint
        R &= MyUniverse.MySS.MyRecord.a.x.ToString
        R &= MyUniverse.MySS.MyRecord.a.y.ToString
        R &= MyUniverse.MySS.MyRecord.a.Named.PointName
        R &= MyUniverse.MySS.MyRecord.a.Named.PathName
        R &= MyUniverse.MySS.MyRecord.a.Named.SymbolName
        R &= MyUniverse.MySS.MyRecord.b.x.ToString
        R &= MyUniverse.MySS.MyRecord.b.y.ToString
        R &= MyUniverse.MySS.MyRecord.b.Named.PointName
        R &= MyUniverse.MySS.MyRecord.b.Named.PathName
        R &= MyUniverse.MySS.MyRecord.b.Named.SymbolName

        R &= MyUniverse.MyStaticData.Color_TableCount.ToString
        R &= MyUniverse.MyStaticData.DataType_TableCount.ToString
        'R &= MyUniverse.MyStaticData.FindIndex_In_TableNetLinks.LastFound.ToString
        'R &= MyUniverse.MyStaticData.FindIndex_In_TableNetLinks.LastIndex.ToString
        'R &= MyUniverse.MyStaticData.FindIndex_In_TableNetLinks.LastPathName
        'R &= MyUniverse.MyStaticData.FindIndex_In_TableNetLinks.LastPathName
        '''''R &= MyUniverse.MyStaticData.FlowChart_FilePathName.LastFlowChart_FilePathName
        '''''R &= MyUniverse.MyStaticData.FlowChart_FilePathName.LastIndexFlowChart.ToString
        R &= MyUniverse.MyStaticData.FlowChart_TableCount.ToString
        R &= MyUniverse.MyStaticData.FoundX.ToString
        R &= MyUniverse.MyStaticData.FoundY.ToString
        '''''R &= MyUniverse.MyStaticData.GrammarTerminal.ToString
        '''''R &= MyUniverse.MyStaticData.GrammarTerminal.LastGrammarIndex.ToString
        '''''R &= MyUniverse.MyStaticData.GrammarTerminal.LastGrammarTerminal
        R &= MyUniverse.MyStaticData.Hints(0)
        R &= MyUniverse.MyStaticData.Hints(1)
        R &= MyUniverse.MyStaticData.Hints(2)
        R &= MyUniverse.MyStaticData.Hints(3)
        R &= MyUniverse.MyStaticData.Hints(4)
        R &= MyUniverse.MyStaticData.Hints(5)
        R &= MyUniverse.MyStaticData.Hints(6)
        R &= MyUniverse.MyStaticData.Hints(7)
        R &= MyUniverse.MyStaticData.Hints(8)
        R &= MyUniverse.MyStaticData.Hints(9)
        R &= MyUniverse.MyStaticData.Hints(10)
        'R &= MyUniverse.MyStaticData.Do_Not_Use_IsThisAWhat.LastCodeLine
        'R &= MyUniverse.MyStaticData.Do_Not_Use_IsThisAWhat.LastWhat
        R &= MyUniverse.MyStaticData.LastColor.ToString
        R &= MyUniverse.MyStaticData.LastHex
        R &= MyUniverse.MyStaticData.LastValue.ToString
        R &= MyUniverse.MyStaticData.LookForX.ToString
        R &= MyUniverse.MyStaticData.LookForY.ToString
        R &= MyUniverse.MyStaticData.MaxXY.x.ToString
        R &= MyUniverse.MyStaticData.MaxXY.y.ToString
        R &= MyUniverse.MyStaticData.MaxXY.Named.PointName
        R &= MyUniverse.MyStaticData.MaxXY.Named.PathName
        R &= MyUniverse.MyStaticData.MaxXY.Named.SymbolName
        'R &= MyUniverse.MyStaticData.MicroCodeText2Syntax.LastMicroCodeText
        'R &= MyUniverse.MyStaticData.MicroCodeText2Syntax.LastGetMyRecord(lb, *)
        'R &= MyUniverse.MyStaticData.MicroCodeText2Syntax.LastPathNames
        R &= MyUniverse.MyStaticData.MinXY.x
        R &= MyUniverse.MyStaticData.MinXY.y
        R &= MyUniverse.MyStaticData.MinXY.Named.PointName
        R &= MyUniverse.MyStaticData.MinXY.Named.PathName
        R &= MyUniverse.MyStaticData.MinXY.Named.SymbolName
        'R &= MyUniverse.MyStaticData.MyDisplayStatus.LastStatusBox.ToString
        'R &= MyUniverse.MyStaticData.MyDisplayStatus.LastTemp
        '''''R &= MyUniverse.MyStaticData.MyEnum.LastComboBox
        'R &= MyUniverse.MyStaticData.MyEnum.LastResults(*)
        '''''R &= MyUniverse.MyStaticData.MyEnum.LastUnEnum
        '''''R &= MyUniverse.MyStaticData.MyEnum.LastWhatString
        '''''R &= MyUniverse.MyStaticData.MyEnum.Last_Enum.ToString
        'R &= MyUniverse.MyStaticData.MyFindColor.lastIndex.ToString
        'R &= MyUniverse.MyStaticData.MyFindColor.LastString
        'R &= MyUniverse.MyStaticData.MyFindMyGrammarName.LastIndex
        'R &= MyUniverse.MyStaticData.MyFindMyGrammarName.LastName
        'R &= MyUniverse.MyStaticData.MyParse_X.LastCodeLine
        'R &= MyUniverse.MyStaticData.MyParse_X.LastFrom_what
        'R &= MyUniverse.MyStaticData.MyParse_X.LastGetMyRecord(lb, *)
        'R &= MyUniverse.MyStaticData.MyParse_X.LastParseArray(*)
        'R &= MyUniverse.MyStaticData.MyParse_X.LastParsedVariableNames
        'R &= MyUniverse.MyStaticData.MyParse_X.LastPathNames
        'R &= MyUniverse.MyStaticData.MyShowAndUpDateProperties.LastIndex.ToString
        'R &= MyUniverse.MyStaticData.MyShowAndUpDateProperties.LastSyntax
        '''''R &= MyUniverse.MyStaticData.MyUnEnum.LastComboBox
        'R &= MyUniverse.MyStaticData.MyUnEnum.LastResults(*)
        '''''R &= MyUniverse.MyStaticData.MyUnEnum.LastUnEnum
        '''''R &= MyUniverse.MyStaticData.MyUnEnum.LastWhatString
        '''''R &= MyUniverse.MyStaticData.MyUnEnum.Last_Enum.ToString
        'R &= MyUniverse.MyStaticData.My_Code_Line_Parsed(*)
        'R &= MyUniverse.MyStaticData.My_Syntax_Line_Parsed(*)
        R &= MyUniverse.MyStaticData.Named_TableCount.ToString
        R &= MyUniverse.MyStaticData.Painting.Ending.ToString
        R &= MyUniverse.MyStaticData.Painting.PanX.ToString
        R &= MyUniverse.MyStaticData.Painting.PanY.ToString
        R &= MyUniverse.MyStaticData.Painting.Start.ToString
        R &= MyUniverse.MyStaticData.Path_Names
        R &= MyUniverse.MyStaticData.Path_NamesCounted.ToString
        R &= MyUniverse.MyStaticData.ShowAllWindows.F1.ToString
        R &= MyUniverse.MyStaticData.ShowAllWindows.F2.ToString
        R &= MyUniverse.MyStaticData.ShowAllWindows.F3.ToString
        R &= MyUniverse.MyStaticData.ShowAllWindows.F4.ToString
        R &= MyUniverse.MySystem.Dumps.OutputFileName1
        R &= MyUniverse.MySystem.Dumps.OutputFileName2
        R &= MyUniverse.MySystem.Dumps.OutputFileName3
        R &= MyUniverse.MySystem.FCProcessID.ToString
        R &= MyUniverse.MySystem.FlowChartOptions(0).OptionNames
        R &= MyUniverse.MySystem.FlowChartOptions(0).OptionNumber.ToString
        R &= MyUniverse.MySystem.FlowChartOptions(1).OptionNames
        R &= MyUniverse.MySystem.FlowChartOptions(1).OptionNumber.ToString
        R &= MyUniverse.MySystem.FlowChartOptions(2).OptionNames
        R &= MyUniverse.MySystem.FlowChartOptions(2).OptionNumber.ToString
        R &= MyUniverse.MySystem.FlowChartOptions(3).OptionNames
        R &= MyUniverse.MySystem.FlowChartOptions(3).OptionNumber.ToString
        R &= MyUniverse.MySystem.FlowChartOptions(4).OptionNames
        R &= MyUniverse.MySystem.FlowChartOptions(4).OptionNumber.ToString
        R &= MyUniverse.MySystem.FlowChartOptions(5).OptionNames
        R &= MyUniverse.MySystem.FlowChartOptions(5).OptionNumber.ToString
        R &= MyUniverse.MySystem.FlowChartOptions(6).OptionNames
        R &= MyUniverse.MySystem.FlowChartOptions(6).OptionNumber.ToString
        R &= MyUniverse.MySystem.FlowChartOptions(7).OptionNames
        R &= MyUniverse.MySystem.FlowChartOptions(7).OptionNumber.ToString
        R &= MyUniverse.MySystem.FlowChartOptions(8).OptionNames
        R &= MyUniverse.MySystem.FlowChartOptions(8).OptionNumber.ToString
        R &= MyUniverse.MySystem.FlowChartOptions(9).OptionNames
        R &= MyUniverse.MySystem.FlowChartOptions(9).OptionNumber.ToString
        R &= MyUniverse.MySystem.FlowChartOptions(10).OptionNames
        R &= MyUniverse.MySystem.FlowChartOptions(10).OptionNumber.ToString
        R &= MyUniverse.MySystem.SelectionOption.ToString
        R &= MyUniverse.MySystem.WindowsStatus(1).ToString
        R &= MyUniverse.MySystem.WindowsStatus(2).ToString
        R &= MyUniverse.MySystem.WindowsStatus(3).ToString
        R &= MyUniverse.MySystem.WindowsStatus(4).ToString
        'R &= MyUniverse.OptionDisplay.x
        'R &= MyUniverse.OptionDisplay.y
        'R &= MyUniverse.OptionDisplay.ColorName
        'R &= MyUniverse.OptionDisplay.TextWidth.tostring
        'R &= MyUniverse.OptionDisplay.TextHeight.tostring
        R &= MyUniverse.PaidFor.FCRName
        R &= MyUniverse.PaidFor.FCRUserLevel
        R &= MyUniverse.PaidFor.FCRUserProfession
        R &= MyUniverse.PaidFor.ID
        R &= MyUniverse.Paint.ToString
        R &= MyUniverse.ProgramOptions.FCCL_Dimension
        R &= Options.ListBoxSymbolData.Items.Item(20).ToString
        R &= Options.ListBoxSymbolData.Items.Item(21).ToString
        'R &= MyUniverse.ProgramOptions.FCCL_Extension
        R &= Options.ListBoxSymbolData.Items.Item(25).ToString
        R &= MyUniverse.ProgramOptions.FCCL_MultiLine
        R &= MyUniverse.ProgramOptions.FCCL_LanguageClassName
        R &= Options.ListBoxSymbolData.Items.Item(23).ToString
        R &= MyUniverse.ProgramOptions.FCCL_VarChars
        R &= MyUniverse.ProgramOptions.FCCL_Order
        R &= MyUniverse.ProgramOptions.FCCL_WhiteSpace
        R &= MyUniverse.ProgramOptions.FCCL_Roots
        R &= MyUniverse.ProgramOptions.FCCL_NotRoots
        R &= MyUniverse.ProgramOptions.FlowChartTextBox
        R &= MyUniverse.ProgramOptions.SelectedSymbolName
        R &= MyUniverse.ProgramOptions.SelectedDataType
        R &= MyUniverse.ProgramOptions.SelectedColor
        R &= MyUniverse.ProgramOptions.SelectedInputOutput
        R &= MyUniverse.ProgramOptions.SelectedRotation
        R &= MyUniverse.ProgramOptions.SelectedPathStart
        R &= MyUniverse.ProgramOptions.SelectedPathEnd
        R &= MyUniverse.ProgramOptions.SelectedPathLineStyle
        R &= MyUniverse.ProgramOptions.SelectedNumberOfBytes

        R &= MyUniverse.ProgramOptions.SelectedObject.ToString
        R &= MyUniverse.ProgramOptions.HelpURL
        R &= MyUniverse.ProgramOptions.SymbolChanged.ToString

        R &= MyUniverse.Security


        R &= MyUniverse.SysGen.Constants.ConstantDelimiters
        R &= MyUniverse.SysGen.Constants.ConstantDistanceBetweenControls.ToString
        R &= MyUniverse.SysGen.Constants.ConstantDistanceToMovePaths.ToString
        R &= MyUniverse.SysGen.Constants.DrillDown_FileName  'ONLY Current File name Device:/Paths/Filename.Extension   '(direction, First-Second Line, X/Y
        R &= MyUniverse.SysGen.Constants.ConstantMaxPenSize.ToString
        R &= MyUniverse.SysGen.Constants.ConstantMinBoxSize.ToString
        R &= MyUniverse.SysGen.Constants.ConstantMinPenSize.ToString
        R &= MyUniverse.SysGen.Constants.ConstantQuote
        R &= MyUniverse.SysGen.Constants.ConstantRecordsBeforeSaveIsAllowed.ToString
        R &= MyUniverse.SysGen.Constants.ConstantSpacingFactor.ToString
        R &= MyUniverse.SysGen.Constants.ConstantSpecialCharacters
        R &= MyUniverse.SysGen.Constants.ConstantSymbolCenter.ToString
        R &= MyUniverse.SysGen.Constants.ConstantWhiteSpaces

        R &= MyUniverse.SysGen.Markers.AlphaNumeric
        R &= MyUniverse.SysGen.Markers.Alphas
        R &= MyUniverse.SysGen.Markers.Block
        R &= MyUniverse.SysGen.Markers.BranchToNextLine
        R &= MyUniverse.SysGen.Markers.CameFromLine
        R &= MyUniverse.SysGen.Markers.Comments
        R &= MyUniverse.SysGen.Markers.DataType
        R &= MyUniverse.SysGen.Markers.FieldDelimiters
        R &= MyUniverse.SysGen.Markers.Functions
        R &= MyUniverse.SysGen.Markers.Grammar
        R &= MyUniverse.SysGen.Markers.HexRange
        R &= MyUniverse.SysGen.Markers.KeyWords
        R &= MyUniverse.SysGen.Markers.Literal  'single quoted (for grammar only)
        R &= MyUniverse.SysGen.Markers.Markers
        R &= MyUniverse.SysGen.Markers.Numbers
        R &= MyUniverse.SysGen.Markers.Operators
        R &= MyUniverse.SysGen.Markers.Quotes  'double quote
        R &= MyUniverse.SysGen.Markers.SpecialCharacter
        R &= MyUniverse.SysGen.Markers.UnicodeClass
        R &= MyUniverse.SysGen.Markers.Unknowns
        R &= MyUniverse.SysGen.Markers.WhiteSpaces
        Return R
    End Function

    Friend Function MyShowEveryThingAtXY(ByRef SourceForm As Source, x As Integer, y As Integer) As String
        Dim RTN As String = ""
        Dim IndexFlowChart, IndexNamed, IndexSymbol As Integer
        Dim xy As MyPointStructure
        Dim heading As String
        heading = ""
        For IndexFlowChart = 1 To TopOfListBox(SourceForm.ListBoxFlowChart)
            Select Case FlowChart_TableCode(SourceForm, IndexFlowChart)
                Case "/use"
                    IndexNamed = FindInNamedList(FlowChart_TableSymbol_Name(SourceForm, IndexFlowChart))
                    IndexSymbol = Named_TableSymbolIndexes(IndexNamed) + 1
                    heading = MyShowFlowChartRecord(SourceForm, True, IndexFlowChart) & vbCrLf
                    While IndexSymbol <= TopOfFile(SourceForm, "Symbol") And Symbol_TableCoded_String(IndexSymbol) <> "/name"
                        Select Case Symbol_TableCoded_String(IndexSymbol)
                            Case "/point"
                                xy.x = FlowChart_TableX1(SourceForm, IndexFlowChart) + Symbol_TableX1(IndexSymbol)
                                xy.y = FlowChart_TableY1(SourceForm, IndexFlowChart) + Symbol_TableY1(IndexSymbol)
                                If x = xy.x And y = xy.y Then
                                    RTN &= MyShowSymbolGraphic(True, IndexSymbol) & vbCrLf
                                    heading = ""
                                End If
                            Case "/Line"
                            Case "/name"
                                Exit While
                            Case Else
                                RTN &= MyShowSymbolGraphic(True, IndexSymbol) & vbCrLf
                                heading = ""
                        End Select
                        IndexSymbol += 1
                    End While

                Case "/path"
                    If FlowChart_TableX1(SourceForm, IndexFlowChart) = x And FlowChart_TableY1(SourceForm, IndexFlowChart) = y Then
                        If MyDebug(A_INFORMATION) Then logA(2144, MyShowFlowChartRecord(SourceForm, True, IndexFlowChart))
                        RTN &= MyShowSymbolGraphic(True, IndexSymbol) & vbCrLf
                    End If
                    If FlowChart_TableX2(SourceForm, IndexFlowChart) = x And FlowChart_TableY2(SourceForm, IndexFlowChart) = y Then
                        If MyDebug(A_INFORMATION) Then logA(2145, MyShowFlowChartRecord(SourceForm, True, IndexFlowChart), MyShowPoint(x, y))
                        RTN &= MyShowSymbolGraphic(True, IndexSymbol) & vbCrLf
                    End If
                Case "/delete"
                    If MyDebug(A_DISPLAY) Then logA(2113, FlowChart_TableCode(SourceForm, IndexFlowChart), heading)
                Case Else
                    logA(2113, FlowChart_TableCode(SourceForm, IndexFlowChart), heading)
                    RTN &= MyShowSymbolGraphic(True, IndexSymbol) & vbCrLf
                    'My_KeyConstUnknown
                    'My_KeyConstUnKnownError
                    'My_KeyConstError
                    'My_KeyConstDelete , 14
                    'My_KeyConstConstant , 15
                    'My_KeyConstOption , 25
            End Select
        Next IndexFlowChart
        RTN = RTN.Replace(vbCrLf & vbCrLf, vbCrLf)
        RTN = RTN.Replace(vbCrLf & vbCrLf, vbCrLf)
        RTN = RTN.Replace(vbCrLf & vbCrLf, vbCrLf)
        Return RTN
    End Function

    Friend Function MyShowMouseEvent(E As MouseEventArgs) As String
        Dim RTN As String = ""
        RTN &= E.X.ToString
        RTN &= COMMA & E.Y.ToString
        RTN &= COMMA & E.ToString
        RTN &= COMMA & E.Clicks.ToString
        RTN &= COMMA & E.Delta.ToString
        Return RTN
    End Function

    Friend Function MyShowLinesAndPoints() As String
        Dim I As Integer
        MyShowLinesAndPoints = ""
        For I = 0 To Library.ListBoxLineColor.Items.Count - 1
            MyShowLinesAndPoints &= Library.ListBoxLineColor.Items.Item(I).ToString & vbCrLf
        Next
        For I = 0 To Library.ListBoxPointNameList.Items.Count - 1
            MyShowLinesAndPoints &= Library.ListBoxPointNameList.Items.Item(I).ToString & vbCrLf
        Next
    End Function

    'todo this is not used.
    Friend Function MyShowInputOutput(expanded As Boolean, Pt As IOTypeStructure) As String
        If expanded = True Then
            MyShowInputOutput = "(:Input>" & Pt.Input & ":Output<" & Pt.Output & ":both<,>" & Pt.Both & ":other?" & Pt.Other & ")"
        Else
            MyShowInputOutput = ":>" & Pt.Input & ":<" & Pt.Output & ":<,>" & Pt.Both & ":?" & Pt.Other
        End If
        Return MyShowInputOutput & vbCrLf
    End Function

    Friend Sub AddSymbolUp(ByRef A As MySymbolCountsStructure)

        AddUp(A.Path.NumberOfConnectionsToOtherPaths)
        AddUp(A.Path.NumberOfConnectionsToSymbols)
        A.Path.Total = A.Path.NumberOfConnectionsToOtherPaths.Total + A.Path.NumberOfConnectionsToSymbols.Total + A.Path.NumberOfErrors

        AddUp(A.Symbol.NumberOfLines)
        AddUp(A.Symbol.NumberOfOther)
        AddUp(A.Symbol.NumberOfPoints)
        A.Symbol.Total = A.Symbol.NumberOfLines.Total + A.Symbol.NumberOfOther.Total + A.Symbol.NumberOfPoints.Total
        A.Total = A.Path.Total + A.Symbol.Total
    End Sub



    Public Sub AddUp(ByRef A As PointTypeStructure)
        A.Data.Total = A.Data.Both + A.Data.Input + A.Data.Output + A.Data.Other
        A.Logic.Total = A.Logic.Both + A.Logic.Input + A.Logic.Output + A.Logic.Other
        A.Total = A.Data.Total + A.Logic.Total
    End Sub

    Public Sub MakeZero(ByRef A As PointTypeStructure)
        A.Data.Both = 0
        A.Data.Input = 0
        A.Data.Output = 0
        A.Data.Other = 0
        A.Data.Total = 0
        A.Logic.Both = 0
        A.Logic.Input = 0
        A.Logic.Output = 0
        A.Logic.Other = 0
        A.Logic.Total = 0
        A.Total = 0
    End Sub



    ' counts the type of the number of points in an existing Symbol
    Friend Sub NumberOfGraphicsInASymbol(ByRef SourceForm As Source, IndexSymbol As Integer, IndexFlowChart As Integer)
        Dim LocalIndex, JIndex As Integer
        Dim SymbolName, PointName As String
        Dim I As Integer

        SymbolName = Symbol_TableSymbolName(IndexSymbol)
        MyUniverse.SymbolAndPath.Name = SymbolName
        MakeZero(MyUniverse.SymbolAndPath.Symbol.NumberOfLines)
        MakeZero(MyUniverse.SymbolAndPath.Symbol.NumberOfOther)
        MakeZero(MyUniverse.SymbolAndPath.Symbol.NumberOfPoints)
        MakeZero(MyUniverse.SymbolAndPath.Path.NumberOfConnectionsToOtherPaths)
        MakeZero(MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfOther)
        MakeZero(MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfLines)
        MakeZero(MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfPoints)
        MyUniverse.SymbolAndPath.Symbol.Total = 0
        MyUniverse.SymbolAndPath.Path.Total = 0
        MyUniverse.SymbolAndPath.Uses.Total = 0
        MyUniverse.SymbolAndPath.Total = 0
        If IndexFlowChart < 1 And IndexSymbol < 1 Then Return
        AddSymbolUp(MyUniverse.SymbolAndPath)
        'Debug . Print ( MyShowPointCounts(True))
        'todo is this necessary '''  LocalIndex=IndexSymbol + 1
        If IndexSymbol >= 1 Then
            For LocalIndex = IndexSymbol + 1 To TopOfFile(SourceForm, "Symbol")
                Select Case PrintAbleNull(Symbol_TableCoded_String(LocalIndex).ToString)
                    Case "/name" ' Start of the next Symbol
                        AddSymbolUp(MyUniverse.SymbolAndPath)
                        logA(3515, MyShowPointCounts(True))
                        Return
                    Case "/point"
                        'todo this is adding extra names to the list of point names, to allow you to just add a point
                        While MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Total + 1 > Library.ListBoxPointNameList.Items.Count
                            If Len(Symbol_Table_NameOfPoint(LocalIndex)) > 0 Then
                                AddPointNameToDropDownX(SourceForm, Symbol_Table_NameOfPoint(LocalIndex))
                            Else Return
                            End If
                            LocalIndex += 1
                        End While
                        AddPointNameToDropDownX(SourceForm, Symbol_Table_NameOfPoint(LocalIndex))
                        'if MyDebug(a_information) then  log_X (2745, MyShowComboBoxItems(library.ListBoxPointNameList ))

                        If Library.ListBoxPointNameList.Items.Count - 1 < 1 Then
                            Library.ListBoxPointNameList.Items.Add("Point_Name" & MyRnd(3))
                        End If
                        AddSymbolUp(MyUniverse.SymbolAndPath)
                        'Debug . Print ( MyShowPointCounts(True))
                        'Debug1 = MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Total
                        'If Debug1 < 1 Then
                        'log_X(1547, Debug1.ToString, (library.ListBoxPointNameList .Items.Count - 1).ToString, MyShowPointCounts(True))
                        'Dump2(SourceForm  )
                        'End If
                        'If Debug1 > library.ListBoxPointNameList .Items.Count - 1 Then
                        'log_X(1548, Debug1.ToString, (library.ListBoxPointNameList .Items.Count - 1).ToString)
                        'End If
                        'todo this is placing a variable in the wrong spot 
                        'library.ListBoxPointNameList .Items.Item(MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Total)=CStr(Symbol_Table_NameOfPoint(LocalIndex).ToString)
                        MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Total += 1
                        AddSymbolUp(MyUniverse.SymbolAndPath)
                        'Debug . Print ( MyShowPointCounts(True))
                        'PointName=Symbol_Table_NameOfPoint(LocalIndex)
                        'PointName=Symbol_Table_InputOutput(LocalIndex)
                        PointName = Symbol_Table_DataType(LocalIndex)
                        Select Case LCase(Pop(PointName, FD))
                            Case "Logic"
                                Select Case LCase(Pop(Symbol_Table_InputOutput(LocalIndex), FD))
                                    Case "input", "OptionalInput"
                                        MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Logic.Input += 1
                                        AddSymbolUp(MyUniverse.SymbolAndPath)
                                        logA(3516, MyShowPointCounts(True))
                                    Case "Output", "OptionalOutput"
                                        MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Logic.Output += 1
                                        AddSymbolUp(MyUniverse.SymbolAndPath)
                                            'log_X(3517,MyShowPointCounts(True))
                                    Case "both", "OptionalBoth"
                                        MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Logic.Both += 1
                                        AddSymbolUp(MyUniverse.SymbolAndPath)
                                            'log_X(3518,MyShowPointCounts(True))
                                    Case Nothing
                                        MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Logic.Other += 1
                                        AddSymbolUp(MyUniverse.SymbolAndPath)
                                        logA(3519, MyShowPointCounts(True))
                                    Case Else
                                        MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Logic.Other += 1
                                        AddSymbolUp(MyUniverse.SymbolAndPath)
                                        logA(3520, MyShowPointCounts(True))
                                End Select
                            Case Else
                                Select Case LCase(Pop(Symbol_Table_InputOutput(LocalIndex), FD))
                                    Case "input", "OptionalInput"
                                        MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Data.Input += 1
                                        AddSymbolUp(MyUniverse.SymbolAndPath)
                                        logA(3521, MyShowPointCounts(True))
                                    Case "Output", "OptionalOutput"
                                        MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Data.Output += 1
                                        AddSymbolUp(MyUniverse.SymbolAndPath)
                                        logA(3522, MyShowPointCounts(True))
                                    Case "IO", "both", "OptionalBoth"
                                        MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Data.Both += 1
                                        AddSymbolUp(MyUniverse.SymbolAndPath)
                                        logA(3523, MyShowPointCounts(True))
                                    Case Nothing
                                        MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Data.Other += 1 'error of come kind
                                        AddSymbolUp(MyUniverse.SymbolAndPath)
                                        logA(3524, MyShowPointCounts(True))
                                    Case Else
                                        logA(1160, LocalIndex.ToString, Symbol_Table_InputOutput(LocalIndex), MyShowSymbolGraphic(True, LocalIndex))
                                        AddSymbolUp(MyUniverse.SymbolAndPath)
                                        logA(3525, MyShowPointCounts(True))
                                        If MyOptionTest(25) = True Then
                                        Else
                                        End If
                                        MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Data.Other += 1
                                        AddSymbolUp(MyUniverse.SymbolAndPath)
                                        logA(3526, MyShowPointCounts(True))
                                End Select
                        End Select
                        AddSymbolUp(MyUniverse.SymbolAndPath)
                            'Debug . Print ( MyShowPointCounts(True))
                    Case "/Line"
                        For I = 0 To Library.ListBoxLineColor.Items.Count - 1
                            If Library.ListBoxLineColor.Items(I).ToString = Symbol_Table_NameOfPoint(LocalIndex) Then
                                Exit Select
                            End If
                        Next I
                        If MyUniverse.SymbolAndPath.Symbol.NumberOfLines.Total > Library.ListBoxLineColor.Items.Count Then
                            AddLineNameToDropDown("Line Color" & CStr(Library.ListBoxLineColor.Items.Count))
                        End If

                        MyUniverse.SymbolAndPath.Symbol.NumberOfLines.Data.Other += 1
                        AddLineNameToDropDown(Symbol_Table_NameOfPoint(LocalIndex) & ", " & MyShowSymbolLines_detail(LocalIndex))
                        If MyUniverse.SymbolAndPath.Symbol.NumberOfLines.Data.Other <> Library.ListBoxLineColor.Items.Count Then
                            MyUniverse.SymbolAndPath.Symbol.NumberOfLines.Data.Other = Library.ListBoxLineColor.Items.Count
                        End If
                        AddSymbolUp(MyUniverse.SymbolAndPath)
                            'log_X(3527,MyShowPointCounts(True))
                    Case "/error"
                        MyUniverse.SymbolAndPath.Symbol.NumberOfOther.Data.Other += 1 ' just counting the number of error records found in the table
                        AddSymbolUp(MyUniverse.SymbolAndPath)
                        logA(3528, MyShowPointCounts(True))
                    Case "/unknown"
                    Case "/delete" ' do not count these 
                    Case Else
                        MyUniverse.SymbolAndPath.Symbol.NumberOfOther.Data.Other += 1 ' just counting the number of error records found in the table
                        logA(1123, Symbol_TableCoded_String(LocalIndex), MyShowSymbolGraphic(True, LocalIndex))
                        If MyOptionTest(25) = True Then
                        Else
                        End If
                        MyUniverse.SymbolAndPath.Symbol.NumberOfOther.Data.Other += 1 ' just count other things (not accounted for)
                        logA(3529, MyShowPointCounts(True))
                End Select
                AddSymbolUp(MyUniverse.SymbolAndPath)
                'log_X(3530,MyShowPointCounts(True))
            Next
        End If
        If IndexFlowChart >= 1 Then
            'count path and use
            For LocalIndex = 1 To TopOfListBox(SourceForm.ListBoxFlowChart)
                If FlowChart_TableCode(SourceForm, LocalIndex) = "/path" Then
                    For JIndex = 1 To TopOfListBox(SourceForm.ListBoxFlowChart)
                        If FlowChart_TableCode(SourceForm, JIndex) = "/path" Then
                            If LocalIndex <> JIndex Then
                                If FlowChart_TablePathName(SourceForm, LocalIndex) = FlowChart_TablePathName(SourceForm, JIndex) Then
                                    If MyOptionTest(25) = True Then
                                    Else
                                    End If
                                End If
                            End If
                        End If
                    Next
                End If
            Next
        End If
        AddSymbolUp(MyUniverse.SymbolAndPath)
        'log_X(3531,MyShowPointCounts(True))
        If MyDebug(A_DISPLAY) Then
            logA(2758, MyShowPointCounts(True))
        End If
        AddSymbolUp(MyUniverse.SymbolAndPath)
        'log_X(3532,MyShowPointCounts(True))
    End Sub
    '''<summary>   
    '''<param name="FromWhat" Fromwhat ="From"> This is the old Symbol Name</param>
    '''<param name="ToWhat" ToWhat="To" >This is the the new Symbol name</param>
    '''<para> Function MyRenameSymbol  This will rename the Symbol and all of the use
    '''<!-- returns the number of times it change the Symbol name (one for the Symbol, and the rest in the FlowChart.-->
    '''if their is not a Symbol with this name already.</para>
    '''<remarks>The Symbol name can not be changed to be nothing.</remarks>
    '''</summary> 
    Friend Function MyRenameSymbol(ByRef SourceForm As Source, FromWhat As String, ToWhat As String) As Integer ' Returns the number of names changed, or <0 if there is an error during the process of changing the name
        Dim Indexes, counter As Integer
        If FromWhat = ToWhat Then
            Return 0 'Equal
        End If
        If PrintAbleNull(ToWhat) = PrintAbleNull(Nothing) Then
            Return 0
        End If
        logA(1113, FromWhat, ToWhat)
        'First need to check that there is no old name
        If FindInNamedList(ToWhat) > 0 Then
            Return -2 'Symbol name already exist
        End If
        If FindInSymbolList(SourceForm, ToWhat) > 0 Then
            Return -3 'Symbol graphics already exist
        End If

        If FindInNamedList(FromWhat) < 0 Then
            Return -4 ' the old name does not exist
        End If
        If FindInSymbolList(SourceForm, FromWhat) < 0 Then
            Return -5 ' There is no graphic records.
        End If

        counter = 0
        'First go through the Symbols
        For Indexes = 1 To TopOfFile(SourceForm, "Symbol")
            If Symbol_TableCoded_String(Indexes) = "/name" Then
                If Symbol_TableSymbolName(Indexes) = FromWhat Then
                    Symbol_TableSymbolName(Indexes, ToWhat) 'Rename what it uses.
                    counter += 1
                End If
            End If
        Next

        'then go through the name (control of the Symbols)
        For Indexes = 1 To TopOfFile(SourceForm, "Symbol")
            If Named_TableSymbolName(Indexes) = FromWhat Then
                Named_TableSymbolName(Indexes, ToWhat) ' update the name
                counter += 1
            End If
        Next
        'then go through the FlowChart and rename all of the /use
        For Indexes = 1 To TopOfListBox(SourceForm.ListBoxFlowChart)
            If FlowChart_TableCode(SourceForm, Indexes) = My_keyWord(My_KeyConstUse) Then
                If FlowChart_TableSymbol_Name(SourceForm, Indexes) = FromWhat Then
                    FlowChart_tablePathSymbolName(SourceForm, Indexes, ToWhat) ' update the name
                    counter += 1
                End If
            End If
        Next
        logA(1171, FromWhat, ToWhat, counter.ToString)
        ' A I N F O 2 (82)
        Return counter
    End Function

    Friend Function FindInNamedList(SymbolNameToFind As String) As Integer
        Dim IndexNamed As Integer

        ' Cheat first now
        If SymbolNameToFind = "" Then
            ' A I N F O 2 (83)
            Return ConstantMyErrorCode
        End If
        IndexNamed = BinarySearch4Index(Options.ListBoxSymbols, SymbolNameToFind)
        If IndexNamed <= 0 Then
            ' A I N F O 2 (85)
            Return CheckNotInList("named", SymbolNameToFind)
        Else
            ' A I N F O 2 (86)
            Return IndexNamed
        End If
    End Function


    Friend Function FindCorrectingIndexes(ByRef SourceForm As Source, SymbolNameToFind As String) As Integer
        Dim IndexSymbol As Integer
        Dim Temp As String
        For IndexSymbol = 1 To TopOfFile(SourceForm, "Symbol")
            Temp = Symbol_TableSymbolName(IndexSymbol)
            ' Finds the first one, not the /name one
            'If SymbolNameToFind <> Temp Then               LogA(2133, SymbolNameToFind, Temp)
            If MyCompared1_a(SymbolNameToFind, Temp) = 0 Then    'GREAT we found a match
                If Symbol_TableCoded_String(IndexSymbol) = "/name" Then
                    logA(1173, IndexSymbol.ToString, SymbolNameToFind, Temp)
                    Return IndexSymbol ' If we find it this way then there is a issues' some where
                Else ' we found a match of the Symbol name, but not the /name record ' report it, and continue on
                    logA(1174, MyShowSymbolGraphic(True, IndexSymbol))
                    If MyOptionTest(25) = True Then
                    Else
                    End If
                    CorrectingIndexes(SourceForm, SymbolNameToFind)
                End If
            Else
                'This is not the symbol we are looking for (Ignore)
            End If
        Next IndexSymbol
        Return ConstantMyErrorCode
    End Function
    ' rewrote 20200711
    'Gets the index in Symbol from just the name (looks it up in named first)
    Friend Function FindInSymbolList(ByRef SourceForm As Source, SymbolNameToFind As String) As Integer 'Gets the index in Symbol from just the name (looks it up in named first)
        Dim Temp As String
        Dim IndexNamed, IndexSymbol, I, J As Integer    'GetMyRecord(lb, ) As String, is always Symbol file name
        ' Cheat first now

        If SymbolNameToFind = "" Then
            ' A I N F O 2  ( 9 0)
            Return ConstantMyErrorCode
        End If

        IndexNamed = BinarySearch4Index(Options.ListBoxSymbols, SymbolNameToFind)
        'If IndexNamed < 1 Then LogDebug(1038,err7," a) **  Symbol name to find at " & IndexNamed & ", " & SymbolNameToFind & vbTab & vbTab & MyShowNamedRecord(True, IndexNamed))

        If IndexNamed <= 0 Then
            IndexNamed = CheckNotInList("named", SymbolNameToFind)
            'If IndexNamed < 1 Then LogDebug(1039,err7," b) **  Symbol name to find at " & IndexNamed & ", " & SymbolNameToFind & vbTab & vbTab & MyShowNamedRecord(True, IndexNamed))
        End If
        'If IndexNamed < 1 Then LogDebug(1040,err7," c) **  Symbol name to find at " & IndexNamed & ", " & SymbolNameToFind & vbTab & vbTab & MyShowNamedRecord(True, IndexNamed))
        'LogDebug(1041,err7," Named index " & IndexNamed.ToString & vbTab & vbTab & SymbolNameToFind)
        If IndexNamed > 0 Then
            IndexSymbol = Named_TableSymbolIndexes(IndexNamed)
            If IndexSymbol <= 0 Then ' We have no cheater/faster Indexes to the name of this Symbol.(We might need to complete re-find all of the Indexes?)
                For I = 1 To TopOfFile(SourceForm, "Symbol")
                    '''''ShowProgressBar(1, I, TopOfFile(SourceForm, "Symbol"))
                    If Symbol_TableSymbolName(I) = SymbolNameToFind Then
                        Named_TableSymbolIndexes(IndexNamed, I)
                        Return I
                    End If
                Next
                'IndexSymbol=CorrectingIndexes(SourceForm   ,   SymbolNameToFind) ' At least fix this Indexes
                ' in the name table, but not in the Symbol table
                Return ConstantMyErrorCode
            Else
                Temp = Symbol_TableSymbolName(IndexSymbol)
                If Len(Temp) = 0 And Len(SymbolNameToFind) <> 0 Then
                    Symbol_TableCode(SourceForm, IndexSymbol, "/Name")
                    Symbol_TableSymbolName(IndexSymbol, SymbolNameToFind)
                End If
                If MyCompared1_a(SymbolNameToFind, Temp) = 0 Then    'GREAT we found a match
                    Return IndexSymbol
                Else ' The Indexes is off again
                    For J = 1 To TopOfFile(SourceForm, "Symbol") + 1
                        If Symbol_TableSymbolName(J) = SymbolNameToFind Then
                            Return J
                        End If
                    Next
                    Return MsgBox("Invalid index to symbol")
                    ' So Do We need to search it again"
                End If
            End If
            ' END OF THE SHORT CUT CHEAT 
        Else
            If IndexNamed < 1 Then LogDebug(1042, Err7, " d) **  Symbol name to find at " & IndexNamed & ", " & SymbolNameToFind & vbTab & vbTab & MyShowNamedRecord(True, IndexNamed))
        End If
        ' Failed above so we have to do this the hard way.
        ' And assume that it is an unsorted list now
        'failed to find it the hard way so it's not there
        ' A I N F O 2 (-92)
        Return ConstantMyErrorCode
    End Function



    Friend Function AddInTable(ByRef LB As ListBox, WhatToFindOrAdd As String) As Integer
        Dim index As Integer

        'AddInTable=IndexPassed
        index = BinarySearch4Index(LB, WhatToFindOrAdd)
        If MyCompared1_a(GetMyRecord(LB, index), WhatToFindOrAdd) = 0 Then
            logA(1270, index.ToString, GetMyRecord(LB, index), WhatToFindOrAdd)
            Return index
        End If

        ' '? Do I need This
        index = TopOfListBox(LB)
        AddInTable = index
        SetMyRecord(LB, index, WhatToFindOrAdd)
        index = index
        CheckThisStringArray(11, LB, index)
    End Function


    'Routine Just gets the size of the circle or path width 
    Friend Function FindMySize(DataTypeName As String, ColorName As String) As Integer
        Dim IndexDataType, IndexColor As Integer

        IndexColor = BinarySearch4Index(Options.ListBoxColors, Trim(ColorName))
        IndexDataType = BinarySearch4Index(Options.ListBoxDataTypes, Trim(DataTypeName))
        If IndexDataType = ConstantMyErrorCode Then
            If IndexColor = ConstantMyErrorCode Then
                Return ConstantMyErrorCode
            Else
                Return MyUniverse.SysGen.Constants.ConstantMinPenSize
            End If
        Else
            ' A I N F O 2  ( 9 6)
            Return MyMinMax(DataType_TableWidth(IndexDataType), MyUniverse.SysGen.Constants.ConstantMinPenSize, MyUniverse.SysGen.Constants.ConstantMaxPenSize)
        End If
        ' A I N F O 2  ( 9 7)
        Return MyUniverse.SysGen.Constants.ConstantMinPenSize
    End Function


    Friend Sub MyDrawBox(ByRef SourceForm As Source, a As MyLineStructure)
        Dim CLR As String
        CLR = RandomColor(SourceForm)
        MyDrawLine(SourceForm, a.a.x, a.a.y, a.a.x, a.b.y, CLR) 'left
        MyDrawLine(SourceForm, a.a.x, a.a.y, a.b.x, a.a.y, CLR) 'top
        MyDrawLine(SourceForm, a.b.x, a.b.y, a.a.x, a.b.y, CLR) 'bottom
        MyDrawLine(SourceForm, a.b.x, a.b.y, a.b.x, a.a.y, CLR) 'right
    End Sub

    Friend Sub MyDrawBox2(ByRef SourceForm As Source, A As MyLineStructure)
        Dim B As MyLineStructure
        B.a.x = 15
        B.a.y = 15
        B.b.x = 50
        B.b.y = 125
        Dim Clr As String
        Clr = RandomColor(SourceForm)
        MyDrawLine(SourceForm, A.a.x + B.a.x, A.a.y + B.a.y, A.a.x + B.a.x, A.b.y - B.b.y, Clr) 'left
        MyDrawLine(SourceForm, A.a.x + B.a.x, A.a.y + B.a.y, A.b.x - B.b.x, A.a.y + B.a.y, Clr) 'top
        MyDrawLine(SourceForm, A.b.x - B.b.x, A.b.y - B.b.y, A.a.x + B.a.x, A.b.y - B.b.y, Clr) 'bottom
        MyDrawLine(SourceForm, A.b.x - B.b.x, A.b.y - B.b.y, A.b.x - B.b.x, A.a.y + B.a.y, Clr) 'right
    End Sub


    Friend Sub MyDrawLineXYXY(ByRef SourceForm As Source, index1 As Integer, index2 As Integer, ColorName As String)
        Dim Centerline As MyLineStructure = Nothing
        Dim X, Y As Integer

        X = CInt((FlowChart_TableX1(SourceForm, index1) + FlowChart_TableX1(SourceForm, index2) + FlowChart_TableX2(SourceForm, index1) + FlowChart_TableX2(SourceForm, index2)) / 4)
        Y = CInt((FlowChart_TableY1(SourceForm, index1) + FlowChart_TableY1(SourceForm, index2) + FlowChart_TableY2(SourceForm, index1) + FlowChart_TableY2(SourceForm, index2)) / 4)
        PanToWorldXY(SourceForm, X, Y)
        PanToWorldXYXY(SourceForm, MyPoint1XY(index1).x, MyPoint1XY(index1).y, MyPoint1XY(index2).x, MyPoint1XY(index2).y)
        MyDrawLine(SourceForm, FlowChart_TableX1(SourceForm, index1), FlowChart_TableY1(SourceForm, index1), FlowChart_TableX2(SourceForm, index1), FlowChart_TableY2(SourceForm, index1), ColorName) 'path 1
        MyDrawLine(SourceForm, FlowChart_TableX1(SourceForm, index2), FlowChart_TableY1(SourceForm, index2), FlowChart_TableX2(SourceForm, index2), FlowChart_TableY2(SourceForm, index2), ColorName) 'path 2

        MyDrawLine(SourceForm, FlowChart_TableX1(SourceForm, index1), FlowChart_TableY1(SourceForm, index1), FlowChart_TableX1(SourceForm, index1), FlowChart_TableY1(SourceForm, index1), ColorName)
        MyDrawLine(SourceForm, FlowChart_TableX1(SourceForm, index1), FlowChart_TableY1(SourceForm, index1), FlowChart_TableX2(SourceForm, index2), FlowChart_TableY2(SourceForm, index2), ColorName)
        MyDrawLine(SourceForm, FlowChart_TableX2(SourceForm, index1), FlowChart_TableY2(SourceForm, index1), FlowChart_TableX1(SourceForm, index2), FlowChart_TableY1(SourceForm, index2), ColorName)
        MyDrawLine(SourceForm, FlowChart_TableX2(SourceForm, index1), FlowChart_TableY2(SourceForm, index1), FlowChart_TableX2(SourceForm, index2), FlowChart_TableY2(SourceForm, index2), ColorName)


        Centerline.a.x = CInt(SourceForm.FlowChartPictureBox.Width / 2) : Centerline.a.y = CInt(SourceForm.FlowChartPictureBox.Height / 2)
        Centerline.a.Named.IsWorldWindow = WorldOrWindow(Centerline.a)

        Centerline.b.x = 0 : Centerline.b.y = 0
        Centerline.b.Named.IsWorldWindow = WorldOrWindow(Centerline.b)
        Centerline.b = Copy2WindowXY(SourceForm, Centerline.b)
        SourceForm.FlowChartPictureBox.CreateGraphics.DrawLine(Pens.LightGreen, Centerline.a.x, Centerline.a.y, Centerline.b.x, Centerline.b.y)

        Centerline.b.Named.IsWorldWindow = WorldOrWindow(Centerline.b)
        Centerline.b.x = FlowChart_TableX1(SourceForm, index1) : Centerline.b.x = FlowChart_TableY1(SourceForm, index1)
        Centerline.b = Copy2WindowXY(SourceForm, Centerline.b)
        SourceForm.FlowChartPictureBox.CreateGraphics.DrawLine(Pens.LightGreen, Centerline.a.x, Centerline.a.y, Centerline.b.x, Centerline.b.y)
        Centerline.b.x = FlowChart_TableX2(SourceForm, index1) : Centerline.b.x = FlowChart_TableY2(SourceForm, index1)
        Centerline.b = Copy2WindowXY(SourceForm, Centerline.b)
        SourceForm.FlowChartPictureBox.CreateGraphics.DrawLine(Pens.LightGreen, Centerline.a.x, Centerline.a.y, Centerline.b.x, Centerline.b.y)
        Centerline.b.x = FlowChart_TableX1(SourceForm, index2) : Centerline.b.x = FlowChart_TableY1(SourceForm, index2)
        Centerline.b = Copy2WindowXY(SourceForm, Centerline.b)
        SourceForm.FlowChartPictureBox.CreateGraphics.DrawLine(Pens.LightGreen, Centerline.a.x, Centerline.a.y, Centerline.b.x, Centerline.b.y)
        Centerline.b.x = FlowChart_TableX2(SourceForm, index2) : Centerline.b.x = FlowChart_TableY2(SourceForm, index2)
        Centerline.b = Copy2WindowXY(SourceForm, Centerline.b)
        SourceForm.FlowChartPictureBox.CreateGraphics.DrawLine(Pens.LightGreen, Centerline.a.x, Centerline.a.y, Centerline.b.x, Centerline.b.y)



        'this draw a light green line to the 0,0 (So when you get lost it will show you the way back to the top
        'todo should limit it to only pan to with in the limits of the current flowchart limits
        SourceForm.FlowChartPictureBox.CreateGraphics.DrawLine(Pens.LightGreen, Centerline.a.x, Centerline.a.y, Centerline.b.x, Centerline.b.y)

    End Sub

    Friend Sub MyDrawLine(ByRef SourceForm As Source, X1 As Integer, Y1 As Integer, X2 As Integer, Y2 As Integer, ColorName As String)
        MyDrawLineXY_XY(SourceForm, MyLine1(SourceForm, X1, Y1, X2, Y2), ColorName)
    End Sub


    Friend Sub MyDrawLineXY_XY(ByRef SourceForm As Source, X1 As Integer, Y1 As Integer, X2 As Integer, Y2 As Integer, ColorName As String)
        MyDrawLineXY_XY(SourceForm, MyLine1(SourceForm, X1, Y1, X2, Y2), ColorName)
    End Sub


    'Routine This is called to draw the inside Symbol Lines 
    Friend Sub MyDrawLineXY_XY(ByRef SourceForm As Source, Xy As MyLineStructure, ColorName As String)
        WW3_My_Draw_Line_Or_Path(SourceForm, Xy, ColorName, 1)
    End Sub


    'This is called to draw the inside Symbol Lines with a width of 1
    Friend Sub MyDrawLineWithIndex(ByRef SourceForm As Source, IndexSymbol As Integer, XYOffSet As MyPointStructure, RotationName As String)
        Dim MyLine As MyLineStructure
        Dim MyColor As String
        '' Cheat and use the path to draw the Line
        If FMBRecurse("MyDrawLineWithIndex") > 2 Then Return
        MyLine = MyLine1(SourceForm, MyRotated_1(IndexSymbol, XYOffSet, RotationName), MyRotated_2d(IndexSymbol, XYOffSet, RotationName))
        MyLine.a.Named.PointName = Symbol_Table_NameOfPoint(IndexSymbol)
        MyLine.b.Named.PointName = Symbol_Table_NameOfPoint(IndexSymbol)
        If Symbol_TableCoded_String(IndexSymbol) = "/Line" Then
            MyColor = Symbol_Table_LineColor(IndexSymbol)
        Else
            MyColor = FindColorFromDataType(Symbol_Table_DataType(IndexSymbol))
        End If
        If Len(MyColor) < 1 Then
            If Symbol_TableCoded_String(IndexSymbol) = "/Line" Then
                Symbol_Table_LineColor(IndexSymbol, "Black")
            Else
                Symbol_Table_DataType(IndexSymbol, "Errored")
            End If
            logA(2694, MyShowSymbolGraphic(True, IndexSymbol))
            If MyOptionTest(25) = True Then
                MyColor = "Black"
            Else
                MyColor = "Black"
            End If
        End If
        WW3_My_Draw_Line_Or_Path(SourceForm, MyLine, MyColor, 1)
    End Sub



    'Routine This is used to draw the paths between the Symbol points (with a min width of 3
    Friend Sub MyDrawRouter(ByRef SourceForm As Source, Index As Integer)
        Dim XY As MyLineStructure = Nothing
        Dim X As String
        Dim X1, Y1, X2, Y2 As String
        Dim Name, DataType As String
        X = GetMyRecord(SourceForm.ListBoxFlowChart, Index)
        Name = Parse(X, ",", "") : X = DropParse(X, ",", "")
        X1 = Parse(X, ",", "") : X = DropParse(X, ",", "")
        Y1 = Parse(X, ",", "") : X = DropParse(X, ",", "")
        X2 = Parse(X, ",", "") : X = DropParse(X, ",", "")
        Y2 = Parse(X, ",", "") : X = DropParse(X, ",", "")
        DataType = Parse(X, ",", "") : X = DropParse(X, ",", "")
        XY.a.x = CInt(X1)
        XY.a.y = CInt(Y1)
        XY.b.x = CInt(X2)
        XY.b.y = CInt(Y2)
        MyDrawWorldPath(SourceForm, XY, FlowChart_TableDataType(SourceForm, Index))
    End Sub



    Friend Function FindNetName(PathName As String) As Integer
        Dim IndexNet As Integer
        'todo Find this Net Name
        For IndexNet = LBound(Net_FilePathNames) To MySizeOf(Net_FilePathNames)
            If PathName = Net_FilePathNames(IndexNet) Then
                Return IndexNet
            End If
        Next IndexNet
        Return ConstantMyErrorCode
    End Function


    Friend Function MyDrawAll(ByRef SourceForm As Source, X As Integer, Y As Integer) As String
        ' This needs to find and display everything here
        Dim I As Integer
        MyDrawAll = COMMA & MyShowPoint(X, Y) & COMMA
        For I = 1 To TopOfListBox(SourceForm.ListBoxFlowChart)
            '''''ShowProgressBar(1, I, TopOfFile(SourceForm, "Symbol"))
            If FlowChart_TableCode(SourceForm, I) = "/Path" Then
                If FlowChart_TableX1(SourceForm, I) = X And FlowChart_TableY1(SourceForm, I) = Y Then
                    MyDrawAll &= COMMA & I & COMMA
                    MyDrawRouter(SourceForm, I)
                End If
                If FlowChart_TableX2(SourceForm, I) = X And FlowChart_TableY2(SourceForm, I) = Y Then
                    MyDrawAll &= COMMA & I & COMMA
                    MyDrawRouter(SourceForm, I)
                End If
            End If
        Next
    End Function
    Friend Sub MyDrawAllPaths(ByRef SourceForm As Source, IndexNet As Integer)
        Dim X, Y As String
        Dim IndexFlowChart As Integer
        Dim IDEX As Integer
        If MyOptionTest(34) Then Return
        X = Net_TableLinks(IndexNet)
        If Len(X) < 64 Then
            While Len(X) > 0
                IndexFlowChart = PopFirstValue(X)
                MyDrawLineS_PathS(SourceForm, IndexFlowChart)
                Y = Net_TableLinks(IndexNet)
                While Len(Y) > 0
                    IDEX = PopFirstValue(Y)
                    If IDEX <> IndexFlowChart Then
                        MyDrawPathsPossible(SourceForm, FlowChart2Line(SourceForm, IndexFlowChart), FlowChart2Line(SourceForm, IDEX))
                    End If
                End While
            End While
        End If
    End Sub


    Friend Sub MyDrawPath(ByRef SourceForm As Source, IndexFlowchart As Integer)
        If FlowChart_TableCode(SourceForm, IndexFlowchart) <> "/Path" Then Return
        MyDrawWorldPath(SourceForm, FlowChart2Line(SourceForm, IndexFlowchart), RandomColor(SourceForm))
    End Sub

    Friend Sub MyDrawWorldPath(ByRef SourceForm As Source, XY As MyLineStructure, DataTypeName As String)
        Dim Temp As MyLineStructure
        If XY.a.x = 0 Then
            If XY.a.y = 0 Then
                If XY.b.x = 0 Then
                    If XY.b.y = 0 Then Return
                End If
            End If
        End If
        If XY.a.x = 0 Or XY.a.y = 0 Or XY.b.x = 0 Or XY.b.y = 0 Then
            Temp.a = Copy2WindowXY(SourceForm, XY.a)
            Temp.b = Copy2WindowXY(SourceForm, XY.b)
            MyDrawWindowPath(SourceForm, Temp, "RED")
            Return
        End If
        Temp.a = Copy2WindowXY(SourceForm, XY.a)
        Temp.b = Copy2WindowXY(SourceForm, XY.b)
        MyDrawWindowPath(SourceForm, Temp, FindColorFromDataType(DataTypeName))
        'todo draw all of the paths that are connected to here (both ends)

    End Sub


    Friend Sub MyDrawWindowPath(ByRef SourceForm As Source, XY As MyLineStructure, Color_Name As String)
        Dim IndexDataTypeOrColor As Integer = -1
        Dim Width As Integer
        If XY.a.x = 0 And XY.a.y = 0 And XY.b.x = 0 And XY.b.y = 0 Then Return

        If Color_Name = "" Then
            Color_Name = RandomColor(SourceForm)
        End If
        If XY.a.x = XY.b.x Or XY.a.y = XY.b.y Then
            WW3_My_Draw_Line_Or_Path(SourceForm, XY, Color_Name, 1)
        Else
            WW3_My_Draw_Line_Or_Path(SourceForm, XY, Color_Name, 1)
        End If
        '
        If Width <= 1 Then
            Width = 12
        End If
        WW3_My_Draw_Line_Or_Path(SourceForm, XY, Color_Name, Width)
    End Sub 'end of MyDrawWindowPath()


    Friend Function InsertFlowChartRecord(ByRef SourceForm As Source, SymbolName As String, CodedString As String, xy1 As MyPointStructure, xy2 As MyPointStructure, DataType_Color As String) As Integer
        Dim IndexFlowChart As Integer
        IndexFlowChart = NewFlowChartRecord(SourceForm)
        FlowChart_TableCode(SourceForm, IndexFlowChart, MyKeyword2Number(CodedString).ToString)
        FlowChart_tablePathSymbolName(SourceForm, IndexFlowChart, SymbolName)
        FlowChart_TableDataType(SourceForm, IndexFlowChart, DataType_Color)
        FlowChart_TableX1(SourceForm, IndexFlowChart, xy1.x)
        FlowChart_TableY1(SourceForm, IndexFlowChart, xy1.y)
        FlowChart_TableX2(SourceForm, IndexFlowChart, xy2.x)
        FlowChart_TableY2(SourceForm, IndexFlowChart, xy2.y)
        InsertFlowChartRecord = IndexFlowChart
        '''''ShowSorts("FlowChart", SortFlowChart())
        PaintAll(SourceForm, IndexFlowChart - 1, IndexFlowChart + 1)
        PaintAll(SourceForm, TopOfListBox(SourceForm.ListBoxFlowChart) - 3, TopOfListBox(SourceForm.ListBoxFlowChart) + 1)
    End Function


    'need to make sure that this error message is not already in the list.
    Friend Sub MakeErrorAt(ByRef SourceForm As Source, myXY As MyPointStructure, ErrorMessage As String)
        Dim LocalIndex As Integer
        Dim IndexSymbol As Integer
        Select Case LCase(SourceForm.Parent.Name)
            Case "FlowChartWindow"
                ' Need to find the closest if this error is already in the FlowChart file, other wise it will go on forever building errors
                For LocalIndex = 1 To TopOfListBox(SourceForm.ListBoxFlowChart)
                    If FlowChart_TableCode(SourceForm, LocalIndex) = "/error" Then ' only check errors
                        If myXY.x = FlowChart_TableX1(SourceForm, LocalIndex) Then
                            If myXY.y = FlowChart_TableY1(SourceForm, LocalIndex) Then
                                ' Do not put errors on top of the same errors
                                If ErrorMessage = FlowChart_TableSymbol_Name(SourceForm, LocalIndex) Then
                                    Return ' not at the same message?
                                End If
                            End If
                        End If
                    End If
                Next
                InsertFlowChartRecord(SourceForm, ErrorMessage, "/error", myXY, MyUniverse.MyStaticData.ZeroZero, RandomColor(SourceForm)) ' color??
            Case "SymbolWindow"
                If MyUniverse.ProgramOptions.SelectedSymbolName <> "" Then ' Only do it if there is a selected Symbol
                    LocalIndex = FindInSymbolList(SourceForm, MyUniverse.ProgramOptions.SelectedSymbolName)
                    IndexSymbol = LocalIndex + 1
                    While IndexSymbol <= TopOfFile(SourceForm, "Symbol") And Symbol_TableCoded_String(IndexSymbol) <> "/name"
                        If Symbol_TableCoded_String(IndexSymbol) = "/error" Then
                            If myXY.x = Symbol_FileX1(IndexSymbol) Then
                                If myXY.y = Symbol_FileY1(IndexSymbol) Then
                                    Return ' It is already in the Symbol
                                End If
                            End If
                        End If
                        IndexSymbol += 1
                    End While
                    'Will insert multiply of this right now
                    InsertSymbolLineRecord(SourceForm, LocalIndex, MyLine1(SourceForm, myXY.x, myXY.y, 0, 0), MyUniverse.ProgramOptions.SelectedSymbolName, "/error", ErrorMessage)
                    logA(1188, LocalIndex.ToString, MyUniverse.ProgramOptions.SelectedSymbolName, MyShowSymbolGraphic(False, LocalIndex), ErrorMessage)
                    If MyOptionTest(25) = True Then
                    Else
                    End If
                End If
            Case Else
                logA(2066, SourceForm.Parent.Name)
        End Select

    End Sub


    'Routine This draws all text on the Window
    Friend Sub MyDrawText(ByRef SourceForm As Source, xy As MyPointStructure, MyString As String, BrushOptionNumber As Integer)
        Const debugLevel As Integer = A_STATUS
        Dim XY1 As Point
        Dim MyFonts As Font
        Dim MyPenDrawer As Brush
        Dim XYXY As Rectangle
        Dim MyBrush As Brush
        Dim MyColor As Color
        Dim A, R, G, B As Integer
        Dim IndexColor As Integer

        If Len(MyString) = 0 Then Return
        If MyOptionTest(BrushOptionNumber) = False Then Return
        If ProgramBuzzy("Begin") = True Then Return

        If InSideMyFlowChartWindow(SourceForm, xy.x, xy.y) = False Then Return 'not printable, so why print it?

        XY1 = MyPointStruct2Point(Copy2WindowXY(SourceForm, xy))
        MyFonts = SystemFonts.DefaultFont


        'todo ned to be able to set another size for the text (lok into aq definition for each of the fonts.)
        If MyUniverse.MyMouseAndDrawing.PaintThisOrEraseThis = False Then
            MyPenDrawer = Brushes.White 'Brushes.White
        Else '''''
            MyPenDrawer = Brushes.Black 'GetBrush(MyUniverse.OptionDisplay(BrushOptionNumber).ColorName)
        End If
        XYXY.X = XY1.X
        XYXY.Y = XY1.Y
        XYXY.Height = MyUniverse.OptionDisplay(BrushOptionNumber).TextWidth
        XYXY.Width = MyUniverse.OptionDisplay(BrushOptionNumber).TextHeight

        If MyDebug(debugLevel) Then logA(2709, MyString, MyShowPoint(XYXY.X, XYXY.Y))
        IndexColor = FindColorIndexFromName(MyUniverse.OptionDisplay(BrushOptionNumber).ColorName)
        A = CByte(Color_TableAlpha(IndexColor))
        R = CByte(Color_TableRed(IndexColor))
        G = CByte(Color_TableGreen(IndexColor))
        B = CByte(Color_TableBlue(IndexColor))
        MyColor = Color.FromArgb(A, R, G, B)

        MyBrush = New Drawing.SolidBrush(MyColor)
        If MyOptionTest(BrushOptionNumber) = True Then
            If MyDebug(debugLevel) Then logA(1285, MyString, MyShowRectangle(XYXY))
            If MyOptionTest(33) = True Then
                SourceForm.FlowChartPictureBox.CreateGraphics.DrawString(BrushOptionNumber.ToString & " : " & MyString, MyFonts, MyPenDrawer, XYXY)
            Else
                If XYXY.Y > 0 Then
                    SourceForm.FlowChartPictureBox.CreateGraphics.DrawString(MyString, MyFonts, MyPenDrawer, XYXY)
                Else
                    'Where.CreateGraphics.DrawString(MyString, MyFonts, MyPenDrawer, XYXY)
                End If
            End If
        Else
            If MyDebug(debugLevel) Then logA(1294, MyShowRectangle(XYXY), MyString)
            SourceForm.FlowChartPictureBox.CreateGraphics.DrawString(MyString, MyFonts, MyPenDrawer, XYXY)
        End If
        MyBrush.Dispose()
    End Sub



    Friend Sub MyDrawBigText(ByRef SourceForm As Source, xy As MyPointStructure, MyString As String)
        Const debugLevel As Integer = A_STATUS
        Dim XY1 As Point
        Dim MyFonts As Font
        Dim MyPenDrawer As Brush
        Dim XYXY As Rectangle
        Dim MyBrush As Brush
        Dim MyColor As Color
        Dim A, R, G, B As Integer
        Dim IndexColor As Integer
        Dim X As Single

        If Len(MyString) = 0 Then Return
        If MyOptionTest(59) = False Then Return
        If ProgramBuzzy("Begin") = True Then Return

        XY1 = MyPointStruct2Point(Copy2WindowXY(SourceForm, xy))
        X = SystemFonts.DefaultFont.Size
        MyFonts = SystemFonts.DefaultFont

        'todo ned to be able to set another size for the text (lok into aq definition for each of the fonts.)
        If MyUniverse.MyMouseAndDrawing.PaintThisOrEraseThis = False Then
            MyPenDrawer = Brushes.White 'Brushes.White
        Else
            MyPenDrawer = Brushes.Black '''''GetBrush(MyUniverse.OptionDisplay(59).ColorName)
        End If
        XYXY.X = XY1.X
        XYXY.Y = XY1.Y
        XYXY.Height = MyUniverse.OptionDisplay(59).TextWidth
        XYXY.Width = MyUniverse.OptionDisplay(59).TextHeight
        If MyDebug(debugLevel) Then logA(2709, MyString, MyShowPoint(XYXY.X, XYXY.Y))
        IndexColor = FindColorIndexFromName(MyUniverse.OptionDisplay(59).ColorName)
        A = CByte(Color_TableAlpha(IndexColor))
        R = CByte(Color_TableRed(IndexColor))
        G = CByte(Color_TableGreen(IndexColor))
        B = CByte(Color_TableBlue(IndexColor))
        MyColor = Color.FromArgb(A, R, G, B)

        MyBrush = New Drawing.SolidBrush(MyColor)
        If MyOptionTest(59) = True Then
            If MyDebug(debugLevel) Then logA(1285, MyString, MyShowRectangle(XYXY))
            If MyOptionTest(33) = True Then
                SourceForm.FlowChartPictureBox.CreateGraphics.DrawString(59.ToString & " : " & MyString, MyFonts, MyPenDrawer, XYXY)
            Else
                SourceForm.FlowChartPictureBox.CreateGraphics.DrawString(MyString, MyFonts, MyPenDrawer, XYXY)
            End If
        Else
            If MyDebug(debugLevel) Then logA(1295, MyShowRectangle(XYXY), MyString)
            SourceForm.FlowChartPictureBox.CreateGraphics.DrawString(MyString, MyFonts, MyPenDrawer, XYXY)
        End If
        MyFonts.Dispose()
        MyBrush.Dispose()
    End Sub




    'Routine This is the actual routine that write out text , called by everything else

    Friend Sub MyDrawLineS_PathS(ByRef SourceForm As Source, IndexFlowChart As Integer)
        Dim MyLine As MyLineStructure
        Dim MyColor As String
        Dim MyWidth As Integer
        MyLine = MyLine1(SourceForm, MyPoint1XY(FlowChart_TableX1(SourceForm, IndexFlowChart), FlowChart_TableY1(SourceForm, IndexFlowChart)),
    MyPoint2XY(FlowChart_TableX2(SourceForm, IndexFlowChart), FlowChart_TableY2(SourceForm, IndexFlowChart)))
        MyColor = FindColorFromDataType(FlowChart_TableDataType(SourceForm, IndexFlowChart))
        If Len(MyColor) < 1 Then
            MyColor = RandomColor(SourceForm)
        End If

        MyWidth = FindWidthFromDataType(SourceForm, FlowChart_TableDataType(SourceForm, IndexFlowChart))
        MyWidth = MyMinMax(MyWidth, 4, 40) 'todo this should be less than the point snap - not 40
        WW3_My_Draw_Line_Or_Path(SourceForm, MyLine, MyColor, MyWidth)
    End Sub


    Friend Sub WW3(ByRef SourceForm As Source, p1 As MyPointStructure, p2 As MyPointStructure, p3 As MyPointStructure, CLR As String)
        WW3_My_Draw_Line_Or_Path(SourceForm, MyLine1(SourceForm, p1, p2), CLR, 8)
        WW3_My_Draw_Line_Or_Path(SourceForm, MyLine1(SourceForm, p1, p3), RandomColor(SourceForm), 8)
        WW3_My_Draw_Line_Or_Path(SourceForm, MyLine1(SourceForm, p2, p3), CLR, 8)
    End Sub

    'color name is not being passed
    Friend Sub WW3_My_Draw_Line_Or_Path(ByRef SourceForm As Source, ByRef XY As MyLineStructure, ColorName As String, Width As Integer)
        Const debugLevel As Integer = A_STATUS
        Dim XY_a, XY_b As Point
        Dim My_Pen As Pen
        Dim indexColor As Integer
        If XY.a.x = 0 And XY.a.y = 0 And XY.b.x = 0 And XY.b.y = 0 Then Return
        'If InSideMyFlowChartWindow( SourceForm  ,XY)=False Then Return 'not printable, so why print it?
        If MyShowNames(XY) = "" Then
            XY.a.Named.PointName = "NoName" & MyRandom(4)
            XY.b.Named.PointName = "NoName" & MyRandom(4)
        End If
        If ProgramBuzzy("begin") Then Return
        If Len(ColorName) = 0 Then
            logA(1193, SourceForm.Parent.Name, MyShowALine(XY), Width.ToString)
            My_Pen = Pens.Black
            ColorName = MyUniverse.ProgramOptions.SelectedColor
        Else
            My_Pen = MyGetPen(SourceForm, ColorName, "")
        End If

        Select Case WorldOrWindow(XY.a) & WorldOrWindow(XY.b)
            Case "WORLDWORLD"
                XY_a = MyPointStruct2Point(Copy2WindowXY(SourceForm, XY.a))
                XY_b = MyPointStruct2Point(Copy2WindowXY(SourceForm, XY.b))
            Case "WORLDWINDOW"
                XY_a = MyPointStruct2Point(Copy2WindowXY(SourceForm, XY.a))
                XY_b = MyPointStruct2Point(XY.b)
            Case "WINDOWWORLD"
                XY_a = MyPointStruct2Point(XY.a)
                XY_b = MyPointStruct2Point(Copy2WindowXY(SourceForm, XY.b))
            Case "WINDOWWINDOW"
                XY_a = MyPointStruct2Point(XY.a)
                XY_b = MyPointStruct2Point(XY.b)
            Case Else
                XY_a = MyPointStruct2Point(XY.a)
                XY_b = MyPointStruct2Point(XY.b)
        End Select
        If MyDebug(debugLevel) Then
            logA(1709, MyShowPoints(SourceForm, XY_a.X, XY_a.Y, XY_b.X, XY_b.Y), ColorName, Width.ToString)
        End If
        If IsHex(My_Pen.Color.Name) Then My_Pen.Width = MyMinMax(Width, 1, 48) 'todo this was 1 not 4 min
        If MyOptionTest(34) Then
            If XY_a.X = XY_b.X And XY_a.Y = XY_b.Y Then
            Else
                SourceForm.FlowChartPictureBox.CreateGraphics.DrawLine(My_Pen, XY_a, XY_b)
            End If
        End If
        If My_Pen.Width > 1 Then ' Then This is a path
            indexColor = BinarySearch4Index(Options.ListBoxColors, ColorName)
            'todo these were drawing at the wrong place
            If indexColor > 0 Then
                QuickDrawLine(SourceForm, XY_a.X, XY_a.Y, XY_b.X, XY_b.Y, Pens.Red) 'My_Pen)
                MyDrawWindowCircle(SourceForm.FlowChartPictureBox, Point2MyPointStruct(XY_a), Color_TableName(indexColor), "")
                MyDrawWindowCircle(SourceForm.FlowChartPictureBox, Point2MyPointStruct(XY_b), Color_TableName(indexColor), "")
            Else
                QuickDrawLine(SourceForm, XY_a.X, XY_a.Y, XY_b.X, XY_b.Y, Pens.Green) 'My_Pen)
            End If
        End If
        If IsHex(My_Pen.Color.Name) Then
            'can only dispose hex named pens
            My_Pen.Dispose()
            Return
        End If
        Return
    End Sub 'WW3_My_Draw_Line_Or_Path







    Friend Function MyDistancePath(XY1 As MyLineStructure, XY2 As MyLineStructure) As Integer 'Find The Distance From XY1  to XY2
        Dim T1, T2, T3, T4 As Integer
        T1 = MyABS(XY1.a.x - XY2.a.x) + MyABS(XY1.a.y - XY2.a.y) '1A to 2A
        T2 = MyABS(XY1.b.x - XY2.a.x) + MyABS(XY1.b.y - XY2.a.y) '1B to 2A
        T3 = MyABS(XY1.a.x - XY2.b.x) + MyABS(XY1.a.y - XY2.b.y) '1A to 2B
        T4 = MyABS(XY1.b.x - XY2.b.x) + MyABS(XY1.b.y - XY2.b.y) '1b to 2B
        MyDistancePath = MyMin(T1, T2) ' Between t1 & t2
        MyDistancePath = MyMin(MyDistancePath, T3) ' Between t1 & t2
        MyDistancePath = MyMin(MyDistancePath, T4) ' Between t1 & t2
        If MyDebug(A_DISPLAY) Then
            logA(1196,
                        MyShowLineXYXY(XY1.a.x, XY1.a.y, XY1.b.x, XY1.b.y),
                        MyShowLineXYXY(XY2.a.x, XY2.a.y, XY2.b.x, XY2.b.y),
                        T1.ToString & ":" & T2.ToString & ":" & T3.ToString & ":" & T4.ToString)
        End If
    End Function



    'routine to see the distance between two points (OK, so I didn't square amounts and take the root
    Friend Function MyDistance(A As MyPointStructure, B As MyPointStructure) As Integer
        'MyDistance = MyABS(A.x - B.x) + MyABS(A.y - B.y)' since we only want to compare distance
        MyDistance = CInt(Math.Sqrt(MyABS(A.x - B.x) ^ 2 + MyABS(A.y - B.y) ^ 2))
        logA(4166, MyDistance.ToString)
    End Function


    'Routine This routine returns a 16 unit clock of the direction of the second point from the first point
    Friend Function MyDirection(XY1 As MyPointStructure, XY2 As MyPointStructure) As Integer
        Dim dX, dY As Integer
        ' This should return the following 'clock' of the direction of the second from the centered first points
        'TDistant=myUniverse.SysGen.Constants.ConstantSymbolCenter * 2
        '14 15 16 01 02
        '13 /  |   / 03
        '12 ---0-----04
        '11 /  |   / 05
        '10 09 08 07 06
        '

        'Just to make it simple
        dX = XY2.x - XY1.x
        dY = XY2.y - XY1.y

        If dX = 0 And dY = 0 Then ' on top of each other
            Return 0
        End If

        If dX = 0 Then
            If dY < 0 Then
                Return 16
            Else
                Return 8
            End If
        End If

        If dY = 0 Then
            If dX > 0 Then
                Return 4
            Else
                Return 12
            End If
        End If


        If dX > 0 Then '1-7
            If dY > 0 Then '1, 2, 3
                If MyABS(dX) = MyABS(dY) Then
                    Return 6
                End If
                If MyABS(dX) > MyABS(dY) Then
                    Return 5
                Else
                    Return 7
                End If
            Else '5, 6, 7
                If MyABS(dX) = MyABS(dY) Then
                    Return 2
                End If
                If MyABS(dX) > MyABS(dY) Then
                    Return 3
                Else
                    Return 1
                End If
            End If
        Else ' dx <08-15
            If dY > 0 Then '13, 14, 15
                If MyABS(dX) = MyABS(dY) Then
                    Return 10
                End If
                If MyABS(dX) > MyABS(dY) Then
                    Return 11
                Else
                    Return 9
                End If
            Else    '9, 10, 11
                If MyABS(dX) = MyABS(dY) Then
                    Return 14
                End If
                If MyABS(dX) > MyABS(dY) Then
                    Return 13
                Else
                    Return 15
                End If
            End If
        End If
        Return 0
        ' For now only returning up
    End Function




    'Routine This draws the Input-Output arrows at each point
    Friend Sub MyDrawPointArrow(ByRef SourceForm As Source, CenterXY As MyPointStructure, ArrowXY As MyPointStructure, DataTypeName As String, InputOrOutPut As Integer)
        Dim MyArrow As ThisArrow

        ReDim MyArrow.IO_SizeModifier(16)

        'todo This is bombing out string to integer
        MyArrow.Temp = MyUnEnum(InputOrOutPut, Options.ListBoxInputOutput, 1)
        MyArrow.Input_Output_Both_Direction = PopValue(MyArrow.Temp)
        'This changes the size based on the direction of the arrow.

        MyArrow.IO_SizeModifier(0) = 20
        MyArrow.IO_SizeModifier(1) = 6    'input
        MyArrow.IO_SizeModifier(2) = -6    'Output
        MyArrow.IO_SizeModifier(3) = 8    'both
        MyArrow.IO_SizeModifier(4) = 7    'OptionalInput
        MyArrow.IO_SizeModifier(5) = -4    'optional Output
        MyArrow.IO_SizeModifier(6) = 4   'optional both
        MyArrow.IO_SizeModifier(7) = 2    ' anything else
        MyArrow.IO_SizeModifier(8) = 4    ' anything else
        MyArrow.IO_SizeModifier(9) = 6 'Future
        MyArrow.IO_SizeModifier(10) = 8 'Future
        MyArrow.IO_SizeModifier(11) = 10 'Future
        MyArrow.IO_SizeModifier(12) = 12 'Future
        MyArrow.IO_SizeModifier(13) = 14 'Future
        MyArrow.IO_SizeModifier(14) = 16 'Future
        MyArrow.IO_SizeModifier(15) = 18 'Future
        MyArrow.IO_SizeModifier(16) = 20 'Future

        MyArrow.ArrowFactor = 1
        If Len(DataTypeName) = 0 Then
            logA(1200, DataTypeName)
            If MyOptionTest(25) = True Then
            Else
            End If
            DataTypeName = "Errored"
        End If
        MyArrow.IndexDataType = BinarySearch4Index(Options.ListBoxDataTypes, DataTypeName) ' Add this DataType 
        If MyArrow.IndexDataType = ConstantMyErrorCode Then
            logA(1201, MyArrow.IndexDataType.ToString, DataTypeName)
            If MyOptionTest(25) = True Then
            Else
            End If
            'todo need to catch where this DataType is not being set when adding points to the Symbol
            MyArrow.ColorName = Color_TableName(FindColorIndexFromName("Black"))
        Else
            MyArrow.ColorName = Color_TableName(DataType_TableColorIndex(MyArrow.IndexDataType))
        End If
        '           ' Make sure we are not over flowing the MyArrays'
        MyArrow.ColorName = FindColorFromDataType(DataType_TableName(MyArrow.IndexDataType))
        '    myArrow.ColorName=DataType_TableColor(myArrow.IndexDataType)

        If MyIsNothing(MyArrow.ColorName) Then 'We get here when a new DataType name was added
            If MyIsNothing(DataType_TableColorIndex(MyArrow.IndexDataType).ToString) Then
                DataType_TableColorIndex(MyArrow.IndexDataType, BinarySearch4Index(Options.ListBoxColors, "Red"))
            End If
            MyArrow.ColorName = "Red"
        End If
        MyArrow.TempPenWidthSize = 1 'MyMinMax(FindMySize( SourceForm.FlowChartPictureBox  , Trim(DataTypeName)), 1, 550) ' Already set between 10 and 250 


        ' Get this pen color
        MyArrow.MinePen = MyGetPen(SourceForm, Trim(MyArrow.ColorName), "")
        'myArrow.MinePen.Width=MyMinMax(ScaledSize(myArrow.TempPenWidthSize), 1, 250) '?
        If ScaledSize(MyArrow.TempPenWidthSize) < 1 Then
            'todo need to make a disposable pen before each .draw ... () and fill it in with the rbg,size,color etc (and get rid of the MicroSoft dependent color names)
            ' myArrow.MinePen.Width=1
        ElseIf ScaledSize(MyArrow.TempPenWidthSize) > 250 Then
            MyArrow.MinePen.Width = 250
        Else
            'flow10 'myArrow.MinePen.Width=10 'myArrow.TempPenWidthSize
        End If
        '    MyXYCenter.X=MyUniverse.SysGen.Constants.ConstantSymbolCenter
        '   MyXYCenter.Y=MyUniverse.SysGen.Constants.ConstantSymbolCenter

        MyArrow.DirectionIs = MyDirection(MyUniverse.MyStaticData.ZeroZero, ArrowXY)


        Select Case LCase(SourceForm.FlowChartPictureBox.Parent.Name)
            Case "SymbolWindow"
                MyArrow.MyXY1 = CenterXY      'Save the center of where we should show
                MyArrow.MyXY1.y -= MyUniverse.OptionDisplay(10).x ' Display Input-Output text
                MyDrawText(SourceForm, MyArrow.MyXY1, Options.ListBoxInputOutput.Items.Item(MyMinMax(MyArrow.IO_SizeModifier(MyArrow.DirectionIs), 1, Options.ListBoxInputOutput.Items.Count - 1)).ToString, 10)
            Case "FlowChartWindow"
                ' For Direction, for the second part of the Line
                MyArrow.MyXY1 = CenterXY
                MyArrow.MyXY2 = CenterXY 'Save the center of where we should show
                MyArrow.MyXY2.x += CInt(MyDirections(MyArrow.DirectionIs, 1, 1) * MyArrow.TempPenWidthSize * MyArrow.IO_SizeModifier(MyMinMax(MyArrow.IO_SizeModifier(MyArrow.DirectionIs), 1, 8)) * MyArrow.ArrowFactor)
                MyArrow.MyXY2.y += CInt(MyDirections(MyArrow.DirectionIs, 1, 2) * MyArrow.TempPenWidthSize * MyArrow.IO_SizeModifier(MyMinMax(MyArrow.IO_SizeModifier(MyArrow.DirectionIs), 1, 8)) * MyArrow.ArrowFactor)
                MyArrow.XY1 = Copy2WindowXY(SourceForm, MyArrow.MyXY1) : MyArrow.XY2 = Copy2WindowXY(SourceForm, MyArrow.MyXY2)
                SourceForm.FlowChartPictureBox.CreateGraphics.DrawLine(MyArrow.MinePen, MyPointStruct2Point(MyArrow.XY1), MyPointStruct2Point(MyArrow.XY2))

                MyArrow.MyXY1 = CenterXY
                MyArrow.MyXY2 = CenterXY 'Save the center of where we should show

                MyArrow.MyXY2.x += CInt(MyDirections(MyArrow.DirectionIs, 2, 1) * MyArrow.TempPenWidthSize * MyArrow.IO_SizeModifier(MyMinMax(MyArrow.IO_SizeModifier(MyArrow.DirectionIs), 1, 8)) * MyArrow.ArrowFactor)
                MyArrow.MyXY2.y += CInt(MyDirections(MyArrow.DirectionIs, 2, 2) * MyArrow.TempPenWidthSize * MyArrow.IO_SizeModifier(MyMinMax(MyArrow.IO_SizeModifier(MyArrow.DirectionIs), 1, 8)) * MyArrow.ArrowFactor)
                MyArrow.XY1 = Copy2WindowXY(SourceForm, MyArrow.MyXY1) : MyArrow.XY2 = Copy2WindowXY(SourceForm, MyArrow.MyXY2)
                SourceForm.FlowChartPictureBox.CreateGraphics.DrawLine(MyArrow.MinePen, MyPointStruct2Point(MyArrow.XY1), MyPointStruct2Point(MyArrow.XY2)) ' Second part of the Indexes (v, or ^ or < or > )
            Case Else
                logA(2066, SourceForm.FlowChartPictureBox.Parent.Name)
        End Select
    End Sub





    'Routine The draws a circle where each point is
    Friend Sub MyDrawWindowCircle(ByRef SourceForm As Source, XY1 As MyPointStructure, MyColorName As String, DataTypeName As String)
        Dim MyRec As Rectangle
        Dim TempSize As Integer
        Dim WindowPoint As MyPointStructure
        Dim IndexColor As Integer
        Dim IndexDataType As Integer
        Dim MinePen As Pen
        Dim ColorNameIs As String

        If XY1.x = 0 And XY1.y = 0 Then Return

        ColorNameIs = MyColorName

        If MyIsNothing(ColorNameIs) Then
            ColorNameIs = RandomColor(SourceForm)
        ElseIf ColorNameIs = "" Then
            ColorNameIs = RandomColor(SourceForm)
        Else
            If BinarySearch4Index(Options.ListBoxColors, ColorNameIs) = ConstantMyErrorCode Then
                ColorNameIs = "Black"
            End If
        End If
        IndexColor = BinarySearch4Index(Options.ListBoxColors, ColorNameIs)
        If IndexColor = ConstantMyErrorCode And IndexDataType = ConstantMyErrorCode Then
            logA(1203, ColorNameIs, DataTypeName, MyShowPoint(XY1))
        End If


        If IndexColor < 0 Then
            IndexDataType = FindDataTypeIndex(DataTypeName)
            If IndexDataType > 0 Then 'if no color name but DataType name then use the color of that DataType
                IndexColor = DataType_TableColorIndex(IndexDataType)
                If IndexColor > 0 Then 'if color in DataType table is valid then use it
                    ColorNameIs = Color_TableName(IndexColor)
                Else 'if the DataType has an invalid color then make it red
                    ColorNameIs = RandomColor(SourceForm)
                End If
            Else ' both are invalid, so just use green
                ColorNameIs = RandomColor(SourceForm)
            End If
        ElseIf IndexColor > 0 Then
            'TempSize=2
            ColorNameIs = MyColorName
            '?IndexDataType=ConstantMyErrorCode
        End If

        TempSize = FindMySize(DataTypeName, ColorNameIs) 'size is only valid for DataTypes
        MinePen = MyGetPen(SourceForm, ColorNameIs, "")

        WindowPoint = XY1
        MyRec.X = WindowPoint.x - CInt(TempSize / 2)
        MyRec.Y = WindowPoint.y - CInt(TempSize / 2)
        MyRec.Width = TempSize
        MyRec.Height = TempSize
        MinePen.Width = CInt(TempSize / 2) 'todo test this 'bug?
        SourceForm.FlowChartPictureBox.CreateGraphics.DrawEllipse(MinePen, MyRec)

        If IsHex(MinePen.Color.Name) Then                'can only dispose hex named pens
            MinePen.Dispose()
            Return
        End If
    End Sub








    'Routine The draws a circle where each point is
    Friend Sub MyDrawWorldCircle(ByRef SourceForm As Source, XY1 As MyPointStructure, MyColorName As String) ', DataTypeName As String)
        Dim MyRec As Rectangle
        Dim TempSize As Integer
        Dim WindowPoint As MyPointStructure
        Dim IndexColor As Integer
        Dim IndexDataType As Integer
        Dim MinePen As Pen
        Dim ColorNameIs As String


        WindowPoint = Copy2WindowXY(SourceForm, XY1)
        If InSideMyFlowChartWindow(SourceForm, WindowPoint.x, WindowPoint.y) = False Then Return 'not printable, so why print it?


        ColorNameIs = MyColorName

        If MyIsNothing(ColorNameIs) Then
            ColorNameIs = RandomColor(SourceForm)
        ElseIf ColorNameIs = "" Then
            ColorNameIs = RandomColor(SourceForm)
        Else
            If BinarySearch4Index(Options.ListBoxColors, ColorNameIs) = ConstantMyErrorCode Then
                ColorNameIs = "Black"
            End If
        End If
        'ColorNameIs="Red"

        IndexColor = BinarySearch4Index(Options.ListBoxColors, ColorNameIs)


        If IndexColor = ConstantMyErrorCode And IndexDataType = ConstantMyErrorCode Then
            logA(1203, ColorNameIs, "?", MyShowPoint(XY1))
            If MyOptionTest(25) = True Then
            Else
            End If
            Return
        End If


        'If IndexColor < 0 Then
        ' IndexDataType = FindDataTypeIndex(DataTypeName)
        ' If IndexDataType > 0 Then 'if no color name but DataType name then use the color of that DataType
        ' IndexColor = DataType_TableColorIndex(IndexDataType)
        ' If IndexColor > 0 Then 'if color in DataType table is valid then use it
        ' ColorNameIs = Color_TableName(IndexColor)
        ' Else 'if the DataType has an invalid color then make it red
        ' ColorNameIs = "Black"
        ' End If
        ' Else ' both are invalid, so just use green
        'ColorNameIs = RandomColor(SourceForm)
        '     End If
        'ElseIf IndexColor > 0 Then
        'TempSize=2
        ColorNameIs = MyColorName
        If ColorNameIs = "" Then ColorNameIs = RandomColor(SourceForm)
        '?IndexDataType=ConstantMyErrorCode
        'End If

        'TempSize = FindMySize(DataTypeName, ColorNameIs) 'size is only valid for DataTypes
        TempSize = 24 'todo this needs to be fixed.  maybe a changable default ?
        'todo need to check if this is a valid color!!!!!!
        MinePen = MyGetPen(SourceForm, ColorNameIs, "")

        WindowPoint = Copy2WindowXY(SourceForm, XY1)
        MyRec.X = WindowPoint.x - CInt(TempSize / 2)
        MyRec.Y = WindowPoint.y - CInt(TempSize / 2)
        MyRec.Width = TempSize
        MyRec.Height = TempSize
        SourceForm.FlowChartPictureBox.CreateGraphics.DrawEllipse(MinePen, MyRec)
    End Sub


    'Routine this draws a circle where each error is 
    'bug 'todo ColorName is being passed the name of the point
    Friend Sub MyDrawCircle_At(ByRef SourceForm As Source, xy As MyPointStructure, SymbolNameOfPoint As String, ColorName As String)
        Dim IndexColor As Integer
        Dim MyColorName As String
        '  Just to make sure we have a valid color (Do I need this?)
        IndexColor = BinarySearch4Index(Options.ListBoxColors, ColorName)
        If IndexColor = ConstantMyErrorCode Then
            MyColorName = MyUniverse.ProgramOptions.SelectedColor
            IndexColor = BinarySearch4Index(Options.ListBoxColors, MyColorName)
            If IndexColor = ConstantMyErrorCode Then
                MyColorName = ColorName
            End If
        Else
            MyColorName = ColorName
        End If

        MyDrawWorldCircle(SourceForm, xy, MyColorName) ' Color, not DataType

        'Display Point Names  This actuality displayed Symbol name
        'todo fix the correct display option number (not 1 for Symbol Name of point)
        MyDrawText(SourceForm, MyOffset(xy, CStr(MyUniverse.OptionDisplay(1).x), CStr(MyUniverse.OptionDisplay(1).y)), SymbolNameOfPoint, 20)
        '    MyDrawText( DrawingArea  , MyOffset(xy, CStr(MyUniverse.OptionDisplay(1).x), CStr(MyUniverse.OptionDisplay(1).y)), ColorName, 20)
    End Sub



    Friend Sub Clear_Window_Only(DrawingArea As PictureBox)
        DrawingArea.CreateGraphics.Clear(DefaultBackColor)
        MyUniverse.MyStaticData.Painting.Start = 0
        MyUniverse.MyStaticData.Painting.Ending = 0
    End Sub 'clear window ONLY


    'Routine This will clear the Window and then redraw everything


    'Routine this keeps track of where the working area is located, 

    Friend Function FindSymbol_StartIndex(ByRef SourceForm As Source, SymbolName As String) As Integer
        Dim IndexNamed As Integer

        FindSymbol_StartIndex = FindInSymbolList(SourceForm, SymbolName)
        If FindSymbol_StartIndex = ConstantMyErrorCode Then
            logA(1208, SymbolName)
            If MyOptionTest(25) = True Then
            Else
            End If
            Return FindSymbol_StartIndex ' not named Symbol
        Else
            logA(1327, SymbolName, FindSymbol_StartIndex.ToString)
        End If
        If MyStrComp(Symbol_TableSymbolName(FindSymbol_StartIndex), SymbolName) = 0 Then
            ' A I N F O 2  ( 9  9)
            Return FindSymbol_StartIndex  ' Indexes is to the right place
        End If

        'wrong Indexes here, so fix if possible, otherwise change Indexes back to a 0 to search every time(yuck)
        For IndexNamed = 1 To TopOfFile(SourceForm, "named")
            FindSymbol_StartIndex = Named_TableSymbolIndexes(IndexNamed)
            If Symbol_TableCoded_String(FindSymbol_StartIndex) = "/name" Then
                If MyStrComp(Symbol_TableSymbolName(FindSymbol_StartIndex), SymbolName) = 0 Then
                    Named_TableSymbolIndexes(IndexNamed) ' short cut
                    Return FindSymbol_StartIndex
                Else
                    Named_TableSymbolIndexes(FindSymbol_StartIndex, 0) ' Lost the Indexes
                End If
            Else
                Named_TableSymbolIndexes(FindSymbol_StartIndex, 0) ' Lost the Indexes
            End If
        Next
        Named_TableSymbolIndexes(FindSymbol_StartIndex, 0) ' Fix wrong point, and not able to find it anyway.
        logA(1209, SymbolName)
        If MyOptionTest(25) = True Then
        Else
        End If
        Return ConstantMyErrorCode ' not findable
    End Function

    'Routine 
    Friend Sub DisplayObject(ByRef SourceForm As Source, XYOffsets As MyPointStructure, SymbolName As String, RotationName As String)
        If FMBRecurse("DisplayObject") > 5 Then Return
        If MyIsValidSymbolName(SourceForm, SymbolName) = False Then Return
        PaintEach(SourceForm, XYOffsets, SymbolName, RotationName)
    End Sub

    Friend Function MyIsValidSymbolName(ByRef SourceForm As Source, SymbolName As String) As Boolean
        Dim I As Integer
        For I = 0 To TopOfFile(SourceForm, "Named")
            If Named_TableSymbolName(I) = SymbolName Then Return True
        Next
        'todo add error message (and fix by adding Symbol?
        Return False
    End Function
    Friend Function MyFindSymbolPoint(ByRef SourceForm As Source, MyXY As MyPointStructure, SymbolName As String) As Integer
        Dim IndexSymbol As Integer
        Dim IndexStart As Integer
        Dim Distance1, Distance3 As Integer

        Distance1 = 10000000 ' biggest number possible
        Distance3 = Distance1

        IndexStart = FindSymbol_StartIndex(SourceForm, SymbolName)

        MyFindSymbolPoint = ConstantMyErrorCode
        If IndexStart = ConstantMyErrorCode Then
            logA(1114, SymbolName)
            If MyOptionTest(25) = True Then
            Else
            End If
            Return ConstantMyErrorCode
        End If
        IndexStart += 1
        For IndexSymbol = IndexStart To TopOfFile(SourceForm, "Symbol")
            Select Case LCase(Symbol_TableCoded_String(IndexSymbol))
                Case "/name" ' Next name so skip it
                    Exit For
                Case "/point"
                    Distance1 = MyDistance(MyXY, MyRotated_1(IndexSymbol, MyUniverse.MyStaticData.ZeroZero, "Default"))
                    If Distance1 < Distance3 Then
                        MyFindSymbolPoint = IndexSymbol
                        Distance3 = Distance1
                    End If
                Case "/Line"
                    'Distance1=MyABS(MyXY.x - Symbol_TableX1(Index)) + MyABS(Myxy.y - Symbol_TableY1(Index))
                    Distance1 = MyDistance(MyXY, MyRotated_1(IndexSymbol, MyUniverse.MyStaticData.ZeroZero, "Default"))
                    If Distance1 < Distance3 Then
                        MyFindSymbolPoint = IndexSymbol
                        Distance3 = Distance1
                    End If
                    Distance1 = MyDistance(MyXY, MyRotated_2d(IndexSymbol, MyUniverse.MyStaticData.ZeroZero, "Default"))
                    If Distance1 < Distance3 Then
                        MyFindSymbolPoint = IndexSymbol
                        Distance3 = Distance1
                    End If
                Case Else 'todo 
                    logA(2137, Symbol_TableCoded_String(IndexSymbol))
            End Select

        Next
    End Function


    'finds the closest Symbol center, each end of the paths, 
    ' Does not search itself FromIndex
    Friend Function MyFindPoint(ByRef SourceForm As Source, MyXY As MyPointStructure, FromIndexFlowChart As Integer) As Integer ' Find the Symbol-Path-point-Line closest to X & Y
        Dim IndexFlowChart, IndexNamed As Integer, StartIndexNamedAt As Integer
        Dim LocalIndex As Integer
        Dim Distance1, Distance3 As Integer

        MyFindPoint = ConstantMyErrorCode
        Distance1 = 10000000 ' biggest number possible
        Distance3 = Distance1
        Select Case LCase(SourceForm.Parent.Name)
            Case "FlowChartWindow"
                MyFindPoint = ConstantMyErrorCode
                For IndexFlowChart = 1 To TopOfListBox(SourceForm.ListBoxFlowChart)
                    If IndexFlowChart <> FromIndexFlowChart Then
                        Select Case LCase(Trim(FlowChart_TableCode(SourceForm, IndexFlowChart)))
                            Case My_keyWord(My_KeyConstUse)
                                Distance1 = MyDistance(MyXY, MyPoint1XY(IndexFlowChart))
                                If Distance1 < Distance3 Then
                                    MyFindPoint = IndexFlowChart
                                    Distance3 = Distance1
                                End If
                            Case "/path"
                                Distance1 = MyDistance(MyXY, MyPoint1XY(IndexFlowChart))
                                If Distance1 < Distance3 Then
                                    MyFindPoint = IndexFlowChart
                                    Distance3 = Distance1
                                End If
                                'Distance1=MyABS(MyXY.x - FlowChart_TableX2(SourceForm, IndexFlowChart  )) + MyABS(Myxy.y - FlowChart_TableY2(SourceForm, IndexFlowChart  ))
                                Distance1 = MyDistance(MyXY, MyPoint2_2XY(SourceForm, IndexFlowChart))
                                If Distance1 < Distance3 Then
                                    MyFindPoint = IndexFlowChart
                                    Distance3 = Distance1
                                End If
                            Case "/Constant"
                                'Distance1=MyABS(MyXY.x - FlowChart_TableX1(SourceForm ,IndexNamed)) + MyABS(Myxy.y - FlowChart_TableY1(SourceForm    , SourceForm    , IndexNamed))
                                Distance1 = MyDistance(MyXY, MyPoint1XY(IndexFlowChart))
                                If Distance1 < Distance3 Then
                                    MyFindPoint = IndexFlowChart
                                    Distance3 = Distance1
                                End If
                            Case "/unknown"
                            Case "/delete"
                            Case "/error"
                            Case Else
                                logA(1212, MyShowFlowChartRecord(SourceForm, False, IndexFlowChart), MyShowPoint(MyXY))
                                If MyOptionTest(25) = True Then
                                Else
                                End If
                        End Select
                    End If ' skip searching for yourself
                Next
            Case "SymbolWindow" ' Find the active point for the selected Symbol table
                StartIndexNamedAt = BinarySearch4Index(Options.ListBoxSymbols, MyUniverse.ProgramOptions.SelectedSymbolName)
                If StartIndexNamedAt > ConstantMyErrorCode Then
                    'Bug This is wrong because the selected item is a string, and the p() requires a number
                    ''hack  If I stop here then find and fix the issues'
                    StartIndexNamedAt = Named_TableSymbolIndexes(My_INT(MyUniverse.ProgramOptions.SelectedSymbolName)) ', IndexNamed) ' Shortcut
                Else
                    logA(1213, StartIndexNamedAt.ToString, MyShowPoint(MyXY.x, MyXY.y), MyShowNamedRecord(False, StartIndexNamedAt))
                    If MyOptionTest(25) = True Then
                    Else
                    End If
                    StartIndexNamedAt = 1
                End If

                If Symbol_TableSymbolName(StartIndexNamedAt) <> "/name" Then
                    Named_TableSymbolIndexes(StartIndexNamedAt, 1)
                    StartIndexNamedAt = 1
                End If


                For IndexNamed = StartIndexNamedAt To TopOfFile(SourceForm, "Symbol")
                    If Symbol_TableCoded_String(IndexNamed) = "/name" Then
                        If MyStrComp(Symbol_TableSymbolName(IndexNamed), MyUniverse.ProgramOptions.SelectedSymbolName) = 0 Then
                            LocalIndex = IndexNamed
                            While LocalIndex <= TopOfFile(SourceForm, "Symbol") - 1
                                LocalIndex += 1
                                Select Case LCase(Symbol_TableCoded_String(LocalIndex))
                                    Case "/name", "/Constant" ' Added Constant incase we are at the end
                                        Exit Function
                                    Case "/point"
                                        'Distance1=MyABS(MyXY.x - Symbol_TableX1(LocalIndex)) + MyABS(Myxy.y - Symbol_TableY1(LocalIndex))
                                        Distance1 = MyDistance(MyXY, MyPoint1XY(LocalIndex))
                                        If Distance1 < Distance3 Then
                                            MyFindPoint = LocalIndex
                                            Distance3 = Distance1
                                        End If
                                    Case "/Line"
                                        'Distance1=MyABS(MyXY.x - Symbol_TableX1(LocalIndex)) + MyABS(Myxy.y - Symbol_TableY1(LocalIndex))
                                        Distance1 = MyDistance(MyXY, MyPoint1XY(LocalIndex))
                                        If Distance1 < Distance3 Then
                                            MyFindPoint = LocalIndex
                                            Distance3 = Distance1
                                        End If
                                        'Distance1=MyABS(MyXY.x - Symbol_TableX2_io(index)) + MyABS(Myxy.y - Symbol_TableY2_dt(index))
                                        Distance1 = MyDistance(MyXY, MyPoint2_2XY(SourceForm, LocalIndex))
                                        If Distance1 < Distance3 Then
                                            MyFindPoint = LocalIndex
                                            Distance3 = Distance1
                                        End If
                                    Case Else 'todo 
                                        logA(2137, Symbol_TableCoded_String(LocalIndex))
                                End Select
                            End While
                        End If
                    End If
                Next

            Case Else
        End Select
    End Function



    'Routine this finds where to start everything at
    Friend Function Find_Start(ByRef SourceForm As Source) As Integer
        Dim Index As Integer
        ' This sets up to run the interactive
        For Index = 1 To TopOfListBox(SourceForm.ListBoxFlowChart)
            If MyStrComp(FlowChart_TableCode(SourceForm, Index), My_keyWord(My_KeyConstUse)) = 0 Then
                If UCase(FlowChart_TableSymbol_Name(SourceForm, Index)) = "START" Or UCase(FlowChart_TableSymbol_Name(SourceForm, Index)) = "MAIN" Then
                    MyUniverse.ProgramOptions.SelectedObject = Index
                    Find_Start = Index
                    '''''ReSetScrollBars(Index)
                    OLD.Clear_Window(SourceForm.FlowChartPictureBox)
                    ' A I N F O 2 (147)
                    Exit Function
                End If
            End If
        Next
        Find_Start = ConstantMyErrorCode
    End Function


    'Routine While get point is 1 (true) then getting the next point
    Friend Function GetPoint(ByRef SourceForm As Source, IndexFlowChart As Integer, ByRef atXY As MyPointStructure, CountOfPoints As Integer) As MyPointStructure  'Get the closest Point to X & Y 
        Dim IndexSymbol As Integer
        IndexSymbol = FindInSymbolList(SourceForm, FlowChart_TableSymbol_Name(SourceForm, IndexFlowChart))
        If IndexSymbol = ConstantMyErrorCode Then
            logA(1124, CountOfPoints.ToString, FlowChart_TableSymbol_Name(SourceForm, IndexFlowChart), TopOfFile(SourceForm, "Symbol").ToString)
            If MyOptionTest(25) = True Then
            Else
            End If
            GetPoint = MyUniverse.MyStaticData.ZeroZero ' failed to get this point number (because the Symbol doesn't exist)
            ' A I N F O 2 (148)
            Exit Function
        End If

        IndexSymbol += 1 ' Jump over the name of this Symbol

        'Count down till we have the point number
        While CountOfPoints > 1 And IndexSymbol <= TopOfFile(SourceForm, "Symbol") - 1
            logA(2228, MyShowSymbolRecord(SourceForm, False, IndexSymbol))
            Select Case LCase(Symbol_TableCoded_String(IndexSymbol))
                Case "/name"    'Next Symbol
                    GetPoint = MyUniverse.MyStaticData.ZeroZero    ' No more points in the Symbol table
                    ' A I N F O 2 (149)
                    Exit Function
                Case "/point"
                    If CountOfPoints < 0 Then ' we are trying to get more points than exist somehow
                        GetPoint = MyUniverse.MyStaticData.ZeroZero    ' No more points in the Symbol table
                        ' A I N F O 2 (150)
                        Exit Function
                    End If
                    If CountOfPoints = 0 Then
                        atXY = MyRotated(SourceForm, IndexSymbol, IndexFlowChart)
                        GetPoint = atXY ' We have the count of points into the symbol
                        ' A I N F O 2 (151)
                        Exit Function
                    End If
                    CountOfPoints -= 1 'CountOfPoints=CountOfPoints -1 ' get the next one
                Case Else
                    logA(1216, Symbol_TableCoded_String(IndexSymbol))
                    If MyOptionTest(25) = True Then
                    Else
                    End If
            End Select
        End While
        GetPoint = MyUniverse.MyStaticData.ZeroZero    'Should never get here 
    End Function


    'Routine 

    'assume that this is the flowchart
    Friend Function InsideMyFlowChartWorld(ByRef SourceForm As Source, X As Integer, Y As Integer) As Boolean
        Dim XY As MyPointStructure = Nothing
        If X = 0 And Y = 0 Then
            Return True
        End If
        XY.x = X
        XY.y = Y
        XY = Copy2WindowXY(SourceForm, XY)
        Return InSideMyFlowChartWindow(SourceForm, XY.x, XY.y)
    End Function


    Friend Function InSideMyFlowChartWindow(ByRef SourceForm As Source, XY As MyLineStructure) As Boolean
        If XY.a.x < 0 And XY.b.x < 0 Then Return False ' all left
        If XY.a.x > SourceForm.FlowChartPictureBox.Width And XY.b.x > SourceForm.FlowChartPictureBox.Width Then Return False ' all Right
        If XY.a.y < 0 And XY.b.y < 0 Then Return False ' all above
        If XY.a.y > SourceForm.FlowChartPictureBox.Height And XY.b.y > SourceForm.FlowChartPictureBox.Height Then Return False ' all left
        Return True
    End Function

    Friend Function InSideMyFlowChartWindow(ByRef SourceForm As Source, X1 As Integer, Y1 As Integer) As Boolean
        Const FakeIt As Boolean = False 'todo this should be false
        Dim PPP As Integer  ' This is the distance outside the screen that I 'might' need to display a symbol
        '             DIM   WhereAt1XY As MyPointStructure
        Dim MaxX, MaxY As Integer
        Dim XY1 As MyPointStructure = Nothing

        PPP = MyUniverse.SysGen.Constants.ConstantSymbolCenter
        If X1 = 0 And Y1 = 0 Then
            Return True
        End If
        MaxX = SourceForm.FlowChartPictureBox.Width
        MaxY = SourceForm.FlowChartPictureBox.Height

        XY1.x = X1 : XY1.y = Y1
        XY1 = Copy2WindowXY(SourceForm, XY1)
        If XY1.x + PPP < 0 Then Return False
        If XY1.x - PPP > MaxX Then Return False
        If XY1.y + PPP < 0 Then Return False
        If XY1.y - PPP > MaxY Then Return False

        ' All Left of my Window
        If XY1.x < MyUniverse.MyMouseAndDrawing.MouseWindow.a.x Then
            Return FakeIt
        End If

        ' All Right of my Window
        If XY1.x > MyUniverse.MyMouseAndDrawing.MouseWindow.b.x Then
            Return FakeIt
        End If
        ' All above my Window
        If XY1.y < MyUniverse.MyMouseAndDrawing.MouseWindow.a.y Then
            Return FakeIt
        End If
        If XY1.y > MyUniverse.MyMouseAndDrawing.MouseWindow.b.y Then
            Return FakeIt
        End If
        ' Else It might be true, 
        Return True
    End Function


    'returns 0 if equal, 5 if both blank, 2,-2 if only one blank, else -1,0,1 for compare
    Friend Function MyStrComp(A As String, B As String) As Integer
        If Len(A) = 0 And Len(B) = 0 Then Return 5
        If Len(B) = 0 Then Return 2
        If Len(A) = 0 Then Return -2
        If TrueOrFalse(Options.ListBoxSymbolData.Items.Item(20).ToString) Then
            Return StrComp(A, B, CompareMethod.Binary)
        Else
            Return StrComp(A, B, CompareMethod.Text)
        End If
    End Function

    Friend Function MyComparePoint(A As MyPointStructure, B As MyPointStructure) As Boolean
        If MyDebug(A_STATUS) Then logA(1349, MyShowPoint(A.x, A.y), MyShowPoint(B))
        If A.x = 0 And A.y = 0 And B.x = 0 And B.y = 0 Then Return True
        If A.x <> B.x Then Return False
        If A.y <> B.y Then Return False
        Return True
    End Function



    Friend Function MyCompareLine(A As MyLineStructure, B As MyLineStructure) As Boolean
        If A.a.x <> B.a.x Then Return False
        If A.a.y <> B.a.y Then Return False
        If A.b.x <> B.b.x Then Return False
        If A.b.y <> B.b.y Then Return False
        Return True
    End Function


    ' Between the first value and the third value, this compares where the second (middle) value belongs at.
    'Test # Results Testing A, b, C
    '1   5     b=nothing
    '2   0   A And C=nothing
    '3   -1     A=b
    '4   1   b=C
    '5   -4  A=nothing And b< C
    '6   4     C=nothing And b > A
    '7   -4  A=Nothing
    '8   4     C=nothing
    '9   -5  A > C 'Unsorted List
    '10  0     A<b<C 'not in the list but should go between these
    '11  -3     A>b
    '12  -2  b > C
    '13  3     b < C
    '14  2   A < b
    '15  5     default fails everything above (Should never happen)


    Friend Function MyCompared3(ByRef LB As ListBox, StringA As String, StringB As String, StringC As String) As SByte
        Dim A, B, C As String
        'Test # Results Testing A, b, C
        '1   5 b=nothing (So you are at the end of the list (Assume that B > a or A=nothing)
        '2   0   A And C=nothing (No Items in the list , empty list)
        '3   -1 A=b
        '4   1   b=C
        '5   -4  A=nothing And b< C
        '6   4 C=nothing And b > A
        '7   -4  A=Nothing
        '8   4 C=nothing
        '9   -5  A > C 'Unsorted List
        '10  0 A<b<C 'not in the list but should go between these
        '11  -3 A>b
        '12  -2  b > C
        '13  3 b < C
        '14  2   A < b
        '15  5 default fails everything above (Should never happen)

        A = StringA
        B = StringB
        C = StringC


        'FMB(StringA, StringB)
        'FMB(StringB, StringC)
        'FMB(StringA, StringC)
        '-1,-1,-1
        '-1'-1,0
        '2020-12-12 Added test to make sure that A is not null (or nothing)
        If Len(StringA) = 0 Then
            If Len(StringB) = 0 Then
                If MyOptionTest(25) = True Then
                Else
                End If
                Return 5 'End of the list (and not the beginning of the list
            End If
        End If

        'First One(A) in the List is between them 
        If Len(A) = 0 And Len(C) = 0 And Len(StringB) > 0 Then
            ' A I N F O 2 (-104)
            Return 0 'First item in the list
        End If

        '(B) in the List is between somethings 
        If Len(A) > 0 And Len(C) > 0 And Len(StringB) > 0 Then
            If MyStrComp(A, B) < 0 Then
                If MyStrComp(C, B) > 0 Then
                    Return 0
                End If
            End If
        End If

        '-1 A=B
        If MyStrComp(A, B) = 0 Then
            '' A I N F O 2 (105)
            Return -1
        End If
        ' 1 B=C
        If MyStrComp(B, C) = 0 Then
            '' A I N F O 2 ( 1 0 6 )
            Return 1
        End If
        '-4 A=start Of list (So Lowest)
        If Len(A) = 0 And MyStrComp(B, C) < 0 Then
            ' A I N F O 2 (-107)
            Return -4 ' Start of the list (See below also)
        End If
        ' 4 C is the end of the list (So Highest)
        If Len(C) = 0 And MyStrComp(B, A) > 0 Then
            '' A I N F O 2 (108)
            Return 4 ' end of the list (See below also)
        End If

        '2020 07 31 'special case if there is a sorted list at the top or bottom
        If MyStrComp(A, C) = 0 And MyStrComp(B, C) < 0 Then
            ' A I N F O 2 (-109)
            Return -4 ' Start of the list (See below also)' Or ELSE you have A and B the same (index array item)
        End If
        ' 4 C is the end of the list (So Highest)
        If MyStrComp(A, C) = 0 And MyStrComp(B, A) > 0 Then
            '' A I N F O 2 (110)
            Return -2 '4 ' end of the list (See below also)
        End If

        If Len(A) = 0 Then
            ' A I N F O 2 (-111)
            Return -4 ' Start of the list?
        End If
        If Len(C) = 0 And MyStrComp(A, B) > 0 Then 'A Is higher than B  And C=nothing
            ' A I N F O 2 (-112)
            Return -3 ' Added 2021/01/07
        End If
        ' 4 C is the end of the list (So Highest)
        If Len(C) = 0 Then
            ' A I N F O 2 (113)
            Return 4 ' end of the list (Also)?
        End If
        '-5 A is not <= than C (A>C) Error
        If MyStrComp(A, C) > 0 Then
            'log_X(1845, MyTable, A, B, C)
            'log_X(3533, A, B, C)
            Return -5
        End If
        ' 0 B is between A and C
        If MyStrComp(A, B) < 0 And MyStrComp(B, C) < 0 Then
            '' A I N F O 2 (115)
            Return 0
        End If
        '-3 A is higher than B  and C=nothing
        If MyStrComp(A, B) > 0 Then
            '' A I N F O 2 (116)
            Return -3
        End If
        '-2 B is higher than C
        If MyStrComp(B, C) > 0 Then
            '    ' A I N F O 2 (117)
            Return -2
        End If
        ' 3 C is higher then B
        If MyStrComp(B, C) < 0 Then
            ' A I N F O 2 (118)
            Return 3
        End If
        ' 2 A is lower than B 
        If MyStrComp(A, B) < 0 Then
            ' A I N F O 2 (119)
            Return 2
        End If
        ' 5 Error
        If MyOptionTest(25) = True Then
        Else
        End If
        ' A I N F O 2 (120)
        Return 5 ' default error
    End Function


    'This is used for checking if the indexes are valid or not
    Friend Function MyCompared2(ByRef LB As ListBox, A As Integer, B As Integer) As Integer
        MyCompared2 = MyCompared1_a(GetMyRecord(LB, A), GetMyRecord(LB, B))
    End Function


    Friend Function MyCompared1(A As String, B As String) As Integer
        If A < B Then Return -1
        If A > B Then Return 1
        Return 0
    End Function

    Friend Function MyComparedIndex2Index(A As Integer, B As Integer) As Integer
        '-2 A=start Of list (So Lowest)
        '-1 A is lower than B (Default if nothing else)
        ' 0 A and B match 
        ' 1 A is higher than B
        ' 2 B is the end of the list (So Highest)

        If A = B Then
            ' A I N F O 2 (128)
            Return 0
        End If
        'If the first Is nothing then it is considered the largest
        If MyIsNothing(A.ToString) Then
            ' A I N F O 2 (129)
            Return -2 'Nothing or null is always the highest
        End If
        ' If the second is nothing then 
        If MyIsNothing(B.ToString) Then
            ' A I N F O 2 (130)
            Return 2 ' You are always searching for something less than nothing or a null
        End If

        'Now we can actually test the two string
        If A > B Then
            ' A I N F O 2 (131)
            Return 1
        End If
        'The default is A < B and anything else is false
        If B > A Then
            ' A I N F O 2 (132)
            Return -1
        End If
        Return -5 'Error
    End Function


    '-2=(start), -1=(A<B), 0=(A=B),1=(A>B),2=(B=End)
    ' Compare two strings to see the order they should be in
    '-2 A=start Of list (So Lowest)
    '-1 A is lower than B (Default if nothing else)
    ' 0 A and B match 
    ' 1 A is higher than B
    ' 2 B is the end of the list (So Highest)


    Friend Function MyCompared1_a(StringA As String, StringB As String) As Integer
        '-1 A is lower than B (Default if nothing else)
        ' 0 A and B match 
        ' 1 A is higher than B
        MyCompared1_a = MyStrComp(StringA, StringB)
        If MyCompared1_a = 0 Then
            Return 0
        End If
        Return MyCompared1_a
    End Function

    Friend Function ComputerFileNamesAre() As String
        Dim i As Integer
        Dim C, E, F As String

        'todo this needs to add multiply extensions (and the correct ones)
        E = Options.ListBoxSymbolData.Items.Item(25).ToString
        C = MyUniverse.ProgramOptions.FCCL_LanguageClassName
        F = ""

        i = 1
        While Len(E) > 1
            F &= C & " (*" & ThisExtension(Options.ListBoxSymbolData.Items.Item(25).ToString, i) & ")" & "|*" & ThisExtension(Options.ListBoxSymbolData.Items.Item(25).ToString, i) & "|"
            i += 1
            Pop(E, FD)
        End While
        F &= "all files (*.*)|*.*"
        Return F
    End Function


    'CHeck if this name is used, and then return one that is not used.
    Friend Function MakeNextName(SymbolName As String) As String

        'todo need to check if (already has a number and 2 if this symbol name already exist
        MakeNextName = SymbolName
        While FindInNamedList(MakeNextName) > 1
            MakeNextName &= MyRnd(1)
        End While
    End Function






    Friend Function FindSymbolName(IndexSymbol As Integer) As String ' Finds tha name of the Symbol from the index in the graphic Symbols
        Dim LocalIndex As Integer

        LocalIndex = IndexSymbol
        While LocalIndex > 0 And Symbol_TableCoded_String(LocalIndex) <> "/name"
            LocalIndex -= 1
        End While
        ' A I N F O 2 (121)
        Return Symbol_TableSymbolName(LocalIndex)
    End Function


    Friend Function MyGrammarNameOnly(GrammarRule As String) As String
        Dim debug1 As String
        debug1 = MyGrammarName(GrammarRule)
        Select Case MyRight(debug1, 1)
            Case "*", "+", "?", "-"
                Return MyLeft(debug1, Len(debug1) - 1)
            Case Else
                Return Pop(debug1, MyUniverse.SysGen.Constants.ConstantDelimiters & "*+?-")
        End Select

    End Function


    Friend Function MyGrammarName(BNF As String) As String
        Return Pop(BNF, MyUniverse.SysGen.Constants.ConstantDelimiters)
    End Function


    Friend Function My_VariableName(ByRef SourceForm As Source, VariableNumber As Integer) As String 'This should return the name of the variable
        'ERROR this is not getting the correct variable name
        ' MyUniverse.MyStaticData.Path_Names
        Dim VariableNames, Temp As String
        VariableNames = MyUniverse.MyStaticData.Path_Names
        'Temp =
        PopLine(MyNoCR(VariableNames, vbTab))
        If Do_Not_Use_IsThisAMarker(SourceForm, VariableNames) <> "" Then
            Return NameOfPointOnly(VariableNames)
        End If
        If Do_Not_Use_IsThisAMarker2(SourceForm, VariableNames) <> "" Then
            Return NameOfPointOnly(VariableNames)
        End If

        If CountPathNames(SourceForm, VariableNames) < VariableNumber Then
            If MyOptionTest(25) = True Then
                My_VariableName = MakeNewName(SourceForm, "NoName_B_", "")
                Return My_VariableName
            Else
                Return ""
            End If
        End If
        Temp = ReturnPathName(SourceForm, VariableNumber, MyUniverse.MyStaticData.Path_Names)

        Return Temp
    End Function 'my variable name    MyUniverse.MyStaticData.Path_Names





    Friend Function SymbolNameFromCodeLine1(ByRef SourceForm As Source, CodeLine As String) As String
        Dim Temp(1) As String
        Dim I As Integer
        Dim Debug1 As String
        Dim KeyWordForCodeLine As String
        KeyWordForCodeLine = ""
        MyUniverse.MyStaticData.Path_Names = MyParse(Temp, CodeLine) ' Parse the code Line then
        MyUniverse.MyStaticData.Path_NamesCounted = CountPathNames(SourceForm, MyUniverse.MyStaticData.Path_Names)
        For I = 1 To MySizeOf(Temp)
            Debug1 = IsThisAWhiteSpace(SourceForm, Temp(I))
            Select Case Debug1'IsThisAWhat(Temp(I))
                Case Nothing ' test nothing first because some of the markers might be set to nothing
                    Return KeyWordForCodeLine
                Case MyUniverse.SysGen.Markers.KeyWords, MyUniverse.SysGen.Markers.Functions
                    KeyWordForCodeLine &= LCase(Temp(I))
                Case MyUniverse.SysGen.Markers.CameFromLine ' Ignore for a name
                    KeyWordForCodeLine &= "1"
                Case MyUniverse.SysGen.Markers.BranchToNextLine ' Ignore for a name
                    KeyWordForCodeLine &= "2"
                Case MyUniverse.SysGen.Markers.Operators
                    KeyWordForCodeLine &= "O" '&' LCase(Temp(I))
                Case MyUniverse.SysGen.Markers.UnicodeClass
                    KeyWordForCodeLine &= "✅"
                Case MyUniverse.SysGen.Markers.SpecialCharacter
                    'todo need to decide if all special characters or separate () {}| [] and other special characters
                    KeyWordForCodeLine &= "^"
                Case Options.ListBoxSymbolData.Items.Item(21).ToString
                    KeyWordForCodeLine &= "C"
                Case MyUniverse.SysGen.Markers.Quotes, MyUniverse.SysGen.Markers.Literal
                    KeyWordForCodeLine &= "q"
                Case MyUniverse.SysGen.Markers.Quotes, MyUniverse.SysGen.Markers.HexRange
                    KeyWordForCodeLine &= "h"
                Case MyUniverse.SysGen.Markers.Block
                    KeyWordForCodeLine &= "B"

                Case MyUniverse.ProgramOptions.FCCL_MultiLine
                    KeyWordForCodeLine &= "XXX" 'MultiLine not allowed right now"
                        'Case MyUniverse.ProgramOptions.FCCL_MultiLine
                        'KeyWordForCodeLine &= "COLON"

                Case MyUniverse.SysGen.Markers.FieldDelimiters, FD
                    KeyWordForCodeLine &= "_"
                Case Options.ListBoxSymbolData.Items.Item(25).ToString
                    KeyWordForCodeLine &= ""
                Case MyUniverse.ProgramOptions.FCCL_VarChars
                    KeyWordForCodeLine &= MyUniverse.ProgramOptions.FCCL_VarChars
                Case MyUniverse.SysGen.Markers.Comments
                    KeyWordForCodeLine &= "COMMENT"
                Case MyUniverse.SysGen.Markers.DataType
                    KeyWordForCodeLine &= "DT"
                Case MyUniverse.SysGen.Markers.Numbers
                    KeyWordForCodeLine &= "#"
                Case MyUniverse.SysGen.Markers.Grammar
                    KeyWordForCodeLine &= "_BNF_"
                Case Else 'todo need to check if this is a marker for a keyword 
                    If Do_Not_Use_IsThisAVariableNameX(SourceForm, Temp(I)) Then
                        KeyWordForCodeLine &= "VAR" 'NameOfPointOnly(Temp(I))
                    ElseIf Temp(I) = "_" Then
                        KeyWordForCodeLine &= "_"
                    Else
                        KeyWordForCodeLine &= "-" ' Temp(I) 'NameOfPointOnly(Temp(I))
                    End If
            End Select
        Next I
        Return KeyWordForCodeLine
    End Function

    Friend Function MakeNewName(ByRef SourceForm As Source, StartOfName As String, CodeLineX As String) As String
        Dim RTN As String
        RTN = CodeLineX
        RTN = Strings.Replace(RTN, FD, "_")
        If MyDebug(A_DISPLAY) Then
        End If
        '
        MakeNewName = StartOfName & MyRnd(6).ToString & "_" & SymbolNameFromCodeLine(SourceForm, RTN)
        While FindInSymbolList(SourceForm, MakeNewName) > 1 'todo loop forever to try and find a random symbol name (instead of just adding one to the random number created
            MakeNewName &= MyRnd(1).ToString
        End While
    End Function


    ' This inserts all new records after the end of the /name, instead of at the end of the list after name (before the next /name)
    Friend Function AddNEWFlowChartRecordPath(ByRef SourceForm As Source, SymbolName As String,
             Coded As String, X1 As Integer, Y1 As Integer, X2_io As Integer,
             Y2_dt As Integer, MyDataType As String) As Integer
        '
        '
        'AddNEWFlowChartRecordPath=NewTopOfFile(SourceForm,  "FlowChart")
        If Len(SymbolName) = 0 Then
            SymbolName = MakeNewName(SourceForm, "Error", Mid(Coded, 2, 99) & VBSpace & MyDataType)
        End If
        AddNEWFlowChartRecordPath = AddFlowChartRecordOther(SourceForm, SymbolName, Coded, X1, Y1, X2_io, Y2_dt, MyDataType.ToString)
        RouterConnectPath(SourceForm, AddNEWFlowChartRecordPath)
    End Function
    Friend Function AddNEWFlowChartRecordUse(ByRef SourceForm As Source, SymbolName As String, Coded As String, X1 As Integer, Y1 As Integer, X2_io As String, Y2_dt As String, MyDataType As String) As Integer
        AddNEWFlowChartRecordUse = AddFlowChartRecordOther(SourceForm, SymbolName, Coded, X1, Y1, My_INT(X2_io), My_INT(Y2_dt), MyDataType.ToString) ', LineNumber
    End Function


    Friend Sub AddNEWSymbolLineRecord(ByRef SourceForm As Source, SymbolName As String, Coded As String, X1 As Integer, Y1 As Integer, X2 As Integer, Y2 As Integer, MyName_Of_Point As String)
        Dim IndexSymbol, IndexNamed As Integer
        Dim PointName As String
        PointName = MyName_Of_Point
        PointName = Pop(PointName, MyUniverse.SysGen.Constants.ConstantDelimiters) ' make sure that it is only one word
        '

        IndexNamed = BinarySearch4Index(Options.ListBoxSymbols, SymbolName)
        If IndexNamed <= 0 Then '  ConstantMyErrorCode Then
            IndexNamed = CheckNotInList("named", SymbolName)
            If IndexNamed = ConstantMyErrorCode Then
                IndexNamed = AddNewNamedRecord(SourceForm, SymbolName, "Missing", "Opcode", "Added Named that was missing", CreateFileNameFromSyntax(SourceForm, Coded & MyName_Of_Point), "Auto", "Version") 'MyUniverse.ProgramOptions.FCCL_LanguageClassName,
                If IndexNamed = ConstantMyErrorCode Then
                    If MyOptionTest(25) = True Then
                    Else
                    End If
                End If
            End If
        End If
        ' The following is not return correctly
        IndexSymbol = FindInSymbolList(SourceForm, SymbolName) ' Search the named 
        If IndexSymbol > 0 Then
            IndexSymbol += 1 ' move to one after the name
            If MyStrComp(Coded, "/name") <> 0 Then
                InsertSymbolLineRecord(SourceForm, IndexSymbol, MyLine1(SourceForm, X1, Y1, X2, Y2), SymbolName, Coded, PointName)
            End If
        Else
            ' New name and record so add name if not already there (which its not) and then this record
            IndexSymbol = NewTopOfFile(SourceForm, "Symbol")
            ' AddFlowChartRecord() the record to the end after a New name record cause there is no name record now.
            If MyStrComp(LCase(Coded), "/name") = 0 Then ' We have to add a missing /name record
                UpdateSymbolLineRecordAt(SourceForm, IndexSymbol, SymbolName, Coded, X1, Y1, X2, Y2, PointName)
                Return
            Else
                IndexSymbol += 1 ' To one after the end of the end of the file 2020 08 06
                InsertSymbolLineRecord(SourceForm, IndexSymbol, MyLine1(SourceForm, X1, Y1, X2, Y2), SymbolName, Coded, PointName)
            End If
        End If
        '''''ReSortSymbolList()
        TopOfFile(SourceForm, "Symbol") ' This is to update the top of the file counter
    End Sub




    ' This inserts all new records after the end of the /name, instead of at the end of the list after name (before the next /name)
    Friend Sub AddNEWSymbolPointRecord(ByRef SourceForm As Source, SymbolName As String, Coded As String, X1 As Integer, Y1 As Integer, X2_IO As String, Y2_DT As String, MyName_Of_Point As String)
        Dim IndexSymbol, IndexNamed As Integer
        Dim PointName As String

        PointName = MyName_Of_Point
        PointName = Pop(PointName, MyUniverse.SysGen.Constants.ConstantDelimiters) ' make sure that it is only one word

        IndexNamed = BinarySearch4Index(Options.ListBoxSymbols, SymbolName)
        If IndexNamed = ConstantMyErrorCode Then
            IndexNamed = CheckNotInList("named", SymbolName)
            If IndexNamed = ConstantMyErrorCode Then
                AddNewNamedRecord(SourceForm, SymbolName, "Missing", "Opcode", "Added Named that was missing", CreateFileNameFromSyntax(SourceForm, Coded & MyName_Of_Point), "Auto", "Version") ', MyUniverse.ProgramOptions.FCCL_LanguageClassName
            End If
        End If
        ' The following is not return correctly
        IndexSymbol = FindInSymbolList(SourceForm, SymbolName) ' Search the named 
        If IndexSymbol > 0 Then
            IndexSymbol += 1 ' move to one after the name
            If MyStrComp(LCase(Coded), "/name") <> 0 Then '2020 08 01 we do not want to add two name records, 
                MyInsertSymbolPointRecord(SourceForm, IndexSymbol, SymbolName, Coded, X1, Y1, X2_IO, Y2_DT, PointName)
            Else ' 2020 08 11 but we will NOT update the record after the name name record
                SetMyRecord(Options.ListBoxSymbolData, IndexSymbol, ToRecord("Symbol", SymbolName, Coded, X1, Y1, X2_IO, Y2_DT, PointName))
            End If
        Else
            ' New name and record so add name if not already there (which its not) and then this record
            IndexSymbol = NewTopOfFile(SourceForm, "Symbol")
            ' AddFlowChartRecord() the record to the end after a New name record cause there is no name record now.
            If MyStrComp(LCase(Coded), "/name") = 0 Then ' We have to add a missing /name record
                ' We have to have a symbol name first
                UpdateSymbolPointRecordAt(SourceForm, IndexSymbol, SymbolName, Coded, X1, Y1, X2_IO, Y2_DT, PointName)
                Return
            Else '2020 08 06
                'We are not updating /name records ever here
                'UpdateSymbolRecordAt(IndexSymbol, SymbolName, "/name", 0, 0, "both", "Default", "Default")
                ' set the record after 
                IndexSymbol += 1 ' To one after the end of the end of the file 2020 08 06
                MyInsertSymbolPointRecord(SourceForm, IndexSymbol, SymbolName, Coded, X1, Y1, X2_IO, Y2_DT, PointName)
            End If
        End If
        TopOfFile(SourceForm, "Symbol") ' This is to update the top of the file counter
    End Sub


    '
    'Make a new Symbol, or get the data from an old Symbol
    'based on the name in the Symbol text box
    '
    'Updates the text boxes on the Symbol Window and redraw.

    Friend Sub MyUpdateSymbolRecordFromSymbolWindow(ByRef SourceForm As Source, What As String) 'undone needs to update the toolstrip Symbol selection on both the Symbol and FlowChart
        Dim Temp As Integer ' max size of a Symbol
        Dim IndexNamed, IndexSymbol As Integer

        Library.ListBoxPointNameList.Text = ""
        Library.ListBoxLineColor.Text = ""
        OLD.Clear_Window(Library.PictureBox1)
        'Me.PictureBox1.Image=Nothing

        DoEvent(22, "update Symbol")
        Temp = MyUniverse.SysGen.Constants.ConstantSymbolCenter * 2
        '
        'PaintEach(Library.PictureBox1, MyPoint1XY( Temp, Temp), What, "Default") ' redraw the Symbol
        IndexNamed = BinarySearch4Index(Options.ListBoxSymbols, "AddressOf", What) ' Get where it is in the Symbols

        If IndexNamed = -1 Then ' Not found in the Named table, so Assume there is not defined Symbol
            'it as a new Symbol
            IndexNamed = BinarySearch4Index(Options.ListBoxSymbols, What)
            If IndexNamed > 0 Then
                Library.TextBoxSymbolName.Text = ""
                DoEvent(23, "update Symbol")
                '''''Library.TextBoxNamedNameOfFile.Text = What
                Library.TextBoxNamedNotes.Text = ""
                Library.TextBoxNamedOpCode.Text = ""
                Library.TextBoxNamedStroke.Text = ""
                MyUniverse.ProgramOptions.SelectedSymbolName = ""
                Library.ListBoxPointNameList.Text = ""
                Library.ListBoxPointNameList.Items.Clear()
                Library.ListBoxLineColor.Text = ""
                Library.ListBoxLineColor.Items.Clear()
                Library.TextBoxSymbolVersionAuthor.Text = ""
                CorrectingIndexes(SourceForm, What)
                PaintEachLibrary(Library, MyPoint1XY(Temp, Temp), What, "Default") ' redraw the Symbol
                Return
            End If
        Else ' If the Symbol already exist then update the Window with the data in the 'file'
            DoEvent(24, "update Symbol")
            IndexNamed = Named_FileSymbolName_ISAM(IndexNamed)
            If IndexNamed <= 0 Then
                PaintEachLibrary(Library, MyPoint1XY(Temp, Temp), What, "Default") ' redraw the Symbol
                Return
            End If
            Named_TableMicroCodeText(IndexNamed, Library.TextBoxSymbolName.Text)
            '''''Named_TableNameOfFile(IndexNamed, Library.TextBoxNamedNameOfFile.Text)
            Named_TableNotes(IndexNamed, Library.TextBoxNamedNotes.Text)
            Named_TableOpCode(IndexNamed, Library.TextBoxNamedOpCode.Text)
            Named_TableStroke(IndexNamed, Library.TextBoxNamedStroke.Text)
            Named_TableSymbolName(IndexNamed, MyUniverse.ProgramOptions.SelectedSymbolName)
            'todo make sure that the version and author is formated right (What ever right happends to end up being.)
            Named_TableVersion(IndexNamed, Library.TextBoxSymbolVersionAuthor.Text)
            Library.ListBoxPointNameList.Text = ""
            DoEvent(24, "update Symbol")
            ' Updating the quick Indexes to the Symbol
            IndexSymbol = Named_TableSymbolIndexes(IndexNamed)
            If IndexSymbol > 0 Then ' make sure we have a Indexes
                If MyStrComp(Named_TableSymbolName(IndexNamed), Symbol_TableSymbolName(IndexSymbol)) = 0 Then ' make sure its the same Symbol still
                    If MyStrComp(LCase(Symbol_TableCoded_String(IndexSymbol)), "/name") = 0 Then ' make sure its the start of the Symbol
                        IndexSymbol += 1
                        While Symbol_TableCoded_String(IndexSymbol) <> "/name" And IndexSymbol <= TopOfFile(SourceForm, "Symbol")
                            If Symbol_TableCoded_String(IndexSymbol) = "/point" Then
                                Library.ListBoxPointNameList.Text = Library.ListBoxPointNameList.Text & COMMA & Symbol_Table_NameOfPoint(IndexSymbol)
                                DoEvent(25, "update Symbol")
                            End If
                            IndexSymbol += 1
                        End While
                    Else
                        CorrectingIndexes(SourceForm, MyUniverse.ProgramOptions.SelectedSymbolName)
                    End If
                Else
                    CorrectingIndexes(SourceForm, MyUniverse.ProgramOptions.SelectedSymbolName)
                End If
            Else
                CorrectingIndexes(SourceForm, MyUniverse.ProgramOptions.SelectedSymbolName)
            End If
        End If
        PaintEachLibrary(Library, MyPoint1XY(Temp, Temp), What, "Default") ' redraw the Symbol
    End Sub



    Friend Function ToRecord(SymbolName As String, Coded As String, X1 As Integer, Y1 As Integer, X2_IO As Integer, Y2_DT As Integer, PointName As String) As String
        Return ToRecord(SymbolName, Coded, X1.ToString, Y1.ToString, X2_IO.ToString, Y2_DT.ToString, PointName)
    End Function
    Friend Function ToRecord(SymbolName As String, Coded As String, X1 As String, Y1 As String, X2_IO As String, Y2_DT As String, PointName As String) As String
        Return SymbolName & "," & Coded & "," & X1 & "," & Y1 & "," & X2_IO & "," & Y2_DT & "," & PointName
    End Function


    Friend Sub UpdateSymbolLineRecordAt(ByRef SourceForm As Source, LocalIndex As Integer, SymbolName As String, Coded As String, X1 As Integer, Y1 As Integer, X2 As Integer, Y2 As Integer, NameOfPoint As String)
        TopOfFile(SourceForm, "Symbol") ' This is to reset the top of file counter only
        Symbol_FileCoded(LocalIndex) = MyKeyword2Number(Coded) ' I think that I forgot this one.
        Symbol_FileSymbolName(LocalIndex) = SymbolName
        Symbol_TableX1(LocalIndex, X1)
        Symbol_TableY1(LocalIndex, Y1)
        Symbol_Table_X2(LocalIndex, X2) ' these have to check for x2 or a io-name
        Symbol_Table_Y2(LocalIndex, Y2) ' these have to check for y2 or a DataType-name
        Symbol_Table_NameOfPoint(LocalIndex, NameOfPoint)
    End Sub




    Friend Sub UpdateSymbolPointRecordAt(ByRef SourceForm As Source, LocalIndex As Integer, SymbolName As String, Coded As String, X1 As Integer, Y1 As Integer, X2_io As String, Y2_dt As String, NameOfPoint As String)
        TopOfFile(SourceForm, "Symbol") ' This is to reset the top of file counter only
        Symbol_FileCoded(LocalIndex) = MyKeyword2Number(Coded) ' I think that I forgot this one.
        Symbol_FileSymbolName(LocalIndex) = SymbolName
        Symbol_TableX1(LocalIndex, X1)
        Symbol_TableY1(LocalIndex, Y1)
        Symbol_Table_InputOutput(LocalIndex, X2_io) ' these have to check for x2 or a io-name
        Symbol_Table_DataType(LocalIndex, Y2_dt) ' these have to check for y2 or a DataType-name
        Symbol_Table_NameOfPoint(LocalIndex, NameOfPoint)
    End Sub


    Friend Function AddNewNamedRecord(ByRef SourceForm As Source,
                                      SymbolName As String,
                                      SourceCode As String,
                                      Optional opcode As String = "No OpCodes",
                                      Optional notes As String = "?",
                                      Optional filename As String = "?",
                                      Optional author As String = "?",
                                      Optional version As String = "?",
                                      Optional stroke As String = "?",
                                      Optional Syntax As String = "?") As Integer
        '
        AddNewNamedRecord = BinarySearch4Index(Options.ListBoxSymbols, SymbolName)
        If AddNewNamedRecord > 0 Then
            Exit Function
        End If
        AddNewNamedRecord = NewTopOfFile(SourceForm, "named")
        Named_FileSymbolName_ISAM(AddNewNamedRecord) = AddNewNamedRecord
        Named_FileSyntax_ISAM(AddNewNamedRecord) = AddNewNamedRecord
        Named_FileSymbolName(AddNewNamedRecord) = SymbolName

        Named_TableSymbolName(AddNewNamedRecord, SymbolName) 'Name of the Symbol
        'todo need to always make the text into macro code text (replace the variable name with " & MyFD("variable name.Path" ) & "
        Named_TableMicroCodeText(AddNewNamedRecord, SourceCode) 'The actual program code to be 'fixed'
        Named_TableOpCode(AddNewNamedRecord, opcode) 'The Machine code of this assemble Symbol
        Named_TableNotes(AddNewNamedRecord, notes) 'Notes for this Symbol
        Named_FileNameOfFile(AddNewNamedRecord) = filename ' This is to avoid index checking not having anything
        Named_TableNameOfFile(AddNewNamedRecord, filename)  'The device:/path/Filename where this came from 

        '    Named_TableLanguage(AddNewNamedRecord, language) 'The computer language this applies to
        Named_TableAuthor(AddNewNamedRecord, author) 'Who wrote or responsible for this Symbol
        Named_TableVersion(AddNewNamedRecord, version) ' the date of the latest update
        Named_TableStroke(AddNewNamedRecord, stroke) 'The movement of the mouse that id's this Symbol
        Named_TableSyntax(AddNewNamedRecord, Syntax) ' The Syntax for this
        Named_FileSyntax_ISAM(AddNewNamedRecord) = AddNewNamedRecord


        If MyLeft(Named_TableSyntax(AddNewNamedRecord), 1) = "?" And Named_TableMicroCodeText(AddNewNamedRecord) <> "" Then
            MyUniverse.MyStaticData.Path_Names = MyParse(MyUniverse.MyStaticData.My_Syntax_Line_Parsed, SourceCode)
            MyUniverse.MyStaticData.Path_NamesCounted = CountPathNames(SourceForm, MyUniverse.MyStaticData.Path_Names)
            Syntax = MakeStatementSyntax(SourceForm, MyUniverse.MyStaticData.My_Syntax_Line_Parsed)
            Syntax = AddComeGo(Syntax)
            Named_TableSyntax(AddNewNamedRecord, Syntax) ' The Syntax for this
        End If
        '''''ReSortNamed(AddNewNamedRecord)
        Named_TableSymbolIndexes(AddNewNamedRecord, CorrectingIndexes(SourceForm, SymbolName)) ' A Indexes to this Symbol in the Symbol Graphics Table
        '''''ReSortNamed(AddNewNamedRecord)


        '''''ShowSorts("Named", MyReSort("Named", 'AddNewNamedRecord))
        '''''ShowSorts("named", MyReSort("Named", AddNewNamedRecord))
        CorrectingIndexes(SourceForm, SymbolName)
        '''''ShowSorts("Named", MyReSort("Named", 'AddNewNamedRecord))
        TopOfFile(SourceForm, "named") ' This is to update the top of file, and make the array bigger
        'If Named_TableSyntax(AddNewNamedRecord) = "" Then
        CheckAndFixSyntax(SourceForm)
        'End If
    End Function

    Friend Function AddANewFlowChartRecord(ByRef SourceForm As Source) As Integer
        '2020/6/22 change to return the record number instead of passing it.
        '
        AddANewFlowChartRecord = NewTopOfListBox(SourceForm.ListBoxFlowChart)
    End Function

    Friend Function AddFlowChartRecordPath(ByRef SourceForm As Source, Named As String, coded As String, XY As MyLineStructure, MyDataType As String) As Integer
        Return AddFlowChartRecordPath(SourceForm, Named, coded, XY.a.x, XY.a.y, XY.b.x, XY.b.y, MyDataType)
    End Function
    Friend Function AddFlowChartRecordPath(ByRef SourceForm As Source, named As String, coded As String, x1 As Integer, y1 As Integer, x2 As Integer, y2 As Integer, MyDataType As String) As Integer
        If coded <> "/path" Then
            If MyOptionTest(25) = True Then
            Else
            End If
        End If
        AddFlowChartRecordPath = NewTopOfListBox(SourceForm.ListBoxFlowChart)
        FlowChart_tablePathSymbolName(SourceForm, AddFlowChartRecordPath, NameOfPointOnly(named))
        FlowChart_tableCoded(SourceForm, AddFlowChartRecordPath, MyKeyword2Number(coded))

        FlowChart_tablePathSymbolName(SourceForm, AddFlowChartRecordPath, NameOfPointOnly(named))
        FlowChart_TableCode(SourceForm, AddFlowChartRecordPath, MyKeyword2Number(coded).ToString)
        FlowChart_TableX1(SourceForm, AddFlowChartRecordPath, x1)
        FlowChart_TableY1(SourceForm, AddFlowChartRecordPath, y1)
        FlowChart_TableX2(SourceForm, AddFlowChartRecordPath, x2)
        FlowChart_TableY2(SourceForm, AddFlowChartRecordPath, y2)


        FlowChart_TableDataType(SourceForm, AddFlowChartRecordPath, MyDataType) 'The DataType for /Path /Constant
        If GetMyRecord(SourceForm.ListBoxFlowChart, AddFlowChartRecordPath) = "" Then
            MakeNewNetLinks(SourceForm, AddFlowChartRecordPath, named)
            logA(1352, AddFlowChartRecordPath.ToString, MyShowFlowChartRecord(SourceForm, False, AddFlowChartRecordPath))
        End If
        '''''ShowSorts("FlowChart", ReSortFlowChart(AddFlowChartRecordPath))
        TopOfListBox(SourceForm.ListBoxFlowChart) ' This is to update the top of file, and make the array bigger
        Return AddFlowChartRecordPath
    End Function


    Friend Function FlowChart_TableRecord(ByRef SourceForm As Source, IndexFlowChart As Integer) As FCCL_FlowChart
        FlowChart_TableRecord.PathSymbolName = FlowChart_tablePathSymbolName(SourceForm, IndexFlowChart)
        FlowChart_TableRecord.X1 = FlowChart_TableX1(SourceForm, IndexFlowChart)
        FlowChart_TableRecord.Y1 = FlowChart_TableY1(SourceForm, IndexFlowChart)
        FlowChart_TableRecord._X2_Rotation = FlowChart_TableX2(SourceForm, IndexFlowChart)
        FlowChart_TableRecord._Y2_Option = FlowChart_TableY2(SourceForm, IndexFlowChart)
        FlowChart_TableRecord.Coded = FlowChart_TableCode(SourceForm, IndexFlowChart)
        FlowChart_TableRecord._DataType = FlowChart_TableDataType(SourceForm, IndexFlowChart)
    End Function



    Friend Function CheckFlowChartExist(ByRef SourceForm As Source, Temp As FCCL_FlowChart) As Boolean
        Dim I As Integer
        'todo this is a very slow method of finding duplicates, need to us the ISAMs() to find the first and then only while it matches
        For I = 1 To TopOfListBox(SourceForm.ListBoxFlowChart)
            'If MyDebug(A_DISPLAY) ThenLogA(5070, "*")
            'If MyDebug(A_DISPLAY) ThenLogA(5071, "Name " & Temp.PathSymbolName, FlowChart_TableSymbol_Name(SourceForm  ,  I))
            If Temp.PathSymbolName = FlowChart_TableSymbol_Name(SourceForm, I) Then
                'If MyDebug(A_DISPLAY) ThenLogA(5072, "code " & Temp.Coded, FlowChart_tableCoded(SourceForm, I).ToString)
                If Temp.Coded = FlowChart_TableCode(SourceForm, I) Then
                    'If MyDebug(A_DISPLAY) ThenLogA(5073, "X1   " & Temp.X1, FlowChart_TableX1(SourceForm ,I).ToString)
                    If Temp.X1 = FlowChart_TableX1(SourceForm, I) Then
                        'If MyDebug(A_DISPLAY) ThenLogA(5074, "Y1   " & Temp.Y1, FlowChart_TableY1(SourceForm    , SourceForm    , I).ToString)
                        If Temp.Y1 = FlowChart_TableY1(SourceForm, I) Then
                            'If MyDebug(A_DISPLAY) ThenLogA(5075, "X2   " & Temp._X2_Rotation, FlowChart_tableCoded(SourceForm, I).ToString)
                            If Temp._X2_Rotation = FlowChart_tableCoded(SourceForm, I) Then
                                'If MyDebug(A_DISPLAY) ThenLogA(5076, "Y2   " & Temp._Y2_Option, FlowChart_TableY2(SourceForm ,  I).ToString)
                                If Temp._Y2_Option = FlowChart_TableY2(SourceForm, I) Then
                                    'If MyDebug(A_DISPLAY) ThenLogA(5077, "D.T. " & Temp._DataType, FlowChart_TableDataType(SourceForm , I))
                                    Return True
                                End If
                            End If
                        End If
                    End If
                End If
            End If
        Next I
        Return False
    End Function


    Friend Function AddFlowChartRecordUse(ByRef SourceForm As Source, named As String, coded As String, x1 As Integer, y1 As Integer, Rotation As String, MyDataType As String) As Integer

        '
        If coded <> My_keyWord(My_KeyConstUse) Then
            If MyOptionTest(25) = True Then
            Else
            End If
        End If
        AddFlowChartRecordUse = NewTopOfListBox(SourceForm.ListBoxFlowChart)
        FlowChart_TableCode(SourceForm, AddFlowChartRecordUse, MyKeyword2Number(coded).ToString)
        FlowChart_tablePathSymbolName(SourceForm, AddFlowChartRecordUse, named)

        If MyDebug(A_FMB) Then logA(2900, My.Application.Info.StackTrace)
        FlowChart_TableX1(SourceForm, AddFlowChartRecordUse, x1)
        FlowChart_TableY1(SourceForm, AddFlowChartRecordUse, y1)
        FlowChart_Table_Rotation(SourceForm, AddFlowChartRecordUse, Rotation)
        '    FlowChart_TableDataType(SourceForm , AddFlowChartRecordUse, DataType)
        If FlowChartRecordMatches(SourceForm, AddFlowChartRecordUse, AddFlowChartRecordUse - 1) Then
            logA(5078, MyShowFlowChartRecord(SourceForm, True, AddFlowChartRecordUse), MyShowFlowChartRecord(SourceForm, True, AddFlowChartRecordUse + 1))
            FlowChartDelete(SourceForm, AddFlowChartRecordUse)
        End If

        If MyDebug(A_DISPLAY) Then logA(2902, My.Application.Info.StackTrace)
        FlowChart_TableDataType(SourceForm, AddFlowChartRecordUse, MyDataType) 'The DataType for /Path /Constant  future option for /use
        '''''ShowSorts("FlowChart", ReSortFlowChart(AddFlowChartRecordUse))
        TopOfListBox(SourceForm.ListBoxFlowChart) ' This is to update the top of file, and make the array bigger
        'PaintAll( SourceForm.flowchartpicturebox ,AddFlowChartRecordUse, AddFlowChartRecordUse)
        Return AddFlowChartRecordUse
    End Function



    Friend Function AddFlowChartRecordOther(ByRef SourceForm As Source, named As String, coded As String, x1 As Integer, y1 As Integer, x2 As Integer, y2 As Integer, MyDataType As String) As Integer '

        '
        AddFlowChartRecordOther = NewTopOfListBox(SourceForm.ListBoxFlowChart)
        FlowChart_TableCode(SourceForm, AddFlowChartRecordOther, MyKeyword2Number(coded).ToString)
        'FlowChart_tablePathSymbolName(SourceForm, AddFlowChartRecordOther)=named
        FlowChart_tablePathSymbolName(SourceForm, AddFlowChartRecordOther, named)

        FlowChart_TableX1(SourceForm, AddFlowChartRecordOther, x1)
        FlowChart_TableY1(SourceForm, AddFlowChartRecordOther, y1)
        FlowChart_TableX2(SourceForm, AddFlowChartRecordOther, x2)
        FlowChart_TableY2(SourceForm, AddFlowChartRecordOther, y2)
        FlowChart_TableDataType(SourceForm, AddFlowChartRecordOther, MyDataType) 'The DataType for /Path /Constant
        '''''ShowSorts("FlowChart", ReSortFlowChart(AddFlowChartRecordOther))
        TopOfListBox(SourceForm.ListBoxFlowChart) ' This is to update the top of file, and make the array bigger
        If GetMyRecord(SourceForm.ListBoxFlowChart, AddFlowChartRecordOther) = "" Then
            If MyDebug(A_INFORMATION) Then logA(1353, AddFlowChartRecordOther.ToString, coded)
        End If
        Return AddFlowChartRecordOther
    End Function




    Friend Function InCorrectOrder(a As Integer, b As Integer) As Boolean
        If b < a Then Return True
        If Len(a) = 0 Or Len(b) = 0 Then Return True
        Return False
    End Function


    'bubble sort the array 
    'Which means sorting the index to the array and never changing the array, so that Indexes\indexes stay the same

    Friend Sub MyInsertSymbolPointRecord(ByRef SourceForm As Source, IndexSymbol As Integer, SymbolName As String, Code As String, x1 As Integer, y1 As Integer, IO As String, DT As String, MyNameOfPoint As String)
        Dim MyXY As MyLineStructure
        If MyDebug(A_DISPLAY) Then logA(2783, IndexSymbol.ToString, Code, SymbolName, IO, DT)
        MyXY = Nothing
        If Code <> "/point" Then
            If Code <> "/name" Then
                If Code <> "/error" Then
                    logA(1239, Code, SymbolName, MyNameOfPoint)
                    If MyOptionTest(25) = True Then
                    Else
                    End If
                End If
            End If
        End If
        MyXY.a.x = x1
        MyXY.a.y = y1
        MyXY.b.x = FindInputOutputIndex(IO)
        MyXY.b.y = FindDataTypeIndex(DT)
        InsertSymbolLineRecord(SourceForm, IndexSymbol, MyXY, SymbolName, Code, MyNameOfPoint)
    End Sub


    Friend Sub InsertSymbolLines(ByRef SourceForm As Source, IndexAt As Integer, NumberOfSpaces As Integer)
        Dim IndexTemp, IndexNew As Integer
        If MyDebug(A_INFORMATION) Then logA(2141, (TopOfFile(SourceForm, "Symbol") - IndexAt).ToString)
        IndexNew = NewTopOfFile(SourceForm, "Symbol")
        For IndexTemp = IndexNew To IndexAt + NumberOfSpaces + 1 Step -1
            If MyDebug(A_INFORMATION) Then logA(2142, MyShowSymbolGraphic(False, IndexTemp))
            MySwapSymbolList(SourceForm, IndexTemp, IndexTemp + 1) ' Move it one record in the 'sorted file, because it's Import to keep them in 'order'
        Next
    End Sub

    Friend Sub InsertSymbolListat(ByRef SourceForm As Source, Index As Integer)
        Dim I As Integer
        For I = TopOfFile(SourceForm, "Symbol") + 1 To Index - 1 Step -1
            MySwapSymbolList(SourceForm, I, I + 1)
        Next
        Symbol_TableCode(SourceForm, Index, "/delete")
    End Sub

    Friend Sub InsertSymbolLineRecord(ByRef SourceForm As Source, Index As Integer, XY As MyLineStructure, SymbolName As String, Code As String, MyNameOfPoint As String)
        ', 'Named As String)
        Dim IndexTemp As Integer
        Dim IndexAt As Integer
        Dim T1, T2 As Integer
        If MyDebug(A_DISPLAY) Then
            logA(2810, TopOfFile(SourceForm, "Symbol").ToString, Index.ToString, Code, SymbolName, MyShowALine(XY), MyNameOfPoint)
        End If
        InsertSymbolListat(SourceForm, Index)
        '
        If MyDebug(A_INFORMATION) Then
            If Code = "/name" Then 'hack
                For IndexTemp = 1 To NewTopOfFile(SourceForm, "Symbol") 'hack
                    If IndexTemp <> Index Then
                        If Symbol_TableCoded_String(IndexTemp) = "/name" Then 'hack
                            If Symbol_TableSymbolName(IndexTemp) = SymbolName Then 'hack
                                logA(1240, SymbolName, Index.ToString, Symbol_TableCoded_Byte(Index).ToString, Symbol_TableCoded_String(Index), Symbol_TableSymbolName(Index), IndexTemp.ToString, Symbol_TableCoded_Byte(IndexTemp).ToString, Symbol_TableCoded_String(IndexTemp).ToString, Symbol_TableSymbolName(IndexTemp))
                                If MyOptionTest(25) = True Then
                                Else
                                End If
                                Return ' extra Just ignore the error in the program that is doing this
                            End If
                        End If
                    End If
                Next IndexTemp 'hack
            End If ' extra
        End If
        IndexAt = Index
        If IndexAt = ConstantMyErrorCode Then
            '
            ' special case, it goes at the end of the file
            IndexAt = NewTopOfFile(SourceForm, "Symbol")
            Symbol_TableSymbolName(IndexAt, SymbolName)
            Symbol_TableCode(SourceForm, IndexAt, Code)
            Symbol_TableX1(IndexAt, XY.a.x)
            Symbol_TableY1(IndexAt, XY.a.y)
            Symbol_Table_X2(IndexAt, XY.b.x)
            Symbol_Table_Y2(IndexAt, XY.b.y)
            Symbol_Table_NameOfPoint(IndexAt, MyNameOfPoint)
            logA(1241, MyShowSymbolGraphic(True, IndexAt))
            '''''ShowSorts("Named", MyReSort("Named", 'IndexAt))
            IndexAt = FindInSymbolList(SourceForm, SymbolName) ' Shortcut to Indexes
            '''''ReSortSymbolList()
            If LCase(Code) = "/name" Then
                Return ' so we do not add two name records
            End If
        End If
        If MyDebug(A_INFORMATION) Then logA(2146, IndexAt.ToString, (TopOfFile(SourceForm, "Symbol") - IndexAt).ToString, MyShowSymbolRecord(SourceForm, False, IndexAt - 1), MyShowSymbolRecord(SourceForm, False, IndexAt), MyShowSymbolRecord(SourceForm, False, IndexAt + 1))
        Symbol_TableCode(SourceForm, IndexAt, Code)
        Symbol_TableSymbolName(IndexAt, SymbolName)
        Symbol_Table_NameOfPoint(IndexAt, MyNameOfPoint)
        Symbol_TableX1(IndexAt, XY.a.x)
        Symbol_TableY1(IndexAt, XY.a.y)
        Symbol_TableY1(IndexAt, XY.a.y)
        If Code = "/point" Then
            Symbol_FileX2_io(IndexAt).MyNumber = XY.b.x 'todo need to set my string with value
            Symbol_FileY2_dt(IndexAt).MyNumber = XY.b.y 'ditto
            T1 = XY.b.x
            If T1 >= 0 And T1 <= Options.ListBoxInputOutput.Items.Count - 1 Then
                Symbol_FileX2_io(IndexAt).MyString = MyTrim(Pop(MyTrim(Options.ListBoxInputOutput.Items.Item(XY.b.x).ToString), FD))
            Else
                Symbol_FileX2_io(IndexAt).MyString = ""
            End If
            T2 = XY.b.y
            If MyDebug(A_STATUS) Then logA(2336, Options.ListBoxDataTypes.Items.Count.ToString)
            If T2 >= 0 And T2 <= Options.ListBoxDataTypes.Items.Count Then
                'todo would this be -1 off the Y ??????
                Symbol_FileY2_dt(IndexAt).MyString = Options.ListBoxDataTypes.Items.Item(XY.b.y - 1).ToString
            Else
                'todo need a bug statement here
                Symbol_FileY2_dt(IndexAt).MyString = ""
            End If
        Else
            Symbol_Table_X2(IndexAt, XY.b.x)
            Symbol_Table_Y2(IndexAt, XY.b.y)
        End If
    End Sub



    Friend Sub PaintEachOne(ByRef SourceForm As Source, IndexFlowChart As Integer)
        Dim MyRotationName As String
        Dim MyXY As MyPointStructure = Nothing
        Dim MyXYXY As MyLineStructure = Nothing
        Select Case LCase(FlowChart_TableCode(SourceForm, IndexFlowChart))
            Case "/delete"
                    'MyDrawText( DrawingArea , MyOffset(MyPoint1XY( FlowChart_TableX1(SourceForm ,IndexFlowChart), FlowChart_TableY1(SourceForm    , SourceForm    , IndexFlowChart)), CStr(MyUniverse.OptionDisplay(9).x), CStr(MyUniverse.OptionDisplay(9).y)), FlowChart_TableOther_Name(SourceForm    , IndexFlowChart), 9)
            Case "/error"                    'Error Text
                MyRotationName = FlowChart_TableOther_Name(SourceForm, IndexFlowChart)
                MyRotationName = PopLine(MyRotationName)
                MyRotationName = Mid(MyRotationName, 1, 96)
                If MyOptionTest(9) Then MyDrawText(SourceForm, MyOffset(MyPoint1XY(FlowChart_TableX1(SourceForm, IndexFlowChart), FlowChart_TableY1(SourceForm, IndexFlowChart)), CStr(MyUniverse.OptionDisplay(1).x), CStr(MyUniverse.OptionDisplay(1).y)), MyRotationName, 1)
            Case My_keyWord(My_KeyConstUse) '"/use"
                'If InsideMyFlowChartWorld( DrawingArea  , MyPoint1XY( FlowChart_TableX1(SourceForm ,IndexFlowChart), FlowChart_TableY1(SourceForm    , SourceForm    , IndexFlowChart))) Then
                MyRotationName = FlowChart_Table_Rotation(SourceForm, IndexFlowChart)
                DisplayObject(SourceForm, MyPoint1XY(FlowChart_TableX1(SourceForm, IndexFlowChart), FlowChart_TableY1(SourceForm, IndexFlowChart)), FlowChart_TableSymbol_Name(SourceForm, IndexFlowChart), MyRotationName)
                MyDrawText(SourceForm, MyOffset(MyPoint1XY(FlowChart_TableX1(SourceForm, IndexFlowChart), FlowChart_TableY1(SourceForm, IndexFlowChart)), CStr(MyUniverse.OptionDisplay(2).x), CStr(MyUniverse.OptionDisplay(2).y)), FlowChart_TableDataType(SourceForm, IndexFlowChart), 2)
                'Input-Output
                MyDrawText(SourceForm, MyOffset(MyPoint1XY(FlowChart_TableX1(SourceForm, IndexFlowChart), FlowChart_TableY1(SourceForm, IndexFlowChart)), CStr(MyUniverse.OptionDisplay(10).x), CStr(MyUniverse.OptionDisplay(10).y)), FlowChart_TableSymbol_Name(SourceForm, IndexFlowChart), 10)
                MyDrawBigText(SourceForm, MyOffset(MyPoint1XY(FlowChart_TableX1(SourceForm, IndexFlowChart), FlowChart_TableY1(SourceForm, IndexFlowChart)), CStr(MyUniverse.OptionDisplay(10).x), CStr(MyUniverse.OptionDisplay(10).y)), FlowChart_TableDataType(SourceForm, IndexFlowChart))

                'Path Data Values
                If FlowChart_TableDataType(SourceForm, IndexFlowChart) > 1 Then
                    MyDrawText(SourceForm, MyOffset(MyPoint1XY(FlowChart_TableX1(SourceForm, IndexFlowChart), FlowChart_TableY1(SourceForm, IndexFlowChart)), (MyUniverse.SysGen.Constants.ConstantSymbolCenter * -1).ToString, (-MyUniverse.SysGen.Constants.ConstantSymbolCenter).ToString), Net_TableLinks(IndexFlowChart), 17)
                End If
                If MyOptionTest(32) = True Then
                    MyXY.x = FlowChart_TableX1(SourceForm, IndexFlowChart)
                    MyXY.y = FlowChart_TableY1(SourceForm, IndexFlowChart)
                    MyXY = MyOffset(MyXY, CStr(MyUniverse.OptionDisplay(32).x), CStr(MyUniverse.OptionDisplay(32).y))
                    MyDrawText(SourceForm, MyXY, IndexFlowChart.ToString, 32)
                End If
                    'End If
            Case "/path"
                FixDataType(SourceForm, IndexFlowChart)
                MyDrawLineS_PathS(SourceForm, IndexFlowChart)
                If MyOptionTest(1) = True Then 'path names
                    MyXY.x = CInt((FlowChart_TableX1(SourceForm, IndexFlowChart) + FlowChart_TableX2(SourceForm, IndexFlowChart)) / 2)
                    MyXY.y = CInt((FlowChart_TableY1(SourceForm, IndexFlowChart) + FlowChart_TableY2(SourceForm, IndexFlowChart)) / 2)
                    MyXY = MyOffset(MyXY, CStr(MyUniverse.OptionDisplay(12).x), CStr(MyUniverse.OptionDisplay(12).y))
                    '& FlowChart_TableDataType(SourceForm , IndexFlowChart)
                    MyDrawText(SourceForm, MyXY, FlowChart_TablePathName(SourceForm, IndexFlowChart), 1)
                End If
            Case "/Constant"
                If InsideMyFlowChartWorld(SourceForm, FlowChart_TableX1(SourceForm, IndexFlowChart), FlowChart_TableY1(SourceForm, IndexFlowChart)) Then
                    MyXYXY.a.x = FlowChart_TableX1(SourceForm, IndexFlowChart)
                    MyXYXY.a.y = FlowChart_TableY1(SourceForm, IndexFlowChart) - 2000
                    MyXYXY.b.x = FlowChart_TableX1(SourceForm, IndexFlowChart) + 500
                    MyXYXY.b.y = FlowChart_TableY1(SourceForm, IndexFlowChart) - 2000
                    MyDrawWorldPath(SourceForm, MyXYXY, "String")
                    MyDrawWorldCircle(SourceForm, MyXYXY.a, "RED") ', "String")
                    'MyDrawCross( SourceForm.FlowChartPictureBox , MyPoint1XY( FlowChart_TableX1(SourceForm ,IndexFlowChart), FlowChart_TableY1(SourceForm    , SourceForm    , IndexFlowChart)), FlowChart_TableDataType(SourceForm , IndexFlowChart), FlowChart_TablePathName(SourceForm, IndexFlowChart))
                    MyDrawText(SourceForm,
                                   MyOffset(
                                    MyPoint1XY(FlowChart_TableX1(SourceForm, IndexFlowChart) + 250,
                                               FlowChart_TableY1(SourceForm, IndexFlowChart) - 2000),
                                    CStr(MyUniverse.OptionDisplay(13).x),
                                    CStr(MyUniverse.OptionDisplay(13).y)), FlowChart_Table_Path_SymbolName(SourceForm, IndexFlowChart), 13)
                End If
            Case Nothing
                logA(1103, MyShowFlowChartRecord(SourceForm, True, IndexFlowChart))
            Case "/unknown"
                If MyOptionTest(34) Then
                    PanToWorldXY(SourceForm, FlowChart_TableX1(SourceForm, IndexFlowChart), FlowChart_TableY1(SourceForm, IndexFlowChart))
                    'MarkWorldHere(FlowChart_TableX1(SourceForm ,IndexFlowChart), FlowChart_TableY1(SourceForm    , IndexFlowChart), "Unknown", "RED", 2)
                    'MarkWorldHere(FlowChart_TableX1(SourceForm ,IndexFlowChart), FlowChart_TableY1(SourceForm    , IndexFlowChart), "", "RED", 5)
                End If
            Case "/raw"
                'If MyOptionTest(34) Then
                ' PanToWorldXY( SourceForm.FlowChartPictureBox  , FlowChart_TableX1(SourceForm ,IndexFlowChart), FlowChart_TableY1(SourceForm    , IndexFlowChart))
                ' End If
                MyDrawText(SourceForm, MyOffset(MyPoint1XY(FlowChart_TableX1(SourceForm, IndexFlowChart), FlowChart_TableY1(SourceForm, IndexFlowChart)), CStr(MyUniverse.OptionDisplay(28).x), CStr(MyUniverse.OptionDisplay(28).y)), "@--->" & FlowChart_TableOther_Name(SourceForm, IndexFlowChart), 28)
            Case Else
                'This should never be drawn
                logA(1278, FlowChart_TableCode(SourceForm, IndexFlowChart), MyShowFlowChartRecord(SourceForm, False, IndexFlowChart))
                'MyDrawCircle_At( SourceForm.FlowChartPictureBox  , MyUniverse.MyStaticData.ZeroZero, 0, LCase(Symbol_TableCode(SourceForm ,index)))
        End Select
    End Sub


    Friend Sub PaintEachLibrary(LibraryForm As Library, XYOffSetXY As MyPointStructure, SymbolName As String, RotationName As String)
        MsgBox("HALT The symbols are not being drawn.") 'PaintEachOfthem(SourceForm, XYOffSetXY, SymbolName, RotationName)
    End Sub
    Friend Sub PaintEach(ByRef SourceForm As Source, XYOffSetXY As MyPointStructure, SymbolName As String, RotationName As String)
        PaintEachOfthem(SourceForm, XYOffSetXY, SymbolName, RotationName)
    End Sub

    'Routine Paint ALL Where is the for, (-) is to erase it
    Friend Sub PaintEachOfthem(ByRef SourceForm As Source, XYOffSetXY As MyPointStructure, SymbolName As String, RotationName As String)
        Dim IndexNamed As Integer
        Dim IndexSymbol As Integer
        Dim RotatedXY As MyPointStructure

        If MyDebug(A_STATUS) Then logA(2811, SymbolName, MyShowPoint(XYOffSetXY), RotationName)

        If MyIsNothing(SymbolName) Or SymbolName = "" Then
            Return ' Because this is not a Symbol
        End If
        If ProgramBuzzy("Begin") = True Then Return
        LimitScale()
        MyDrawText(SourceForm, MyOffset(XYOffSetXY, CStr(MyUniverse.OptionDisplay(2).x), CStr(MyUniverse.OptionDisplay(2).y)), SymbolName, 2)

        IndexNamed = BinarySearch4Index(Options.ListBoxSymbols, "NeverAddWhilePainting", SymbolName)
        If IndexNamed = ConstantMyErrorCode Then
            logA(2221, SymbolName)
            Return
        End If

        'Never update the Indexes While painting
        IndexNamed = CheckNotInList("named", SymbolName)
        If IndexNamed = ConstantMyErrorCode Then         ' If found in the named table
            'todo need a bug message here instead
            IndexNamed = IndexNamed 'error cant find error hack
        Else
            'If MyOptionTest(3)=True Then 'stroke
            MyDrawText(SourceForm, MyOffset(XYOffSetXY, CStr(MyUniverse.OptionDisplay(3).x), CStr(MyUniverse.OptionDisplay(3).y)), Named_TableStroke(IndexNamed), 3)
            'End If
            'If MyOptionTest(4)=True Then 'filename
            MyDrawText(SourceForm, MyOffset(XYOffSetXY, CStr(MyUniverse.OptionDisplay(4).x), CStr(MyUniverse.OptionDisplay(4).y)), Named_TableNameOfFile(IndexNamed), 4)
            'End If

            'If MyOptionTest(5)=True Then 'Notes
            MyDrawText(SourceForm, MyOffset(XYOffSetXY, CStr(MyUniverse.OptionDisplay(5).x), CStr(MyUniverse.OptionDisplay(5).y)), Named_TableNotes(IndexNamed), 5)
            'DoEvent(25, "Paint Each")
            'End If

            'If MyOptionTest(6)=True Then ' Opcode
            MyDrawText(SourceForm, MyOffset(XYOffSetXY, CStr(MyUniverse.OptionDisplay(6).x), CStr(MyUniverse.OptionDisplay(6).y)), Named_TableOpCode(IndexNamed), 6)
            'DoEvent(26, "Paint Each")
            'End If

            'If MyOptionTest(7)=True Then ' Program code text
            MyDrawText(SourceForm, MyOffset(XYOffSetXY, CStr(MyUniverse.OptionDisplay(7).x), CStr(MyUniverse.OptionDisplay(7).y)), Named_TableMicroCodeText(IndexNamed), 7)
            'DoEvent(27, "Paint Each")
            'End If
            MyDrawText(SourceForm, MyOffset(XYOffSetXY, CStr(MyUniverse.OptionDisplay(8).x), CStr(MyUniverse.OptionDisplay(8).y)), Named_TableSymbolIndexes(IndexNamed).ToString, 8)
            'DoEvent(29, "Paint Each")
        End If
        IndexSymbol = CorrectingIndexes(SourceForm, SymbolName)
        'IndexSymbol=Named_TableSymbolIndexes(IndexNamed) ' CorrectingIndexes(SourceForm   ,   SymbolName)
        If IndexSymbol < 1 Then ' update the Indexes, if and only if it is pointing to nothing
            Named_TableSymbolIndexes(IndexNamed, CorrectingIndexes(SourceForm, SymbolName))
            IndexSymbol = Named_TableSymbolIndexes(IndexNamed) ' CorrectingIndexes(SourceForm   ,   SymbolName)
        End If

        ' is there no symbol name
        If IndexSymbol > ConstantMyErrorCode Then       ' If there is a name in the named table then
            'is there no symbol name (done twice for the else clause if 0
            If IndexSymbol > 0 Then
                'Test that we never change the name of a symbol and test that this is a wrong symbol
                If Symbol_TableCoded_String(IndexSymbol) <> "/name" Or Symbol_TableSymbolName(IndexSymbol) <> SymbolName Then   ' If the names do note match (error)
                    IndexSymbol = FindInSymbolList(SourceForm, SymbolName) '20200711 '20200629   ' Find the actual location in the Symbol table
                    ' test if found this 'new' symbol name (Which we shouldn't )
                    If IndexSymbol >= 0 Then      ' If there is a name in the Symbol table 
                        Dump2(SourceForm)
                        logA(1243, SymbolName, RotationName, IndexSymbol.ToString, MyShowSymbolGraphic(False, IndexSymbol))
                        If MyOptionTest(25) = True Then
                        Else
                        End If
                        Return ' 20200713 because we have no graphics to show
                    End If
                    'Else
                    '    Index=IndexSymbol          'Shortcut worked here
                Else
                    IndexSymbol = CorrectingIndexes(SourceForm, SymbolName) 'not in the named table (so assumed not in the Symbol table
                End If
            Else
                'This is an named Symbol with no graphics, so it's an error if we ever get here.but fix it for next time?
                IndexSymbol = CorrectingIndexes(SourceForm, SymbolName) 'not in the named table (so assumed not in the Symbol table
                If IndexSymbol > 0 Then
                    Named_TableSymbolIndexes(IndexNamed, IndexSymbol)
                Else
                    logA(1244, SymbolName, IndexNamed.ToString, IndexSymbol.ToString)
                    If MyOptionTest(25) = True Then
                    Else
                    End If
                    IndexNamed = ConstantMyErrorCode          ' Not in the named table.
                End If
            End If
        Else
            logA(1245, SymbolName, RotationName)
            ' index?
        End If


        If IndexSymbol = ConstantMyErrorCode Then 'hack? because we have to exit if there is no graphics for the Symbol
            logA(1246, SymbolName, IndexNamed.ToString, IndexSymbol.ToString)
            Return
        End If
        IndexSymbol += 1 ' after the MyKeyword_2_string(KeyConstName )  for the rest of the Symbol till the next name or end
        While (Symbol_TableCoded_String(IndexSymbol) <> "/name") And (IndexSymbol <= TopOfFile(SourceForm, "Symbol"))
            Select Case LCase(Symbol_TableCoded_String(IndexSymbol))
                Case "/Line" 'Line Start
                    XYOffSetXY.Named.PointName = Symbol_Table_LineColor(IndexSymbol)
                    MyDrawLineWithIndex(SourceForm, IndexSymbol, XYOffSetXY, RotationName)
                Case "/point"
                    RotatedXY = MyRotated_1(IndexSymbol, MyUniverse.MyStaticData.ZeroZero, RotationName)
                    'todo This should be passing the DataType or color name for the point color.
                    'MyDrawCircle_At( SourceForm  , MyPoint1XY( RotatedXY.x + XYOffSetXY.x, RotatedXY.y + XYOffSetXY.y), Symbol_TableSymbolName(IndexSymbol), Symbol_Table_NameOfPoint(IndexSymbol))
                    MyDrawCircle_At(SourceForm, MyPoint1XY(RotatedXY.x + XYOffSetXY.x, RotatedXY.y + XYOffSetXY.y), Symbol_Table_NameOfPoint(IndexSymbol), Symbol_Table_DataType(IndexSymbol))
                    ', Symbol_TableSymbolName(IndexSymbol) , 
                    MyDrawPointArrow(SourceForm, MyRotated_1(IndexSymbol, XYOffSetXY, RotationName), MyRotated_1a(IndexSymbol, RotationName), Symbol_Table_DataType(IndexSymbol), Symbol_Table_X2(IndexSymbol))
                    'MyUnEnum(Symbol_Table_InputOutput(IndexSymbol), Options.ListBoxInputOutput , 1), from above
                    MyDrawText(SourceForm, MyRotated_1(IndexSymbol, MyPoint1XY(XYOffSetXY.x + CInt(MyUniverse.OptionDisplay(1).x), XYOffSetXY.y + CInt(MyUniverse.OptionDisplay(1).x)), RotationName), Symbol_Table_NameOfPoint(IndexSymbol), 21)
                Case "/name"
                    MyDrawText(SourceForm, MyRotated_1(IndexSymbol, MyOffset(XYOffSetXY, CStr(MyUniverse.OptionDisplay(2).x), CStr(MyUniverse.OptionDisplay(2).y)), RotationName), Symbol_TableSymbolName(IndexSymbol), 2)
                Case "/delete"
                        'MyDrawCircle_At( SourceForm  , MyUniverse.MyStaticData.ZeroZero, "red", LCase(Symbol_Table_NameOfPoint(IndexSymbol)))
                Case "/error"
                    'Why am I calling (11) this display ?
                    MyDrawText(SourceForm, MyRotated_1(IndexSymbol, MyPoint1XY(XYOffSetXY.x + CInt(MyUniverse.OptionDisplay(11).x), XYOffSetXY.y + CInt(MyUniverse.OptionDisplay(11).y)), RotationName), Symbol_TableSymbolName(IndexSymbol), 11)
                    MyDrawText(SourceForm, MyOffset(XYOffSetXY, CStr(MyUniverse.OptionDisplay(2).x), CStr(MyUniverse.OptionDisplay(2).y)), SymbolName, 2)
                    MyDrawCircle_At(SourceForm, XYOffSetXY, "red", LCase(Symbol_TableSymbolName(IndexSymbol)))
                    MyDrawCircle_At(SourceForm, XYOffSetXY, "red", LCase(Symbol_Table_NameOfPoint(IndexSymbol)))
                Case Else
                    logA(2107, IndexSymbol.ToString, MyShowSymbolRecord(SourceForm, False, IndexSymbol))
                    MyDrawCircle_At(SourceForm, MyUniverse.MyStaticData.ZeroZero, "red", Symbol_TableCoded_String(IndexSymbol))
                    Return
            End Select
            IndexSymbol += 1
        End While
        'DoEvent(155)
    End Sub

    Friend Sub PaintErase(ByRef SourceForm As Source, Index As Integer)
        MyUniverse.MyMouseAndDrawing.PaintThisOrEraseThis = False
        If MyDebug(A_FMB) Then logA(2812, Index.ToString, SourceForm.Parent.Name)
        Select Case LCase(SourceForm.Parent.Name)
            Case "FlowChartWindow"
                PaintAll(SourceForm, Index, Index)
            Case "SymbolWindow"
                PaintEach(SourceForm, MyUniverse.MyStaticData.ZeroZero, MyUniverse.ProgramOptions.SelectedSymbolName, "default")
            Case Else
                logA(2066, SourceForm.Parent.Name)
        End Select
        MyUniverse.MyMouseAndDrawing.PaintThisOrEraseThis = True
    End Sub



    'Routine Paint ALL Where is the for, (-) is to erase it
    '
    Friend Sub PaintAll(ByRef SourceForm As Source, Start As Integer, Ending As Integer)
        Dim IndexFlowChart As Integer
        Dim Centerline As MyLineStructure = Nothing
        Dim LastPainting As String = ""
        If MyUniverse.MyProgramStatus = "Painting" And Start = 1 And Ending = TopOfListBox(SourceForm.ListBoxFlowChart) Then
            Return
        End If
        If MyUniverse.Paint = False And Ending - Start > 4 Then
            Return
        End If
        If MyUniverse.MyProgramStatus <> "Painting" Then
            LastPainting = MyUniverse.MyProgramStatus
        End If
        MyUniverse.MyProgramStatus = "Painting"

        Centerline.a.x = CInt(SourceForm.FlowChartPictureBox.Width / 2)
        Centerline.a.y = CInt(SourceForm.FlowChartPictureBox.Height / 2)
        Centerline.b.x = 0
        Centerline.b.y = 0
        Centerline.a.Named.IsWorldWindow = WorldOrWindow(Centerline.a)
        Centerline.b.Named.IsWorldWindow = WorldOrWindow(Centerline.b)
        Centerline.b = Copy2WindowXY(SourceForm, Centerline.b)

        'this draw a light green line to the 0,0 (So when you get lost it will show you the way back to the top
        'todo should limit it to only pan to with in the limits of the current flowchart limits
        SourceForm.FlowChartPictureBox.CreateGraphics.DrawLine(Pens.LightGreen, Centerline.a.x, Centerline.a.y, Centerline.b.x, Centerline.b.y)

        MyUniverse.MyStaticData.Painting.Start = Start
        MyUniverse.MyStaticData.Painting.Ending = Ending
        'DoEvent(30, "Paint All")
        If FMBRecurse("PaintAll") > 8 Then Return
        If CountStackI(3) > 200 Then Return
        If Ending < Start Then Return 'nothing to paint
        'DoEvent(31, "Paint All")
        If MyDebug(A_STATUS) Then logA(2433, Start.ToString, Ending.ToString)
        If ProgramBuzzy("Begin") Then Return
        If FMBRecurse("PaintAll") > 5 Then Return
        LimitScale()
        If MyDebug(A_STATUS) Then logA(2764, MyShowScale())
        Start = MyMinMax(Start, 1, TopOfListBox(SourceForm.ListBoxFlowChart))
        Ending = MyMinMax(Ending, Start, TopOfListBox(SourceForm.ListBoxFlowChart))
        ''''''ShowAllWindows(ShowWindow, LeaveWindow, LeaveWindow, LeaveWindow)
        If ProgramBuzzy("Buzzy") Then Return
        '''''SetWindowArea()
        MyUniverse.MyProgramStatus = "Painting"
        'todo need to also paint everything that crosses the window ie paint from left - centerSymbolDistance
        For IndexFlowChart = Start To Ending
            'if MyDebug(a_information) then log_X ( 2695,MyShowFlowChartRecord(SourceForm, False, IndexFlowChart))
            '''''ShowProgressBar(Start, IndexFlowChart, Ending)
            If IndexFlowChart = Int(IndexFlowChart / 500) * 100 Then
                DisplayStatus(3218, IndexFlowChart.ToString)
                'DoEvent(156)
            End If
            PaintEachOne(SourceForm, IndexFlowChart)
        Next
        If MyDebug(A_STATUS) Then logA(2434, Start.ToString, Ending.ToString)
        If LastPainting = "Painting" Then
            MyUniverse.MyProgramStatus = "Alive"
        Else
            MyUniverse.MyProgramStatus = LastPainting
        End If
    End Sub ' end of PaintAll()

    Friend Function InsertCameFromLine(ByRef KeyLine As String, IndexForInsert As Integer, SubLine As Integer) As Integer ' returns the number of characters it added to the string
        Dim Temp As String
        Dim K As Integer
        If MyDebug(A_FMB) Then logA(2816, KeyLine)
        K = Len(KeyLine)
        If SubLine = 0 Then
            Temp = MyUniverse.ProgramOptions.FCCL_WhiteSpace
        Else
            Temp = "_" & Trim(Str(SubLine)) & MyUniverse.ProgramOptions.FCCL_WhiteSpace
        End If
        If IndexForInsert = 1 Then
            KeyLine = MyUniverse.SysGen.Markers.CameFromLine & Temp & MyUniverse.ProgramOptions.FCCL_WhiteSpace & MyUniverse.ProgramOptions.FCCL_MultiLine & MyUniverse.ProgramOptions.FCCL_WhiteSpace & MyUniverse.ProgramOptions.FCCL_WhiteSpace & Mid(KeyLine, IndexForInsert, Len(KeyLine)) '2020 08 20 added space between 
        Else
            KeyLine = Mid(KeyLine, 1, IndexForInsert) & MyUniverse.SysGen.Markers.CameFromLine & Temp & MyUniverse.ProgramOptions.FCCL_WhiteSpace & MyUniverse.ProgramOptions.FCCL_MultiLine & MyUniverse.ProgramOptions.FCCL_WhiteSpace & MyUniverse.ProgramOptions.FCCL_WhiteSpace & Mid(KeyLine, IndexForInsert, Len(KeyLine))
        End If
        Return Len(KeyLine) - K ' cause we always add something
    End Function



    Friend Function AddComeGo(CodeLine As String) As String
        If CodeLine = "" Then Return ""
        'todo need to test if GoTo/CameFrom label already part of the syntax
        Return MyUniverse.SysGen.Markers.CameFromLine &
                MyUniverse.ProgramOptions.FCCL_WhiteSpace &
"Address_" & (MyUniverse.MySS.Inputs.LineNumberIn - 1).ToString &
".PathName" & ":  " & vbCrLf &
                CodeLine & vbCrLf &
                MyUniverse.SysGen.Markers.BranchToNextLine &
                MyUniverse.ProgramOptions.FCCL_WhiteSpace &
                AddRM("Address_" & MyUniverse.MySS.Inputs.LineNumberIn & ".PathName")
    End Function




    Friend Function InsertBranchToNextLine(ByRef KeyLine As String, IndexForInsert As Integer, SubLine As Integer) As Integer 'return the number characters it added to the string
        Dim Temp As String
        Dim K As Integer
        If MyDebug(A_FMB) Then logA(2818, KeyLine)

        K = Len(KeyLine)
        If SubLine = 0 Then
            Temp = MyUniverse.ProgramOptions.FCCL_WhiteSpace
        Else
            Temp = "_" & Trim(Str(SubLine)) & MyUniverse.ProgramOptions.FCCL_WhiteSpace

        End If
        If IndexForInsert >= Len(KeyLine) Then
            KeyLine = KeyLine &
    MyUniverse.ProgramOptions.FCCL_WhiteSpace &
    MyUniverse.ProgramOptions.FCCL_MultiLine &
    MyUniverse.ProgramOptions.FCCL_WhiteSpace &
    MyUniverse.SysGen.Markers.BranchToNextLine &
        MyUniverse.ProgramOptions.FCCL_WhiteSpace &
Temp
        Else
            KeyLine = Mid(KeyLine, 1, IndexForInsert - 1) &
    MyUniverse.ProgramOptions.FCCL_WhiteSpace &
    MyUniverse.ProgramOptions.FCCL_MultiLine &
    MyUniverse.ProgramOptions.FCCL_WhiteSpace &
    MyUniverse.SysGen.Markers.BranchToNextLine &
    MyUniverse.ProgramOptions.FCCL_WhiteSpace &
    Temp &
    MyUniverse.ProgramOptions.FCCL_WhiteSpace &
    Mid(KeyLine, IndexForInsert, Len(KeyLine))
        End If
        Return Len(KeyLine) - K
    End Function



    Friend Function Spaced(Too As Integer, What As String) As String
        'todo need to make sure that len(what is less than Too)
        If Len(What) >= Too Then
            Return Mid(What, 1, Too - 1) & "#" 'todo this is a bug (should self correct to make this wider
        Else
            Return What & Space(Too - Len(What))
        End If
    End Function



    Friend Function NoWhiteSpaceS(ByRef SourceForm As Source, S As String) As String ' Remove all white space to return just a character string (For Filenames etc)
        Dim I, j As Integer
        Dim T As String
        T = S
        For j = 1 To Len(S)
            For I = 1 To Len(MyUniverse.SysGen.Constants.ConstantDelimiters & MyUniverse.SysGen.Constants.ConstantSpecialCharacters)
                If Mid(S, j, 1) = Mid(MyUniverse.SysGen.Constants.ConstantDelimiters & MyUniverse.SysGen.Constants.ConstantSpecialCharacters, I, 1) Then
                    Mid(T, j, 1) = MyUniverse.ProgramOptions.FCCL_WhiteSpace
                End If
            Next I
        Next j

        NoWhiteSpaceS = ""
        For j = 1 To Len(Trim(T))
            If Mid(T, j, 1) <> MyUniverse.ProgramOptions.FCCL_WhiteSpace Then NoWhiteSpaceS &= Mid(T, j, 1)
        Next j


        'hack OK, why am I removing the digits again? (Boy it is hard getting old and forgetful)
        While Do_Not_Use_IsThisANumber(SourceForm, MyLeft(NoWhiteSpaceS & "a", 1))
            NoWhiteSpaceS = Mid(NoWhiteSpaceS, 2, Len(NoWhiteSpaceS))
        End While
    End Function








    'Routine This returns and removes the till the first 'white' space
    ' and returns the string without the whitespace delimiters
    Friend Function Pop(ByRef A As String, Delimiters As String) As String ' Returns the first "word" and never the seperating 
        Dim at1 As Integer
        Dim Temp As String ' Used to check for -+*? after literal in /grammars
        If Do_Not_Use_IsThisALiteral(A) Then
            Temp = Pop_Literal(A)
            If MyLeft(A, 1) = "-" Or MyLeft(A, 1) = "+" Or MyLeft(A, 1) = "*" Or MyLeft(A, 1) = "?" Then
                Temp &= MyLeft(A, 1)
                A = Mid(A, 2)
                Return Temp
            End If
            If MyRight(A, 1) = "-" Or MyRight(A, 1) = "+" Or MyRight(A, 1) = "*" Or MyRight(A, 1) = "?" Then
                Temp &= MyRight(A, 1)
                A = Mid(A, 2)
                Return Temp
            End If
            Return Temp
        End If
        Pop = A
        at1 = MyFirstOne(Pop, Delimiters)
        If at1 > 0 Then
            Pop = Mid(A, 1, at1)
            A = Mid(A, at1 + 1, Len(A))
        Else
            Pop = A
            A = ""
        End If
        Return MyTrim(Pop)
    End Function

    Friend Function PopQuote(ByRef A As String) As String

        If MyLeft(A, Len(MyUniverse.SysGen.Markers.Quotes)) = MyUniverse.SysGen.Markers.Quotes Then
            A = Mid(A, Len(MyUniverse.SysGen.Markers.Quotes) + 1, Len(A))
            Return MyUniverse.SysGen.Constants.ConstantQuote
        End If
        PopQuote = MyLeft(A, 1) 'First quote
        A = Mid(A, 2, Len(A))
        While MyLeft(A, 1) <> Chr(34) And Len(A) > 0
            PopQuote &= MyLeft(A, 1)
            A = Mid(A, 2, Len(A))
            If MyInStr(Chr(34), A) <> 0 Then
                Return MyUniverse.SysGen.Constants.ConstantQuote
            End If
        End While
        ' Save The Last Quote also
        'todo is this necessary '''PopQuote &= MyLeft(A, 1)
        A = Mid(A, 2, Len(A))
        Return MyUniverse.SysGen.Constants.ConstantQuote
    End Function



    'Routine This returns and removes the till the first 'white' space
    Friend Function Pop1(ByRef SourceForm As Source, ByRef A As String, Delimiters As String) As String ' Pop the first parsed "word" or special character (See Pop)
        Dim X As String
        If Do_Not_Use_IsThisAMarker(SourceForm, A) <> "" Then
            X = MyTrim(Do_Not_Use_IsThisAMarker(SourceForm, A))
            A = Mid(A, Len(X) + 1, Len(Trim(A))) 'todo trim this ? 
            Return X
        End If

        ' This needs to be changed so that we find where the trim is, and then move the string only once, because this way is VERY slow.
        X = ""
        While MyInStr(MyLeft(A, 1), Delimiters) = 0 And Len(A) > 0
            X &= MyLeft(A, 1)
            A = Mid(A, 2, Len(A))
        End While
        If X <> "" Then
            Pop1 = X
        Else
            X = MyLeft(A, 1) ' first character is a delimiters character
            A = Mid(A, 2, Len(A))
            Pop1 = X
        End If
        A = Trim(A) ' Do not get rid of the character that stopped the pop
        If Len(Pop1) = 0 And Len(A) <> 0 Then
            Pop1 = MyLeft(A, 1)
            A = Mid(Pop1, 2, Len(A))
        End If
        Pop1 = Trim(Pop1)
    End Function


    Friend Function ReturnPathName(ByRef SourceForm As Source, VariableNumber As Integer, Names As String) As String
        Dim i As Integer
        Dim t As String
        i = 0
        t = NoFD(Names)
        If VariableNumber = 0 Then
            Return MakeNewName(SourceForm, "NoName_A_", "")
        End If

        While Len(t) > 0
            i += 1
            If i = VariableNumber Then
                If Len(t) = 0 Then
                    logA(1354, VariableNumber.ToString, Names)
                End If
                Return Pop(t, FD)
            End If
            NoFD(Pop(t, FD)) ' show what is being counter as a variable
        End While
        Return MakeNewName(SourceForm, "NoNamePath" & Names & VariableNumber.ToString, Names)
    End Function

    Friend Function CountPathNames(ByRef SourceForm As Source, names As String) As Integer
        Dim i As Integer
        Dim t As String

        t = names
        i = 0
        t = PopLine(t)
        t = NoFD(t)
        While Len(t) > 0
            i += 1
            t = NoFD(t)
            Pop(t, FD)
        End While
        Return i
    End Function


    Friend Function FirstEqualsFirst(ByRef SourceForm As Source, CodeLine As String, B_N_F As String) As String
        Dim A, B, C, D, bnf As String

        bnf = Trim(Mid(B_N_F, MyInStr("::=", B_N_F & "::=") + 3, Len(B_N_F)))
        If CodeLine = bnf Then Return AddRM(bnf & ".BNF")
        If Do_Not_Use_IsThisAKeyWord(SourceForm, bnf) Then Return bnf
        'todo need to return if bnf is a '?' character, '?-?' character range, or '??' keyword-string
        If Len(bnf) = 3 Then
            If Do_Not_Use_IsThisALiteral(bnf) Then
                'If MyLeft(bnf, 1)="'" Then
                'If MyRight(bnf, 1)="'" Then
                If MyLeft(CodeLine, 1) = Mid(bnf, 2, 1) Then Return MyLeft(CodeLine, 1)
                '    End If
            End If
        End If
        A = Trim(CodeLine)
        B = Trim(bnf)
        If MyTrim(A) = MyTrim(B) Then Return AddRM(B & ".BNF")
        C = Pop(A, MyUniverse.SysGen.Constants.ConstantDelimiters)
        D = Pop(B, MyUniverse.SysGen.Constants.ConstantDelimiters)
        C = NoBlock(C)
        D = NoBlock(D)
        If C = D Then Return AddRM(D & ".BNF")
        If Do_Not_Use_IsThisALiteral(D) Then 'MyLeft(D, 1)="'" And MyRight(D, 1)="'" And Len(D) > 1 Then
            If FirstEqualsFirst(SourceForm, C, D) <> "" Then Return AddRM(D & ".BNF")
            If FirstEqualsFirst(SourceForm, A, D) <> "" Then Return AddRM(D & ".BNF")
        End If
        Return "" ' no match
    End Function


    Friend Function InsideRange(MyString As String, HexRange As String) As Boolean
        Dim A, B As String
        Dim I, J, K As Integer
        J = MyInStr("-", HexRange)
        I = 2
        K = J + 1
        A = Mid(HexRange, I, J - 2)
        A = TrimOff(Fix0X(A), "'")
        If MyInStr("0X", A) <> 0 Then
            A = ChrW(CInt(Hex2Bin(A)))
        End If
        B = Mid(HexRange, K)
        B = TrimOff(B, "'")
        If MyInStr("0X", B) <> 0 Then
            B = ChrW(Hex2Bin(B)).ToString
        End If
        If Len(A) <> 1 Or Len(B) <> 1 Then Return False
        If MyDebug(A_DISPLAY) Then logA(1584, AscW(A).ToString, AscW(MyString).ToString, AscW(B).ToString)
        If AscW(MyLeft(MyString, 1)) >= AscW(A) Then
            If AscW(MyLeft(MyString, 1)) <= AscW(B) Then
                Return True
            End If
        End If
        Return False
    End Function


    Friend Function MatchesGrammarSyntax(ByRef SourceForm As Source, ByRef CodeLine As String, ByRef GrammarRule As String) As String
        Dim A, B, C, D, E, F As String
        If Len(Trim(CodeLine)) = 0 Or Len(Trim(GrammarRule)) = 0 Then
            If MyDebug(A_DISPLAY) Then logA(1585, CodeLine, GrammarRule)
            Return "" 'needs more, or has more 
        End If
        A = CodeLine
        F = GrammarRule
        If MyInStr("::=", F) <> 0 Then
            D = MyTrim(Mid(F, 1, MyInStr("::=", F) - 1))
            F = MyTrim(Mid(F, MyInStr("::=", F) + 3))
        Else
            D = ""
        End If
        B = Pop_What(SourceForm, A) 'get first whatever
        E = Pop_What(SourceForm, F) ' get first whatever
        C = MyLeft(F, 1)
        If E = D Then
            logA(1575, E, D)
            Return ""
        End If
        If GetGrammarRuleName(SourceForm, D) <> "" Then
            If C = "?" Or C = "*" Or C = "+" Or C = "-" Then
                If MyDebug(A_DISPLAY) Then logA(1586, C, D)
                E &= C
                F = Mid(F, 2)
            End If
        End If
        'testing if code 'word' equals grammar rule phrase
        If MyDebug(A_DISPLAY) Then logA(1528, CodeLine, GrammarRule, B, E)

        If GetGrammarRuleName(SourceForm, E) <> "" Then
            If MatchesGrammarSyntax(SourceForm, B, GetGrammarRuleName(SourceForm, E)) <> "" Then
                Return MyUniverse.SysGen.Constants.RMStart & E & "." & B & MyUniverse.SysGen.Constants.RMEnd
            End If
        ElseIf Do_Not_Use_IsThisAHexDigitRange(E) Then
            If MyDebug(A_DISPLAY) Then logA(1576, B, E)
            If InsideRange(B, E) Then
                Return MyLeft(B, 1)
            Else
                Return ""
            End If
        ElseIf Do_Not_Use_IsThisALiteral(E) Then
            If MyDebug(A_DISPLAY) Then logA(1578, B, E)
            If MatchesGrammarSyntax(SourceForm, B, TrimOff(E, "'")) <> "" Then
                Return MyUniverse.SysGen.Constants.RMStart & E & "." & B & MyUniverse.SysGen.Constants.RMEnd
            Else
                Return "" ' no match
            End If
        ElseIf B = E Then 'return marker of rule name and literal 
            logA(1579, B, E)
            Return MyUniverse.SysGen.Constants.RMStart & TrimOff(E, "'") & "." & B & MyUniverse.SysGen.Constants.RMEnd
        ElseIf E = Mid(B, 1, Len(E)) Then
            logA(1580, B, E)
            Return MyUniverse.SysGen.Constants.RMStart & TrimOff(E, "'") & "." & Mid(B, 1, Len(E)) & MyUniverse.SysGen.Constants.RMEnd
        Else
            Return "" ' no match
        End If
        'C=B
        'D=E
        Return "" ' does not match somewhere
    End Function



    Friend Function FindGrammarMatch(ByRef SourceForm As Source, CodeLine As String, CurrentString As String, Grammar As String) As String
        Dim I As Integer
        Dim A, B, C, D, E, F, GrammarLine As String
        Dim debugLevel As Integer = A_DISPLAY
        If CurrentString = "" Then Return CodeLine
        For I = 1 To TopOfFile(SourceForm, "Grammar")
            '''''ShowProgressBar(1, I, TopOfFile(SourceForm,  "grammar"))
            A = Language_Grammar(I)
            B = CurrentString
            If MyDebug(debugLevel) Then logA(1572, B, A)
            GrammarLine = MatchesGrammarSyntax(SourceForm, CurrentString, Language_Grammar(I))
            If GrammarLine <> "" Then
                If MyDebug(debugLevel) Then logA(1529, CurrentString, Language_Grammar(I), GrammarLine)
                ' we have the start of a match, so go to the next phrase 
                If MyDebug(debugLevel) Then logA(1530, A, B)
                C = B
                F = MyTrim(Pop_What(SourceForm, C))
                D = A
                D = Pop(D, VBSpace & vbTab & vbCrLf)
                E = MatchesGrammarSyntax(SourceForm, C, D)
                If MyDebug(A_DISPLAY) Then logA(1573, A, B, C, D, E)
                If E = "" Then
                    Return ""
                End If
            End If
        Next I
        Return "?"
    End Function

    Friend Function FindSymbolGrammar(ByRef SourceForm As Source, Keyline As String) As String
        Dim G, S, T As String
        'S is the original, T= left un matched, G is the grammar so Far
        S = Keyline
        T = S
        G = ""
        FindSymbolGrammar = FindGrammarMatch(SourceForm, S, T, G)
        If MyDebug(A_DISPLAY) Then logA(1608, S, T, G, FindSymbolGrammar)
    End Function
    Friend Function FindGrammarRoot(ByRef SourceForm As Source, SpecialCharacter As String) As String
        Dim I, J As Integer
        Dim A, B, C, D As String
        FindGrammarRoot = ""
        A = SpecialCharacter
        For I = 1 To TopOfFile(SourceForm, "Grammar")                                       'loop through all of the grammars
            '''''ShowProgressBar(1, I, TopOfFile(SourceForm,  "Grammar"))
            B = Language_Grammar(I)                                             'cause I'm to lazy to type
            If MyInStr("'" & A & "'", B) <> 0 Then                 'looking for this defination
                J = MyInStr("::=", B)                                             ' make sure it has a defined 
                If J <> 0 Then
                    C = Mid(B, J + 3)                                           ' get the name of the grammar rule

                    D = FirstEqualsFirst(SourceForm, A, B) ' This should tell if it matches so far
                    If D <> "" Then
                        FindGrammarRoot &= FD & A
                        Return FindGrammarRoot
                    End If
                End If
            End If
        Next
        Return AddRM("'" & A & "'")
    End Function


    'recursive
    Friend Function FindGrammarFromCode(ByRef SourceForm As Source, Code_Line As String, IsAtCharacter As Integer) As String
        Dim A, B, D As String  'C, 
        Dim I, J As Integer

        FindGrammarFromCode = ""
        A = Mid(Code_Line, IsAtCharacter) ' get what it is so far
        For I = 1 To TopOfFile(SourceForm, "Grammar")
            '''''ShowProgressBar(1, I, TopOfFile(SourceForm,  "Grammar"))
            B = Language_Grammar(I)
            J = MyInStr("::=", B)
            If J <> 0 Then
                D = FirstEqualsFirst(SourceForm, A, B) ' This should tell if it matches so far
                If D <> "" Then
                    FindGrammarFromCode &= FD & A
                    Return FindGrammarFromCode
                End If
            End If
        Next
        Return ""
    End Function


    '
    ' This separates the string into parts.
    'see  WhatIsThis()
    'Basally it is parsed by trying to find 
    '   first keyWord, Operator, and other known inputs
    '   second then variable name

    Friend Function Do_Not_Use_IsThisALiteral(CodeLine As String) As Boolean
        If MyLeft(CodeLine, 1) <> "'" Then Return False
        If MyInStr("'", Mid(CodeLine, 2, Len(CodeLine))) <> 0 Then Return True
        Return False
    End Function


    'Test if imbedded mark
    Friend Function Do_Not_Use_IsThisABranchToNextLine(CodeLine As String) As Boolean
        If MyLeft(Trim(CodeLine), Len(MyUniverse.SysGen.Markers.BranchToNextLine)) = MyUniverse.SysGen.Markers.BranchToNextLine Then
            Return True
        End If
        Return False
    End Function

    'Test if imbedded mark
    Friend Function Do_Not_Use_IsThisACameFromLine(CodeLine As String) As Boolean
        If MyLeft(Trim(CodeLine), Len(MyUniverse.SysGen.Markers.CameFromLine)) = MyUniverse.SysGen.Markers.CameFromLine Then
            Return True
        End If
        Return False
    End Function


    Friend Sub SetNameOfPoint(ByRef XY As MyPointStructure, Optional PointName As String = "", Optional SymbolName As String = "", Optional PathName As String = "")
        XY.Named.PointName = PointName
        XY.Named.SymbolName = SymbolName
        XY.Named.PathName = PathName
        XY.Named.IsWorldWindow = WorldOrWindow(XY)
    End Sub

    Friend Function NameOfPointOnly(A As String) As String
        Dim B As String
        Dim I1, I2, I3, I4 As Integer
        B = A
        If B = "" Then Return B
        I1 = MyInStr(".", B)
        I2 = MyInStr(MyUniverse.SysGen.Constants.RMStart, B)
        I3 = MyInStr(MyUniverse.SysGen.Constants.RMEnd, B)
        I4 = Len(MyUniverse.SysGen.Constants.RMStart)

        If I1 <> 0 And I2 <> 0 And I3 <> 0 Then
            If I1 > 0 And I2 > 0 And I3 > 0 And I1 - I4 - I2 > 0 Then
                If I2 + I4 > 0 And (I1 - I4 - I2) > 0 Then
                    Return Mid(B, I2 + I4, I1 - I4 - I2)
                End If
            End If
            If MyDebug(A_ERROR) Then
                logA(2635, (I2 + I4).ToString, (I1 - I4 - I2).ToString, Len(B).ToString, A)
            End If
        End If
        Return NoFD(NoRM(A))
    End Function


    Friend Function RemoveOne(A As String) As String
        Return Mid(A, 2, Len(A))
    End Function


    Friend Function AddRM(A As String) As String
        Dim x, y As String
        x = MyUniverse.SysGen.Constants.RMStart
        y = MyUniverse.SysGen.Constants.RMEnd
        If MyLeft(A, Len(x)) = x And MyRight(A, Len(y)) = y Then Return A ' don't add if already a marker
        Return MyUniverse.SysGen.Constants.RMStart & A & MyUniverse.SysGen.Constants.RMEnd
    End Function


    Friend Function NoFDs(A As String) As String
        Dim B As String
        B = A
        B = NoFD(Trim(B))
        While B <> NoFD(Trim(B))
            B = NoFD(Trim(B))
        End While
        Return B
    End Function



    Friend Function NoFD(A As String) As String
        NoFD = TrimOff(A, FD)
        'NoFD = TrimOff(NoFD, COMMA)
        Return NoFD
    End Function

    Friend Function NoFD_or_Space(A As String) As String
        NoFD_or_Space = A
        NoFD_or_Space = NoFD_or_Space.Replace(FD, "")
        NoFD_or_Space = NoFD_or_Space.Replace(" ", "")
    End Function


    Friend Function NoRM(A As String) As String
        If MyIsNothing(A) Then Return ""
        NoRM = TrimOff(A, MyUniverse.SysGen.Constants.RMStart)
        NoRM = TrimOff(NoRM, MyUniverse.SysGen.Constants.RMEnd)
    End Function


    Friend Function Pop_What_2(What As String, ByRef CodeLine As String) As String
        Dim RTN As String
        RTN = MyLeft(CodeLine, Len(What))
        If RTN = What Then
            CodeLine = Mid(CodeLine, Len(What) + 1)
            Return RTN
        End If
        Return ""
    End Function




    ' checks if this is just a part
    Friend Function IsThisAWhat_2(What As String, CodeLine As String) As Boolean
        If Len(What) = 0 Then Return False
        If MyLeft(CodeLine, Len(What)) = What Then
            Return True
        End If
        Return False
    End Function


    Friend Function Pop_Attribute(ByRef Marker As String) As String
        If MyInStr(".", Marker) = 0 Then Return ""
        Return Mid(Marker, MyInStr(".", Marker), Len(Marker))
    End Function

    Friend Function Pop_What(ByRef SourceForm As Source, ByRef CodeLine As String) As String
        If Do_Not_Use_IsThisAMarker(SourceForm, CodeLine) <> "" Then Return Pop_Marker(CodeLine)
        If Do_Not_Use_IsThisAMarker2(SourceForm, CodeLine) <> "" Then Return Pop_Marker2(CodeLine)
        If IsThisAWhiteSpace(CodeLine) <> "" Then Return Pop_WhiteSpace(SourceForm, CodeLine)
        If Do_Not_Use_IsThisABranchToNextLine(CodeLine) Then Return Pop_BranchToNextLine(CodeLine)
        If Do_Not_Use_IsThisACameFromLine(CodeLine) Then Return Pop_CameFromLine(CodeLine)
        If Do_Not_Use_IsThisAComment(CodeLine) Then Return Pop_Comment(CodeLine)
        If Do_Not_Use_IsThisAKeyWord(SourceForm, CodeLine) Then Return Pop_KeyWord(CodeLine)
        '''''If Do_Not_Use_IsThisA_Function(CodeLine) Then Return Pop_Function(CodeLine)
        '''''If IsThisAnOperator(CodeLine) > 0 Then Return Pop_Operator(CodeLine)
        If IsThisAGrammarRule(CodeLine) <> "" Then Return IsThisAGrammarRule(CodeLine)
        If IsthisADataType(CodeLine) <> "" Then Return IsthisADataType(CodeLine)
        If Do_Not_Use_IsThisALiteral(CodeLine) Then Return Pop_Literal(CodeLine)
        If Do_Not_Use_IsThisAQuote(CodeLine) Then Return Pop_Quote(CodeLine)
        If Do_Not_Use_IsThisAVariableNameX(SourceForm, CodeLine) Then Return Pop_VariableName(SourceForm, CodeLine)
        '''''If  Do_Not_Use_IsThisAVariableName(CodeLine) Then Return Pop_VariableName(SourceForm, CodeLine)
        If Do_Not_Use_IsThisANumber(SourceForm, CodeLine) Then Return Pop_Number(SourceForm, CodeLine)
        If Do_Not_Use_IsThisAnAlpha(SourceForm, CodeLine) Then Return Pop_Alpha(CodeLine)
        If IsThisAWhat_2(CodeLine, MyUniverse.ProgramOptions.FCCL_MultiLine) Then Return Pop_What_2(CodeLine, MyUniverse.ProgramOptions.FCCL_MultiLine)
        If IsThisAWhat_2(CodeLine, Options.ListBoxSymbolData.Items.Item(21).ToString) Then Return Pop_What_2(CodeLine, Options.ListBoxSymbolData.Items.Item(21).ToString)
        If IsThisAWhat_2(CodeLine, Options.ListBoxSymbolData.Items.Item(25).ToString) Then Return Pop_What_2(CodeLine, Options.ListBoxSymbolData.Items.Item(25).ToString)
        If IsThisAWhat_2(CodeLine, MyUniverse.SysGen.Markers.BranchToNextLine) Then Return Pop_What_2(CodeLine, MyUniverse.SysGen.Markers.BranchToNextLine)
        If Do_Not_Use_IsThisAMarker2(SourceForm, CodeLine) <> "" Then Return Do_Not_Use_IsThisAMarker2(SourceForm, CodeLine)
        If IsThisAWhat_2(CodeLine, FD) Then Return Pop_What_2(CodeLine, FD)
        If Do_Not_Use_IsThisASpecialCharacter(SourceForm, CodeLine) Then Return Pop_SpecialCharacter(SourceForm, CodeLine)
        If Do_Not_Use_IsThisAGrammarTerminal(SourceForm, CodeLine) <> "" Then Return Do_Not_Use_IsThisAGrammarTerminal(SourceForm, CodeLine)
        If Do_Not_Use_IsThisAHexDigit(CodeLine) Then Return Pop_HexDigit(CodeLine)
        If Do_Not_Use_IsThisAHexDigitRange(CodeLine) Then Return Pop_HexDigitRange(CodeLine)
        If Do_Not_Use_IsThisALetterRange(SourceForm, CodeLine) Then Return Pop_LetterRange(CodeLine)
        If Do_Not_Use_IsThisAnAlphaNumeric(SourceForm, CodeLine) Then Return Pop_AlphaNumeric(CodeLine)
        If Do_Not_Use_IsThisAPointAttribute(CodeLine) <> "" Then Return Do_Not_Use_IsThisAPointAttribute(CodeLine)
        If Do_Not_Use_IsThisABlock(CodeLine) Then Return Pop_Block(CodeLine)
        If MyUnicode.IsThisAUnicodeClass(CodeLine) Then Return MyUnicode.Pop_Unicode_Used(CodeLine)
        Pop_What = MyLeft(CodeLine, 1)
        CodeLine = Mid(CodeLine, 2)
    End Function


    Friend Function Pop_Marker(ByRef CodeLine As String) As String
        Dim I, J As Integer
        I = MyInStr(MyUniverse.SysGen.Constants.RMStart, CodeLine)
        J = MyInStr(MyUniverse.SysGen.Constants.RMEnd, CodeLine, I)
        ' log_X (1609, CodeLine)
        Pop_Marker = Mid(CodeLine, I, J - I + 1)
        CodeLine = MyReplace(CodeLine, Pop_Marker, "")
        Return Pop_Marker
    End Function
    Friend Function Pop_Marker2(ByRef CodeLine As String) As String
        logA(1610, CodeLine)
        Return Pop_Marker(CodeLine)
    End Function
    Friend Function Pop_WhiteSpace(ByRef SourceForm As Source, ByRef CodeLine As String) As String
        Dim RTN As String = ""
        While WhatIsThis(Mid(CodeLine, 1, 1)) <> "BLANK"
            RTN &= Mid(CodeLine, 1, 1)
            CodeLine = Mid(CodeLine, 2, Len(CodeLine))
        End While
        Return RTN
    End Function
    Friend Function Pop_BranchToNextLine(ByRef CodeLine As String) As String
        logA(1613, CodeLine)
        Return ""
    End Function
    Friend Function Pop_CameFromLine(ByRef CodeLine As String) As String
        logA(1614, CodeLine)
        Return ""
    End Function
    Friend Function Pop_Comment(ByRef CodeLine As String) As String
        Pop_Comment = CodeLine
        CodeLine = ""
        Return Pop_Comment
    End Function
    Friend Function Pop_KeyWord(ByRef CodeLine As String) As String
        Dim B As String
        B = Pop(CodeLine, MyUniverse.SysGen.Constants.ConstantDelimiters)
        Return NoFD(TrimOff(B, "'"))
    End Function
    Friend Function Pop_Function(ByRef CodeLine As String) As String
        logA(1616, CodeLine)
        Return Pop(CodeLine, MyUniverse.SysGen.Constants.ConstantDelimiters)
    End Function



    Friend Function Pop_Literal(ByRef CodeLine As String) As String
        Dim at1, at2 As Integer
        at1 = MyInStr("'", CodeLine)
        If at1 > 0 Then
            at2 = MyInStr("'", CodeLine, at1 + 1)
            If at2 > at1 And at1 > 0 Then
                Pop_Literal = Mid(CodeLine, at1, at2 - at1 + 1)
                CodeLine = MyReplace(CodeLine, Pop_Literal, "")
                Return MyTrim(Pop_Literal)
            End If
        End If
        Return ""
    End Function
    Friend Function Pop_Quote(ByRef CodeLine As String) As String
        If MyDebug(A_DISPLAY) Then logA(1620, CodeLine)
        Dim I, J As Integer
        If MyLeft(CodeLine, 4) = Chr(34) & Chr(34) & Chr(34) & Chr(34) Then
            CodeLine = Mid(CodeLine, 4)
            Return Chr(34) & Chr(34)
        End If
        If MyLeft(CodeLine, 3) = Chr(34) & Chr(34) & Chr(34) Then
            CodeLine = Mid(CodeLine, 3)
            Return Chr(34)
        End If
        If MyLeft(CodeLine, 2) = Chr(34) & Chr(34) Then
            CodeLine = Mid(CodeLine, 2)
            Return ""
        End If
        I = MyInStr(Chr(34), CodeLine)
        If I = 0 Then Return ""
        J = MyInStr(Chr(34), CodeLine, I + 1)
        If J = 0 Then
            If I = 1 Then
                If Len(CodeLine) = 2 And MyRight(CodeLine, 1) = Chr(34) Then
                    logA(1596, CodeLine)
                End If
                CodeLine = Mid(CodeLine, 2)
            End If
            Return ""
        End If
        Pop_Quote = Mid(CodeLine, I, J - I + 1)

        CodeLine = MyReplace(CodeLine, Pop_Quote, "")
        'CodeLine=CodeLine.Replace(Pop_Quote, VBSpace)
        Return Pop_Quote
    End Function
    Friend Function Pop_VariableName(ByRef SourceForm As Source, ByRef CodeLine As String) As String
        'If MyDebug(A_DISPLAY) ThenLogA(1621, CodeLine)
        Pop_VariableName = ""
        If Do_Not_Use_IsThisAnAlpha(SourceForm, CodeLine) = False Then
            Return "" ' This is not a variable name because it does not start with a letter
        End If
        While IsThisAVariable(SourceForm, CodeLine)
            Pop_VariableName &= MyLeft(CodeLine, 1)
            CodeLine = Mid(CodeLine, 2, Len(CodeLine))
        End While
        Return Pop_VariableName
    End Function
    Friend Function Pop_Number(ByRef SourceForm As Source, ByRef CodeLine As String) As String
        If MyDebug(A_DISPLAY) Then logA(1622, CodeLine)
        Pop_Number = ""
        While Do_Not_Use_IsThisANumber(SourceForm, CodeLine) Or MyLeft(CodeLine, 1) = "." Or MyLeft(CodeLine, 1) = "-"
            Pop_Number &= MyLeft(CodeLine, 1)
            CodeLine = Mid(CodeLine, 2, Len(CodeLine))
        End While
        Return Pop_Number
    End Function

    Friend Function Pop_Alpha(ByRef CodeLine As String) As String
        logA(1623, CodeLine)
        Return ""
    End Function
    Friend Function Pop_HexDigit(ByRef CodeLine As String) As String
        Pop_HexDigit = ""
        While Do_Not_Use_IsThisAHexDigit(CodeLine)
            'log_X(1624, CodeLine)
            Pop_HexDigit &= Mid(CodeLine, 1, 1)
            CodeLine = Mid(CodeLine, 2, Len(CodeLine))
        End While
        Return Pop_HexDigit
    End Function
    Friend Function Pop_HexDigitRange(ByRef CodeLine As String) As String
        logA(1625, CodeLine)
        Return ""
    End Function
    Friend Function Pop_LetterRange(ByRef CodeLine As String) As String
        logA(1626, CodeLine)
        Return ""
    End Function
    Friend Function Pop_AlphaNumeric(ByRef CodeLine As String) As String
        logA(1627, CodeLine)
        Return ""
    End Function
    Friend Function Pop_SpecialCharacter(ByRef SourceForm As Source, ByRef CodeLine As String) As String
        If MyDebug(A_DISPLAY) Then logA(1628, CodeLine)
        Pop_SpecialCharacter = ""
        While Do_Not_Use_IsThisASpecialCharacter(SourceForm, CodeLine)
            Pop_SpecialCharacter &= MyLeft(CodeLine, 1)
            CodeLine = Mid(CodeLine, 2, Len(CodeLine))
        End While
        Return Pop_SpecialCharacter
    End Function



    Friend Function Possible2MostLikely(ByRef SourceForm As Source, ParsedWord As String, ShowMsg As Boolean, grammerString As String) As String
        Dim Debuglevel As Integer = A_ERROR 'A_INFORMATION
        Select Case WhatCouldThisBe(SourceForm, ParsedWord)
            Case ""
                Possible2MostLikely = ""
                If MyDebug(Debuglevel) Then logA(2010, ParsedWord, Possible2MostLikely, WhatCouldThisBe(SourceForm, ParsedWord), grammerString)
            Case "Comment, BLOCK, Keyword, Literal, Terminal, " 'OK because this is a keyword
                Possible2MostLikely = MyUniverse.SysGen.Markers.KeyWords
                If MyDebug(Debuglevel) Then logA(1858, ParsedWord, Possible2MostLikely, WhatCouldThisBe(SourceForm, ParsedWord), grammerString)
            Case "Grammar Name, Variable Name, Letter, " 'Grammar Name only 
                Possible2MostLikely = MyUniverse.SysGen.Markers.Grammar
                    'log_X(1857, ParsedWord, Possible2MostLikely, WhatCouldThisBe(SourceForm ,ParsedWord), grammerString)
            Case "Special Character, "
                If Len(ParsedWord) = 3 And MyLeft(ParsedWord, 1) = "'" And MyRight(ParsedWord, 1) = "'" Then
                    If MyInStr(Mid(ParsedWord, 2, 1), "|';") <> 0 Then
                        Possible2MostLikely = AddRM(NoRM(MyUniverse.SysGen.Markers.SpecialCharacter) & ".|")
                    Else ' not ok, it should be a literal
                        Possible2MostLikely = AddRM(NoRM(MyUniverse.SysGen.Markers.SpecialCharacter) & "." & ParsedWord)
                        'MyUnicode.UnicodeClassCode(ParsedWord)
                        logA(2011, ParsedWord, Possible2MostLikely, WhatCouldThisBe(SourceForm, ParsedWord), grammerString)
                    End If
                Else
                    If MyInStr(Mid(ParsedWord, 1, 1), "|';()[]{}") <> 0 Then
                        Possible2MostLikely = AddRM(NoRM(MyUniverse.SysGen.Markers.SpecialCharacter) & "." & ParsedWord)
                    Else
                        Possible2MostLikely = AddRM(NoRM(MyUniverse.SysGen.Markers.SpecialCharacter) & "." & ParsedWord)
                        logA(1923, ParsedWord, Possible2MostLikely, WhatCouldThisBe(SourceForm, ParsedWord), grammerString)
                    End If
                End If
            Case "BLOCK, Keyword, Literal, Terminal, " ' OK because this is 'keyword' 
                Possible2MostLikely = MyUniverse.SysGen.Markers.KeyWords
                If MyDebug(Debuglevel) Then logA(1924, ParsedWord, Possible2MostLikely, WhatCouldThisBe(SourceForm, ParsedWord), grammerString)
            Case "BLOCK, Literal, " ' could be quoted space
                Possible2MostLikely = MyUniverse.SysGen.Markers.SpecialCharacter
                If ParsedWord = "' '" Then
                    If MyDebug(Debuglevel) Then logA(1925, ParsedWord, Possible2MostLikely, WhatCouldThisBe(SourceForm, ParsedWord), grammerString)
                Else
                    If MyDebug(Debuglevel) Then logA(2012, ParsedWord, Possible2MostLikely, WhatCouldThisBe(SourceForm, ParsedWord), grammerString)
                End If
            Case "BLOCK, Literal, Terminal, " ' OK because it is ('x') format or 'x' and in the /grammar
                Possible2MostLikely = MyUniverse.SysGen.Markers.SpecialCharacter
                If MyDebug(Debuglevel) Then logA(1926, ParsedWord, Possible2MostLikely, WhatCouldThisBe(SourceForm, ParsedWord), grammerString)
            Case "BLOCK, Literal, Terminal, Hex_Range, Char_Hex_Range, "
                Possible2MostLikely = MyUniverse.SysGen.Markers.SpecialCharacter
                If MyDebug(Debuglevel) Then logA(1927, ParsedWord, Possible2MostLikely, WhatCouldThisBe(SourceForm, ParsedWord), grammerString)
            Case "BLOCK, Operator, Literal, Terminal, " ' this is a quoted operater, and is considered a literal string 
                Possible2MostLikely = MyUniverse.SysGen.Markers.Operators
                If MyDebug(Debuglevel) Then logA(1928, ParsedWord, Possible2MostLikely, WhatCouldThisBe(SourceForm, ParsedWord), grammerString)
            Case "BLOCK, Special Character, "
                Possible2MostLikely = MyUniverse.SysGen.Markers.SpecialCharacter
                If MyDebug(Debuglevel) Then logA(2013, ParsedWord, Possible2MostLikely, WhatCouldThisBe(SourceForm, ParsedWord), grammerString)
            Case "Comment, CommentMark, "
                Possible2MostLikely = MyUniverse.SysGen.Markers.Comments
                If MyDebug(Debuglevel) Then logA(2014, ParsedWord, Possible2MostLikely, WhatCouldThisBe(SourceForm, ParsedWord), grammerString)
            Case "Comment, BLOCK, DataType, Literal, Terminal, " 'datatype terminal
                Possible2MostLikely = MyUniverse.SysGen.Markers.DataType
                If MyDebug(Debuglevel) Then logA(2015, ParsedWord, Possible2MostLikely, WhatCouldThisBe(SourceForm, ParsedWord), grammerString)
            Case "Comment, BLOCK, Keyword, Literal, "
                Possible2MostLikely = MyUniverse.SysGen.Markers.KeyWords
                If MyDebug(Debuglevel) Then logA(1929, ParsedWord, Possible2MostLikely, WhatCouldThisBe(SourceForm, ParsedWord), grammerString)
            Case "Comment, BLOCK, Keyword, Operator, Literal, Terminal, "
                Possible2MostLikely = ""
                If MyDebug(Debuglevel) Then logA(2016, ParsedWord, Possible2MostLikely, WhatCouldThisBe(SourceForm, ParsedWord), grammerString)
            Case "Comment, BLOCK, Literal, " 'not ok, because this should be a keyword or operator 
                Possible2MostLikely = ""
                If MyDebug(Debuglevel) Then logA(1854, ParsedWord, Possible2MostLikely, WhatCouldThisBe(SourceForm, ParsedWord), grammerString)
            Case "Comment, BLOCK, Literal, Hex_Range, Char_Hex_Range, "
                Possible2MostLikely = MyUniverse.SysGen.Markers.SpecialCharacter
                If MyDebug(Debuglevel) Then logA(2017, ParsedWord, Possible2MostLikely, WhatCouldThisBe(SourceForm, ParsedWord), grammerString)
            Case "Comment, BLOCK, Literal, Terminal, " 'Literal should be a keyword or operator BUT can be just puncation
                If ParsedWord = "," Or ParsedWord = "','" Then
                    Possible2MostLikely = MyUniverse.SysGen.Markers.SpecialCharacter
                    logA(1930, ParsedWord, Possible2MostLikely, WhatCouldThisBe(SourceForm, ParsedWord), grammerString)
                Else
                    Possible2MostLikely = ""
                    logA(1852, ParsedWord, Possible2MostLikely, WhatCouldThisBe(SourceForm, ParsedWord), grammerString)
                End If
            Case "Comment, BLOCK, Literal, Terminal, Hex_Range, "
                Possible2MostLikely = MyUniverse.SysGen.Markers.SpecialCharacter
                If MyDebug(Debuglevel) Then logA(2018, ParsedWord, Possible2MostLikely, WhatCouldThisBe(SourceForm, ParsedWord), grammerString)
            Case "Comment, BLOCK, Literal, Terminal, Hex_Range, Char_Hex_Range, "
                Possible2MostLikely = MyUniverse.SysGen.Markers.SpecialCharacter
                If MyDebug(Debuglevel) Then logA(1931, ParsedWord, Possible2MostLikely, WhatCouldThisBe(SourceForm, ParsedWord), grammerString)
            Case "Comment, BLOCK, Operator, Literal, Terminal, " 'OK because it is a quoted special character
                Possible2MostLikely = MyUniverse.SysGen.Markers.Operators
                If MyDebug(Debuglevel) Then logA(1932, ParsedWord, Possible2MostLikely, WhatCouldThisBe(SourceForm, ParsedWord), grammerString)
            Case "Comment, CommentMark, Operator, Special Character, "
                Possible2MostLikely = MyUniverse.SysGen.Markers.Operators
                If MyDebug(Debuglevel) Then logA(2019, ParsedWord, Possible2MostLikely, WhatCouldThisBe(SourceForm, ParsedWord), grammerString)
            Case "Comment, CommentMark, Special Character, "
                If ParsedWord = "'''" Or ParsedWord = "'" Then
                    Possible2MostLikely = MyUniverse.SysGen.Markers.SpecialCharacter
                Else
                    Possible2MostLikely = MyUniverse.SysGen.Markers.SpecialCharacter
                    If MyDebug(Debuglevel) Then logA(2020, ParsedWord, Possible2MostLikely, WhatCouldThisBe(SourceForm, ParsedWord), grammerString)
                End If
            Case "Comment, DataType, Literal, Terminal, "
                Possible2MostLikely = MyUniverse.SysGen.Markers.DataType
                If MyDebug(Debuglevel) Then logA(2021, ParsedWord, Possible2MostLikely, WhatCouldThisBe(SourceForm, ParsedWord), grammerString)
            Case "Comment, Grammar Name, Literal, Terminal, "
                Possible2MostLikely = MyUniverse.SysGen.Markers.Grammar
                If MyDebug(Debuglevel) Then logA(2022, ParsedWord, Possible2MostLikely, WhatCouldThisBe(SourceForm, ParsedWord), grammerString)
            Case "Comment, Keyword, Literal, Terminal, " 'OK because ' is a comment, but it is a keyword inside ''
                Possible2MostLikely = MyUniverse.SysGen.Markers.KeyWords
'                    If MyDebug(Debuglevel) ThenLogA(2023, ParsedWord, Possible2MostLikely, WhatCouldThisBe(SourceForm ,ParsedWord), grammerString)
            Case "Comment, Keyword, Literal, Terminal, Hex_Range, Char_Hex_Range, "
                Possible2MostLikely = MyUniverse.SysGen.Markers.KeyWords
                If MyDebug(Debuglevel) Then logA(2024, ParsedWord, Possible2MostLikely, WhatCouldThisBe(SourceForm, ParsedWord), grammerString)
            Case "Comment, Keyword, Operator, Literal, Terminal, " 'OK, beacuse it is a defined terminal
                Possible2MostLikely = ""
                If MyDebug(Debuglevel) Then logA(2025, ParsedWord, Possible2MostLikely, WhatCouldThisBe(SourceForm, ParsedWord), grammerString)
            Case "Comment, Keyword, Special Character, " ' special characters in the keyword
                Possible2MostLikely = MyUniverse.SysGen.Markers.KeyWords
                If MyDebug(Debuglevel) Then logA(2026, ParsedWord, Possible2MostLikely, WhatCouldThisBe(SourceForm, ParsedWord), grammerString)
            Case "Comment, Literal, "
                Possible2MostLikely = MyUniverse.SysGen.Markers.Literal
                If MyDebug(Debuglevel) Then logA(2186, ParsedWord, Possible2MostLikely, WhatCouldThisBe(SourceForm, ParsedWord), grammerString)
                If NoWhiteSpaceS(SourceForm, ParsedWord) <> ParsedWord Then
                    LogDebug(1043, Err7, "no white spaces Error also: --->" & ParsedWord & "<---")
                End If
            Case "Comment, Literal, Terminal, "
                'is a known single letter terminal?
                If Len(ParsedWord) = 3 And MyLeft(ParsedWord, 1) = "'" And MyRight(ParsedWord, 1) = "'" Then
                    'Possible2mostlikely(SourceForm ,Mid(ParsedWord, 2, 1), False, grammerString)
                    Possible2MostLikely = MyUniverse.SysGen.Markers.Literal 'terminal
                    'check if ok to allow a terminal (single quoted character)
                    'If Possible2MostLikely = "⬂FieldDelimiter⬃" Then
                    'LogA( 1000, "B " & "dont stop " & Possible2MostLikely & vbTab & ParsedWord)
                    ' ElseIf Possible2MostLikely = "⬂WhiteSpace⬃" Then
                    '    LogA( 1000, "C " & "dont stop " & Possible2MostLikely & vbTab & ParsedWord)
                    ' ElseIf Possible2MostLikely = MyUniverse.SysGen.Markers.Literal Then 'MyLeft(Possible2MostLikely, 9) = "⬂Special." Then
                    'log_X( 1000, "D " & "dont stop " & Possible2MostLikely & vbTab & ParsedWord)
                    'Else
                    '   LogA( 1000, "E " & "Stop " & Possible2MostLikely & vbTab & ParsedWord)
                    '    If ShowMsg ThenLogA(2187, ParsedWord, Possible2MostLikely, WhatCouldThisBe(SourceForm ,ParsedWord), grammerString)
                    '   LogA( 1000, "F " & "Stop " & Possible2MostLikely & vbTab & ParsedWord)
                    ' End If
                Else
                    'log_X( 1000, "G " & ParsedWord & ", " & WhatCouldThisBe(SourceForm ,ParsedWord))
                    Possible2MostLikely = MyUniverse.SysGen.Markers.Literal
                    If MyDebug(Debuglevel) Then logA(2233, ParsedWord, Possible2MostLikely, WhatCouldThisBe(SourceForm, ParsedWord), grammerString)
                End If
            Case "Comment, Literal, Hex_Range, Char_Hex_Range, " 'OK because this is a hex range
                Possible2MostLikely = MyUniverse.SysGen.Markers.HexRange
                If MyDebug(Debuglevel) Then logA(2188, ParsedWord, Possible2MostLikely, WhatCouldThisBe(SourceForm, ParsedWord), grammerString)
            Case "Comment, Literal, Terminal, Hex_Range, Char_Hex_Range, " 'OK literal hex character range
                Possible2MostLikely = MyUniverse.SysGen.Markers.HexRange
'                    If MyDebug(Debuglevel) ThenLogA(1933, ParsedWord, Possible2MostLikely, WhatCouldThisBe(SourceForm ,ParsedWord), grammerString)
            Case "Comment, Operator, Literal, Terminal, " 'OK because it is a quoted operator in /grammar
                Possible2MostLikely = MyUniverse.SysGen.Markers.Operators
                    'If MyDebug(Debuglevel) ThenLogA(2189, ParsedWord, Possible2MostLikely, WhatCouldThisBe(SourceForm ,ParsedWord), grammerString)
            Case "Comment, Operator, DataType, Literal, Terminal, " 'NOT ok because a data type can not also be an operator.
                Possible2MostLikely = ""
                If MyDebug(Debuglevel) Then logA(2190, ParsedWord, Possible2MostLikely, WhatCouldThisBe(SourceForm, ParsedWord), grammerString)
            Case "CommentMark, MultiLine, Extension, BranchTo, FieldDelimiter, "
                logA(1071, ParsedWord, WhatCouldThisBe(SourceForm, ParsedWord), grammerString)
                Possible2MostLikely = ""
                If ParsedWord = "" Then
                    logA(1934, ParsedWord, Possible2MostLikely, WhatCouldThisBe(SourceForm, ParsedWord), grammerString)
                Else
                    logA(2191, ParsedWord, Possible2MostLikely, WhatCouldThisBe(SourceForm, ParsedWord), grammerString)
                End If
            Case "DataType, Literal, Terminal, "
                Possible2MostLikely = MyUniverse.SysGen.Markers.DataType
                If MyDebug(Debuglevel) Then logA(2192, ParsedWord, Possible2MostLikely, WhatCouldThisBe(SourceForm, ParsedWord), grammerString)
            Case "DataType, Variable Name, Letter, "
                Possible2MostLikely = MyUniverse.SysGen.Markers.DataType
                If MyDebug(Debuglevel) Then logA(2193, ParsedWord, Possible2MostLikely, WhatCouldThisBe(SourceForm, ParsedWord), grammerString)
            Case "Extension, Special Character, "
                Possible2MostLikely = MyUniverse.SysGen.Markers.SpecialCharacter
                If MyDebug(Debuglevel) Then logA(2194, ParsedWord, Possible2MostLikely, WhatCouldThisBe(SourceForm, ParsedWord), grammerString)
            Case "FieldDelimiter, Special Character, "
                Possible2MostLikely = MyUniverse.SysGen.Markers.FieldDelimiters
                If ShowMsg Then logA(1072, ParsedWord, Possible2MostLikely, WhatCouldThisBe(SourceForm, ParsedWord), grammerString)
            Case "Function Name, Variable Name, Letter, "
                Possible2MostLikely = MyUniverse.SysGen.Markers.Functions
                If MyDebug(Debuglevel) Then logA(2195, ParsedWord, Possible2MostLikely, WhatCouldThisBe(SourceForm, ParsedWord), grammerString)
            Case "Grammar Name, Literal, "
                Possible2MostLikely = MyUniverse.SysGen.Markers.Grammar
                If MyDebug(Debuglevel) Then logA(2196, ParsedWord, Possible2MostLikely, WhatCouldThisBe(SourceForm, ParsedWord), grammerString)
            Case "Grammar Name, DataType, Variable Name, Letter, "
                Possible2MostLikely = ""
                logA(1147, ParsedWord, Possible2MostLikely, WhatCouldThisBe(SourceForm, ParsedWord), grammerString)
            Case "Grammar Name, Special Character, "
                Possible2MostLikely = MyUniverse.SysGen.Markers.Grammar
                If MyDebug(Debuglevel) Then logA(2293, ParsedWord, Possible2MostLikely, WhatCouldThisBe(SourceForm, ParsedWord), grammerString)
            Case "Grammar Name, Variable Name, Letter, "
                Possible2MostLikely = MyUniverse.SysGen.Markers.Grammar
                If MyDebug(Debuglevel) Then logA(2212, ParsedWord, Possible2MostLikely, WhatCouldThisBe(SourceForm, ParsedWord), grammerString)
            Case "Grammar Name, Variable Name, Letter, Char_Hex_Range, " 'grammar name has a dash - or other special letters
                Possible2MostLikely = MyUniverse.SysGen.Markers.Grammar
                If MyDebug(Debuglevel) Then logA(2213, ParsedWord, Possible2MostLikely, WhatCouldThisBe(SourceForm, ParsedWord), grammerString)
            Case "Grammar Name, Variable Name, Letter, Hex_Digit, " 'OK this is a grammar name
                Possible2MostLikely = MyUniverse.SysGen.Markers.Grammar
                If MyDebug(Debuglevel) Then logA(2214, ParsedWord, Possible2MostLikely, WhatCouldThisBe(SourceForm, ParsedWord), grammerString)
            Case "Grammar Name, Variable Name, Letter, PointAttribute, " 'NOT OK grammar name same as point attribut name
                Possible2MostLikely = MyUniverse.SysGen.Markers.Grammar
                If MyDebug(Debuglevel) Then logA(1935, ParsedWord, Possible2MostLikely, WhatCouldThisBe(SourceForm, ParsedWord), grammerString)
            Case "Grammar Name, Literal, Terminal, " 'not ok, because a grammar name can not be inside squotes
                Possible2MostLikely = ""
                If MyDebug(Debuglevel) Then logA(2215, ParsedWord, Possible2MostLikely, WhatCouldThisBe(SourceForm, ParsedWord), grammerString)
            Case "KeyWord" 'todo this should be a literal also, not just the keyword. 
                Possible2MostLikely = MyUniverse.SysGen.Markers.KeyWords
            Case "Keyword, DataType, Variable Name, Letter, "
                Possible2MostLikely = ""
                If MyDebug(Debuglevel) Then logA(2217, ParsedWord, Possible2MostLikely, WhatCouldThisBe(SourceForm, ParsedWord), grammerString)
            Case "Keyword, Function Name, Variable Name, Letter, "
                Possible2MostLikely = ""
                If MyDebug(Debuglevel) Then logA(2268, ParsedWord, Possible2MostLikely, WhatCouldThisBe(SourceForm, ParsedWord), grammerString)
            Case "KeyWord, Literal, "
                Possible2MostLikely = MyUniverse.SysGen.Markers.KeyWords
            Case "Keyword, Literal, Terminal, " 'OK
                Possible2MostLikely = MyUniverse.SysGen.Markers.KeyWords
                    'If MyDebug(Debuglevel) ThenLogA(2270, ParsedWord, Possible2MostLikely, WhatCouldThisBe(SourceForm ,ParsedWord), grammerString)
            Case "Keyword, Grammar Name, Variable Name, Letter, Hex_Digit, "
                Possible2MostLikely = ""
                If MyDebug(Debuglevel) Then logA(2271, ParsedWord, Possible2MostLikely, WhatCouldThisBe(SourceForm, ParsedWord), grammerString)
            Case "Keyword, Grammar Name, Variable Name, Letter, " 'NOT ok because it is a grammar name and also a keyword
                Possible2MostLikely = ""
                If MyDebug(Debuglevel) Then logA(1850, ParsedWord, Possible2MostLikely, WhatCouldThisBe(SourceForm, ParsedWord), grammerString)
            Case "Keyword, Grammar Name, Literal, "
                Possible2MostLikely = ""
                If MyDebug(Debuglevel) Then logA(2272, ParsedWord, Possible2MostLikely, WhatCouldThisBe(SourceForm, ParsedWord), grammerString)
            Case "Keyword, Number, Special Character, "
                Possible2MostLikely = ""
                If MyDebug(Debuglevel) Then logA(2273, ParsedWord, Possible2MostLikely, WhatCouldThisBe(SourceForm, ParsedWord), grammerString)
            Case "Keyword, Operator, Variable Name, Letter, "
                Possible2MostLikely = ""
                If MyDebug(Debuglevel) Then logA(2274, ParsedWord, Possible2MostLikely, WhatCouldThisBe(SourceForm, ParsedWord), grammerString)
            Case "Keyword, Special Character, " 'OK because special letters might be allowed in keywords
                Possible2MostLikely = MyUniverse.SysGen.Markers.KeyWords
                If MyDebug(Debuglevel) Then logA(2275, ParsedWord, Possible2MostLikely, WhatCouldThisBe(SourceForm, ParsedWord), grammerString)
            Case "Keyword, Variable Name, Letter, " 'NOT OK it is a keyword with out quotes
                Possible2MostLikely = MyUniverse.SysGen.Markers.KeyWords
                If MyDebug(Debuglevel) Then logA(2276, ParsedWord, Possible2MostLikely, WhatCouldThisBe(SourceForm, ParsedWord), grammerString)
            Case "Keyword, Variable Name, Letter, Hex_Digit, "
                Possible2MostLikely = MyUniverse.SysGen.Markers.KeyWords
                If MyDebug(Debuglevel) Then logA(2277, ParsedWord, Possible2MostLikely, WhatCouldThisBe(SourceForm, ParsedWord), grammerString)
            Case "Keyword, Variable Name, Letter, PointAttribute, " 'NOT ok because it is both a keyword and point attribute.
                Possible2MostLikely = MyUniverse.SysGen.Markers.KeyWords
                If MyDebug(Debuglevel) Then logA(2278, ParsedWord, Possible2MostLikely, WhatCouldThisBe(SourceForm, ParsedWord), grammerString)
            Case "Literal, "
                Possible2MostLikely = "" 'NOT ok, this should be defined as an operator, or keyword (or function)
                If MyDebug(Debuglevel) Then logA(2279, ParsedWord, Possible2MostLikely, WhatCouldThisBe(SourceForm, ParsedWord), grammerString)
            Case "Literal, Char_Hex_Range, ", "Literal, Hex_Range, Char_Hex_Range, " 'ok
                Possible2MostLikely = MyUniverse.SysGen.Markers.HexRange
                If MyDebug(Debuglevel) Then logA(2294, ParsedWord, Possible2MostLikely, WhatCouldThisBe(SourceForm, ParsedWord), grammerString)
            Case "Literal, Terminal, "
                If ParsedWord = "," Then ','" then ,
                    Possible2MostLikely = MyUniverse.SysGen.Markers.FieldDelimiters
                ElseIf ParsedWord = "','" Then
                    Possible2MostLikely = MyUniverse.SysGen.Markers.Literal
                ElseIf Len(ParsedWord) = 3 And MyLeft(ParsedWord, 1) = "'" And MyRight(ParsedWord, 1) = "'" Then
                    'todo this needs to return terminal or literal (which do not exist)
                    Possible2MostLikely = MyUniverse.SysGen.Markers.Literal
                Else
                    Possible2MostLikely = MyUniverse.SysGen.Markers.Literal  'quoted simi colon?
                    If MyDebug(Debuglevel) Then logA(2280, ParsedWord, Possible2MostLikely, WhatCouldThisBe(SourceForm, ParsedWord), grammerString)
                End If
            Case "Literal, Terminal, Char_Hex_Range, ", "Literal, Terminal, Hex_Range, ", "Literal, Terminal, Hex_Range, Char_Hex_Range, "
                Possible2MostLikely = MyUniverse.SysGen.Markers.HexRange
                    'If MyDebug(Debuglevel) ThenLogA(2281, ParsedWord, Possible2MostLikely, WhatCouldThisBe(SourceForm ,ParsedWord), grammerString)
            Case "MultiLine, Special Character, "
                Possible2MostLikely = MyUniverse.SysGen.Markers.Markers
                If MyDebug(Debuglevel) Then logA(1853, ParsedWord, Possible2MostLikely, WhatCouldThisBe(SourceForm, ParsedWord), grammerString)
            Case "Number, ", "Number, Hex_Digit, "
                Possible2MostLikely = MyUniverse.SysGen.Markers.Numbers
                If MyDebug(Debuglevel) Then logA(2284, ParsedWord, Possible2MostLikely, WhatCouldThisBe(SourceForm, ParsedWord), grammerString)
            Case "Number, Special Character, "
                Possible2MostLikely = MyUniverse.SysGen.Markers.Numbers
                If MyDebug(Debuglevel) Then logA(2286, ParsedWord, Possible2MostLikely, WhatCouldThisBe(SourceForm, ParsedWord), grammerString)
            Case "Number, Hex_Range, "
                Possible2MostLikely = MyUniverse.SysGen.Markers.Numbers
                If MyDebug(Debuglevel) Then logA(2287, ParsedWord, Possible2MostLikely, WhatCouldThisBe(SourceForm, ParsedWord), grammerString)
            Case "Operator, " 'OK 
                Possible2MostLikely = MyUniverse.SysGen.Markers.Operators
                If MyDebug(Debuglevel) Then logA(2288, ParsedWord, Possible2MostLikely, WhatCouldThisBe(SourceForm, ParsedWord), grammerString)
            Case "Operator, Grammar Name, Variable Name, Letter, "
                Possible2MostLikely = ""
                If MyDebug(Debuglevel) Then logA(2289, ParsedWord, Possible2MostLikely, WhatCouldThisBe(SourceForm, ParsedWord), grammerString)
            Case "Operator, Literal, Terminal, " 'OK because this is an operator that is correctly quoted
                Possible2MostLikely = MyUniverse.SysGen.Markers.Operators
                    'If MyDebug(Debuglevel) ThenLogA(2290, ParsedWord, Possible2MostLikely, WhatCouldThisBe(SourceForm ,ParsedWord), grammerString)
            Case "Operator, MultiLine, Special Character, "
                Possible2MostLikely = ""
                If MyDebug(Debuglevel) Then logA(2291, ParsedWord, Possible2MostLikely, WhatCouldThisBe(SourceForm, ParsedWord), grammerString)
            Case "Operator, Special Character, "
                If ParsedWord = "|" Then 'OK because it is the one operator that is allowed in /grammar
                    Possible2MostLikely = MyUniverse.SysGen.Markers.Operators
                Else ' NOT OK, because it is a special character that is not a literal
                    Possible2MostLikely = ""
                    If MyDebug(Debuglevel) Then logA(1854, ParsedWord, Possible2MostLikely, WhatCouldThisBe(SourceForm, ParsedWord), grammerString)
                End If
            Case "Operator, Extension, Special Character, "
                Possible2MostLikely = MyUniverse.SysGen.Markers.Operators
                If MyDebug(Debuglevel) Then logA(2295, ParsedWord, Possible2MostLikely, WhatCouldThisBe(SourceForm, ParsedWord), grammerString)
            Case "Quote, Special Character, " ' OK because it is a " or else a ' 
                If ParsedWord <> MyUniverse.SysGen.Constants.ConstantQuote And ParsedWord <> "'" Then
                    Possible2MostLikely = MyUniverse.SysGen.Markers.SpecialCharacter
                    If MyDebug(Debuglevel) Then logA(2296, "A) " & ParsedWord, Possible2MostLikely, WhatCouldThisBe(SourceForm, ParsedWord), grammerString)
                Else
                    Possible2MostLikely = MyUniverse.SysGen.Markers.SpecialCharacter
                    If MyDebug(Debuglevel) Then logA(2296, "B) " & ParsedWord, Possible2MostLikely, WhatCouldThisBe(SourceForm, ParsedWord), grammerString)
                End If
                If MyDebug(Debuglevel) Then logA(2296, ParsedWord, Possible2MostLikely, WhatCouldThisBe(SourceForm, ParsedWord), grammerString)
            Case "Special Character, Hex_Range, "
                Possible2MostLikely = MyUniverse.SysGen.Markers.SpecialCharacter
                If MyDebug(Debuglevel) Then logA(2297, ParsedWord, Possible2MostLikely, WhatCouldThisBe(SourceForm, ParsedWord), grammerString)
            Case "Variable Name, Letter, " 'NOT ok, because it needs to be a keyword, or a grammar name or a terminal
                Possible2MostLikely = MyUniverse.SysGen.Markers.AlphaNumeric
                If MyDebug(Debuglevel) Then logA(2298, ParsedWord, Possible2MostLikely, WhatCouldThisBe(SourceForm, ParsedWord), grammerString)
            Case "Variable Name, Letter, Hex_Digit, " 'not ok because if hex character then should be quoted, and variable name is never allowed
                Possible2MostLikely = MyUniverse.SysGen.Markers.AlphaNumeric
                If MyDebug(Debuglevel) Then logA(2299, ParsedWord, Possible2MostLikely, WhatCouldThisBe(SourceForm, ParsedWord), grammerString)
                    'Case "Variable Name, Letter, PointAttribute, "
                    '    Possible2MostLikely = MyUniverse.SysGen.Markers.
                    '    If MyDebug(Debuglevel) ThenLogA(2299, ParsedWord, Possible2MostLikely, WhatCouldThisBe(SourceForm ,ParsedWord), grammerString)
            Case "Unicode, Variable Name, Letter, " 'OK, because this is a unicode class name unicode.xx
                Possible2MostLikely = MyUniverse.SysGen.Markers.UnicodeClass
                If MyDebug(Debuglevel) Then logA(2386, ParsedWord, Possible2MostLikely, WhatCouldThisBe(SourceForm, ParsedWord), grammerString)
            Case "Keyword, Operator, Literal, Terminal, "
                logA(2318, ParsedWord)
                Possible2MostLikely = ""
                If MyDebug(Debuglevel) Then logA(2385, ParsedWord, Possible2MostLikely, WhatCouldThisBe(SourceForm, ParsedWord), grammerString)
            Case Nothing, ""
                Possible2MostLikely = ""
            Case "White Space, "
                Possible2MostLikely = MyUniverse.SysGen.Markers.WhiteSpaces
            Case Else
                Possible2MostLikely = MyUniverse.SysGen.Markers.Unknowns
                logA(1632, ParsedWord, Possible2MostLikely, WhatCouldThisBe(SourceForm, ParsedWord), grammerString)
        End Select

    End Function




    'returns all possible things this could be (ie number is also an alphanumeric
    Friend Function WhatCouldThisBe(ByRef SourceForm As Source, CodeLine As String) As String
        Static LastCodeLine, LastRTN As String
        Dim RTN, C As String

        RTN = "" ' HighLight(CodeLine)
        If Len(CodeLine) = 0 Then
            Return ""
        End If
        If CodeLine = LastCodeLine Then
            Return LastRTN
        End If
        'If MyUnicode.UnicodeClassCode(CodeLine) <> "" Then RTN &= "Unicode." & MyUnicode.UnicodeClassCode(CodeLine) & ", "
        If MyUnicode.IsThisAUnicodeClass(CodeLine) Then RTN &= "Unicode, "
        If Do_Not_Use_IsThisAMarker(SourceForm, CodeLine) <> "" Then RTN &= "Marker, "
        If Do_Not_Use_IsThisAMarker2(SourceForm, CodeLine) <> "" Then RTN &= "Marker 2, "
        If IsThisAWhiteSpace(CodeLine) <> "" Then RTN &= "White Space, "
        If Do_Not_Use_IsThisABranchToNextLine(CodeLine) Then RTN &= "BranchTo, "
        If Do_Not_Use_IsThisACameFromLine(CodeLine) Then RTN &= "CAMEFROM , "
        If Do_Not_Use_IsThisAComment(CodeLine) Then RTN &= "Comment, "
        If IsThisAWhat_2(CodeLine, Options.ListBoxSymbolData.Items.Item(21).ToString) Then RTN &= "CommentMark, "
        If Do_Not_Use_IsThisABlock(CodeLine) Then RTN &= "BLOCK, "
        If Do_Not_Use_IsThisAKeyWord(SourceForm, CodeLine) Then RTN &= "Keyword, "
        '''''If Do_Not_Use_IsThisA_Function(CodeLine) Then RTN &= "Function Name, "
        '''''If Do_Not_Use_IsThisA_Operator(SourceForm, CodeLine) > 0 Then RTN &= "Operator, "
        If IsThisAGrammarRule(CodeLine) <> "" Then RTN &= "Grammar Name, "
        If IsthisADataType(CodeLine) <> "" Then RTN &= "DataType, "
        If Do_Not_Use_IsThisALiteral(CodeLine) Then RTN &= "Literal, "
        If Do_Not_Use_IsThisAQuote(CodeLine) Then RTN &= "Quote, "
        C = CodeLine
        If Pop_VariableName(SourceForm, C) <> "" Then RTN &= "Variable Name, "
        If Do_Not_Use_IsThisANumber(SourceForm, CodeLine) Then RTN &= "Number, "
        If Do_Not_Use_IsThisAnAlpha(SourceForm, CodeLine) Then RTN &= "Letter, "

        If IsThisAWhat_2(CodeLine, MyUniverse.ProgramOptions.FCCL_MultiLine) Then RTN &= "MultiLine, "
        If IsThisAWhat_2(CodeLine, Options.ListBoxSymbolData.Items.Item(25).ToString) Then RTN &= "Extension, "
        If IsThisAWhat_2(CodeLine, MyUniverse.SysGen.Markers.BranchToNextLine) Then RTN &= "BranchTo, "
        If Do_Not_Use_IsThisAMarker2(SourceForm, CodeLine) <> "" Then RTN &= "Marker 2, "
        If IsThisAWhat_2(CodeLine, FD) Then RTN &= "FieldDelimiter, "
        If Do_Not_Use_IsThisASpecialCharacter(SourceForm, CodeLine) Then RTN &= "Special Character, "

        If Do_Not_Use_IsThisAGrammarTerminal(SourceForm, CodeLine) <> "" Then RTN &= "Terminal, "
        If Do_Not_Use_IsThisAHexDigit(CodeLine) Then RTN &= "Hex_Digit, "
        If Do_Not_Use_IsThisAHexDigitRange(CodeLine) Then RTN &= "Hex_Range, "
        If Do_Not_Use_IsThisALetterRange(SourceForm, CodeLine) Then RTN &= "Char_Hex_Range, "
        '''''If  Do_Not_Use_IsThisAnAlphaNumeric(SourceForm, CodeLine) Then RTN &= "***Character, "
        If Do_Not_Use_IsThisAPointAttribute(CodeLine) <> "" Then RTN &= "PointAttribute, "
        LastCodeLine = CodeLine
        LastRTN = RTN
        Return RTN
    End Function


    Friend Function Do_Not_Use_IsThisAWhat(ByRef SourceForm As Source, CodeLine As String) As String
        Dim What As String
        If MyDebug(A_STATUS) Then logA(1467, CodeLine)

        If MyIsNothing(CodeLine) Then Return Nothing
        If CodeLine = "" Then Return MyUniverse.SysGen.Markers.Unknowns


        What = Do_Not_Use_IsThisAMarker(SourceForm, MyTrim(CodeLine))
        If What <> "" Then
            Return What
        End If

        If IsThisAWhiteSpace(CodeLine) <> "" Then
            Return MyUniverse.SysGen.Markers.WhiteSpaces
        End If

        If Do_Not_Use_IsThisABranchToNextLine(CodeLine) Then
            Return MyUniverse.SysGen.Markers.BranchToNextLine
        End If

        If Do_Not_Use_IsThisACameFromLine(CodeLine) Then
            Return MyUniverse.SysGen.Markers.CameFromLine
        End If


        If Do_Not_Use_IsThisAKeyWord(SourceForm, CodeLine) Then
            Return MyUniverse.SysGen.Markers.KeyWords
        End If


        '''''If Do_Not_Use_IsThisA_Function(CodeLine) Then
        '''''Return MyUniverse.SysGen.Markers.Functions
        '''''End If

        If IsThisA_Operator(SourceForm, CodeLine) > 0 Then
            Return MyUniverse.SysGen.Markers.Operators
        End If

        If IsThisAGrammarRule(CodeLine) <> "" Then
            Return MyUniverse.SysGen.Markers.Grammar
        End If

        If IsthisADataType(CodeLine) <> "" Then
            Return MyUniverse.SysGen.Markers.DataType
        End If


        'todo quote and comment needs to be combine to be a 'block' (as well as all other blocks)
        If Do_Not_Use_IsThisALetterRange(SourceForm, CodeLine) Or Do_Not_Use_IsThisAHexDigitRange(CodeLine) Then
            'should this return \quote/?
            Return MyUniverse.SysGen.Markers.HexRange
        End If


        If Do_Not_Use_IsThisALiteral(CodeLine) Then
            Return MyUniverse.SysGen.Markers.Literal
        End If

        If Do_Not_Use_IsThisAQuote(CodeLine) Then
            Return MyUniverse.SysGen.Markers.Quotes
        End If


        'todo need to also check if this is in the netLinks list
        If Do_Not_Use_IsThisAVariableNameX(SourceForm, CodeLine) Then
            Return CodeLine
        End If


        If Do_Not_Use_IsThisANumber(SourceForm, CodeLine) Then
            Return MyUniverse.SysGen.Markers.Numbers 'number is always a variable(Need to add option to over ride, and a mnemonic)
        End If

        If Do_Not_Use_IsThisAnAlpha(SourceForm, CodeLine) Then
            Return MyUniverse.SysGen.Markers.Alphas ' Alpha is always a variable (Need to add an option to over ride, and also a mnemonic)
        End If


        If Do_Not_Use_IsThisAComment(CodeLine) Then
            Return MyUniverse.SysGen.Markers.Comments
        End If

        If IsThisAWhat_2(CodeLine, MyUniverse.ProgramOptions.FCCL_MultiLine) Then
            Return MyUniverse.ProgramOptions.FCCL_MultiLine
        End If
        If IsThisAWhat_2(CodeLine, Options.ListBoxSymbolData.Items.Item(21).ToString) Then
            Return Options.ListBoxSymbolData.Items.Item(21).ToString
        End If
        If IsThisAWhat_2(CodeLine, Options.ListBoxSymbolData.Items.Item(25).ToString) Then
            Return Options.ListBoxSymbolData.Items.Item(25).ToString
        End If
        If IsThisAWhat_2(CodeLine, MyUniverse.SysGen.Markers.BranchToNextLine) Then
            Return MyUniverse.SysGen.Markers.BranchToNextLine
        End If

        'already did this above
        'If  Do_Not_Use_IsThisAMarker(SourceForm ,  CodeLine) <> "" Then
        'MyUniverse.MyStaticData.Do_Not_Use_IsThisAWhat.LastCodeLine=CodeLine
        'MyUniverse.MyStaticData.Do_Not_Use_IsThisAWhat.LastWhat=CodeLine
        'Return CodeLine ' MyUniverse.SysGen.Markers.Variables ' this will return if it is a  MyFD(point.name )  format which is a variable
        'End If

        If Do_Not_Use_IsThisAMarker2(SourceForm, CodeLine) <> "" Then
            Return CodeLine 'MyUniverse.SysGen.Markers.Variables
        End If

        If IsThisAWhat_2(CodeLine, FD) Then
            Return MyUniverse.SysGen.Markers.FieldDelimiters
        End If

        If Do_Not_Use_IsThisASpecialCharacter(SourceForm, CodeLine) Then
            Return AddRM(NoRM(MyUniverse.SysGen.Markers.SpecialCharacter) & "." & CodeLine)
        End If

        'done above
        'If  Do_Not_Use_IsThisAWhiteSpace(CodeLine) Then
        'MyUniverse.MyStaticData.Do_Not_Use_IsThisAWhat.LastCodeLine=CodeLine
        'MyUniverse.MyStaticData.Do_Not_Use_IsThisAWhat.LastWhat=MyUniverse.SysGen.Markers.WhiteSpaces
        'Return MyUniverse.SysGen.Markers.WhiteSpaces
        'End If

        Return MyUniverse.SysGen.Markers.Unknowns
    End Function

    Friend Function Do_Not_Use_IsThisAGrammarTerminal(ByRef SourceForm As Source, CodeLine As String) As String
        Dim A As String
        Dim I As Integer
        ' DIM   debugLevel As Integer=3
        '''''If MyUniverse.MyStaticData.GrammarTerminal.LastGrammarTerminal = CodeLine Then
        '''''Return Language_Grammar(MyUniverse.MyStaticData.GrammarTerminal.LastGrammarIndex)
        '''''End If

        A = NoRightRule(CodeLine)
        'If MyLeft(A, 1)="'" And MyRight(A, 1)="'" Then
        'Else
        ' A="'" & PopLine(A) & "'"
        'End If
        If Not Do_Not_Use_IsThisALiteral(A) Then Return "" '' terminals must be inside sQuote
        If CodeLine = "" Then Return ""
        If MyInStr(VBSpace, A) <> 0 And A <> "' '" Then
            Return ""
        End If
        For I = 1 To TopOfFile(SourceForm, "Grammar")
            '''''ShowProgressBar(1, I, TopOfFile(SourceForm,  "Grammar"))
            If MyInStr(A, Language_Grammar(I)) <> 0 Then
                '''''MyUniverse.MyStaticData.GrammarTerminal.LastGrammarTerminal = CodeLine
                '''''MyUniverse.MyStaticData.GrammarTerminal.LastGrammarIndex = I
                Return Language_Grammar(I)
            End If
        Next I
        Return ""
    End Function



    'todo need to change this to check the keywords array for the 'correct' for of the input (which needs to be changed to allow other languages, and changing the format, so that it is used to decide how the input is formatted
    Friend Function Do_Not_Use_IsThisAFCKeyword(KeyWord As String) As Boolean
        Select Case LCase(KeyWord)
            Case "/Grammar", "/Grammar="
                Return True
            Case "/name"
                Return True
            Case "/use"
                Return True
            Case "/path"
                Return True
            Case "/point"
                Return True
            Case "/Line"
                Return True
            Case "/error"
                Return True
            Case "/keyword", "/keyword="
                Return True
            Case "/function", "/function="
                Return True
            Case "/operator", "/operator="
                Return True
            Case "/ignore", "/ignore="
                Return True
            Case "/debug", "/debug="
                Return True
            Case Else
                logA(2373, KeyWord)
                Return False
        End Select
        Return False
    End Function





    'Test if imbedded mark is a start of a comment
    Friend Function Do_Not_Use_IsThisAComment(CodeLine As String) As Boolean
        If MyLeft(CodeLine, Len(MyUniverse.SysGen.Markers.Comments)) = MyUniverse.SysGen.Markers.Comments Then
            Return True
        End If
        If MyLeft(CodeLine, Len(Options.ListBoxSymbolData.Items.Item(21).ToString)) = Options.ListBoxSymbolData.Items.Item(21).ToString Then
            Return True
        End If
        'If  Do_Not_Use_IsThisAMarker(SourceForm ,  CodeLine) <> "" Then Return False
        Return False
    End Function




    'Test if the string is all digits
    Friend Function Do_Not_Use_IsThisANumber(ByRef SourceForm As Source, CodeLine As String) As Boolean
        Dim A As String
        A = CodeLine
        'might start with a "-" sign
        'todo might be numbers.13523
        If MyLeft(A, Len(MyUniverse.SysGen.Markers.Numbers)) = MyUniverse.SysGen.Markers.Numbers Then Return True
        If Do_Not_Use_IsThisAMarker(SourceForm, A) <> "" Then Return False
        Select Case (MyUnicode.UnicodeClassCode(CodeLine))
            Case "Unicode.Nd", "Unicode.Nl", "Unicode.No", "Nd", "Nl", "No"
                Return True
            Case "Unicode.Pd", "Pd" 'this is a dash (or something like it)
                Return True
            Case Else
                Return False
        End Select
        'If MyLeft(A, 1) >= "0" And MyLeft(A, 1) <= "9" Then Return True
        'If Len(A) > 1 Then
        ' If MyLeft(A, 1) = "+" Or MyLeft(A, 1) = "-" Or MyLeft(A, 1) = "." Or MyLeft(A, 1) = "," Then
        ' If Mid(A, 2, 1) >= "0" And Mid(A, 2, 1) <= "9" Then
        ' Return True
        ' End If
        ' End If
        ' End If
        ' Return False
    End Function


    'Test if the string is all alpha characters

    Friend Function Do_Not_Use_IsThisAnAlphaNumeric(ByRef SourceForm As Source, CodeLine As String) As Boolean
        If Do_Not_Use_IsThisAnAlpha(SourceForm, CodeLine) = True Then Return True
        If Do_Not_Use_IsThisANumber(SourceForm, CodeLine) = True Then Return True
        Return False
    End Function
    Friend Function Do_Not_Use_IsThisAnAlpha(ByRef SourceForm As Source, InputCodeLine As String) As Boolean
        Static LastCodeLine As String
        Static LastRTN As Boolean
        Dim CodeLine As String
        CodeLine = InputCodeLine
        If MyStrComp(LastCodeLine, CodeLine) = 0 Then Return LastRTN
        LastCodeLine = CodeLine
        If MyLeft(CodeLine, Len(MyUniverse.SysGen.Markers.Alphas)) = MyUniverse.SysGen.Markers.Alphas Then
            LastRTN = True
            Return True
        End If
        If MyLeft(CodeLine, 1) = "'" Then
            CodeLine = Pop_Literal(CodeLine)
            If CodeLine = "" Then
                CodeLine = InputCodeLine
            End If
        End If
        If Do_Not_Use_IsThisAMarker(SourceForm, CodeLine) <> "" Then
            LastRTN = False
            Return False ' Any other marker
        End If
        If MyLeft(CodeLine, Len(MyUniverse.SysGen.Markers.Alphas)) = MyUniverse.SysGen.Markers.Alphas Then
            LastRTN = True
            Return True
        End If
        If IsThisAWhiteSpace(CodeLine) <> "" Then
            LastRTN = False
            Return False
        End If

        Select Case MyUnicode.UnicodeClassCode(CodeLine)
            Case "Unicode.Ll" 'lower case letter
                LastRTN = True
                Return True
            Case "Unicode.LU" 'upper case letter
                LastRTN = True
                Return True
            Case "Unicode.Cc", "Unicode.Cf", "Unicode.Co", "Unicode.Cs",
"Unicode.Lm", "Unicode.Lo", "Unicode.Lt",
"Unicode.Mc", "Unicode.Me", "Unicode.Mn",
"Unicode.Nd", "Unicode.Nl", "Unicode.No",
"Unicode.Pc", "Unicode.Pd", "Unicode.Pe", "Unicode.Pf", "Unicode.Pi", "Unicode.Po", "Unicode.Ps",
"Unicode.Sc", "Unicode.Sk", "Unicode.Sm", "Unicode.So",
"Unicode.Zl", "Unicode.Zp", "Unicode.Zs"
                LastRTN = False
                Return False
            Case Else
                LogDebug(3471, Err7, CodeLine & vbTab & vbTab & MyUnicode.UnicodeClassCode(CodeLine))
                LogDebug(3472, Err7, CodeLine & " is Not An alpha, but a unicode character class of " & MyUnicode.UnicodeClassCode(CodeLine))
                'log_X(1028, CodeLine, MyUnicode.UnicodeClassCode(CodeLine))
        End Select
        LastRTN = False
        Return False
    End Function


    Friend Function Do_Not_Use_IsThisAWhiteSpace(ByRef SourceForm As Source, CodeLine As String) As Boolean
        If Len(CodeLine) = 0 Then Return False
        If MyInStr(MyLeft(CodeLine, 1), MyUniverse.SysGen.Constants.ConstantWhiteSpaces) > 0 Then
            Return True
        Else
            Return False
        End If
    End Function


    'Test if the string is special character mark
    Friend Function Do_Not_Use_IsThisASpecialCharacter(ByRef SourceForm As Source, CodeLine As String) As Boolean
        If Len(CodeLine) = 0 Then Return False
        If MyLeft(CodeLine, Len(MyUniverse.SysGen.Markers.SpecialCharacter)) = MyUniverse.SysGen.Markers.SpecialCharacter Then
            Return True
        End If
        If MyInStr(".BNF", CodeLine) <> 0 Then
            Return True
        End If
        If Do_Not_Use_IsThisAMarker(SourceForm, CodeLine) <> "" Then
            Return False
        End If
        If Do_Not_Use_IsThisAVariableNameX(SourceForm, CodeLine) = True Then
            Return False ' if it is a variable name (including special characters for this language
        End If
        'todo need to go through all of the characters of CodeLine ?
        'todo make sure that special characters for this language for this variable is not included
        'todo change special to be bnfRuleName.Special Character
        'todo phase 2 There should only be reduced items 
        'todo phase 2 keywords made from the bnf/grammar
        'todo phase 2 operators made from a selection from a list (enum) in the form of bnfRuleName.CharacterUsed
        'todo phase 2    operators/() [] {} etc 
        'todo phase 2 variables PointName.AttributeValue
        'todo phase 2 change most of the markers to be bnfRuleName.Selection
        If Do_Not_Use_IsThisALiteral(CodeLine) Then
            Return False
        End If
        'If MyLeft(CodeLine, 1)="'" And MyRight(CodeLine, 1)="'" Then Return False
        'If  Do_Not_Use_IsThisALiteral(CodeLine) Then Return False
        If MyInStr(MyLeft(CodeLine, 1), MyUniverse.SysGen.Constants.ConstantSpecialCharacters) > 0 Then
            Return True
        Else
            Return False
        End If

    End Function


    Friend Function Do_Not_Use_IsThisALetterRange(ByRef SourceForm As Source, T As String) As Boolean
        If T = "-" Then Return False
        If MyInStr("-", T) = 0 Then Return False
        Select Case Len(T)
            Case 3
                If Mid(T & VBSpace, 2, 1) = "-" Then
                    If AscW(Mid(T, 1, 1)) < AscW(Mid(T, 3, 1)) Then
                        Return True
                    End If
                End If
            Case 5
                If Mid(T, 3, 1) = "-" Then
                    If Do_Not_Use_IsThisALiteral(T) Then 'MyLeft(T, 1)="'" And MyRight(T, 1)="'" Then
                        If MyInStr("-", T) <> 0 Then
                            Return True
                        End If
                    ElseIf MyInStr("-", T) <> 0 Then
                        If MyInStr("-", T) > 1 Then
                            If MyInStr("-", T) < Len(T) Then
                                If MyDebug(A_FMB) Then logA(2381, AscW(T).ToString, AscW(Mid(T, MyInStr("-", T) + 1, 1)).ToString)
                                Return True
                            End If
                        End If
                    Else
                        If MyInStr("-", T) <> 0 Then
                            Return True
                        End If
                    End If
                End If
        End Select
        Return False
    End Function



    'find pairs of matching containers (IE () or {} etc ... )
    Friend Function Block(ByRef CL As String) As String
        Dim I, T1 As Integer
        Dim A, B, C As String
        Dim debugLevel As Integer = A_STATUS
        For I = 1 To MySizeOf(Language_Blocks)
            If Len(Language_Blocks(I)) > 0 Then
                If MyDebug(debugLevel) Then logA(2916, Language_Blocks(I), CL)
                A = MyTrim(CL)
                B = Language_Blocks(I)
                T1 = CInt(Len(B) / 2)
                C = MyRight(B, T1)
                B = MyLeft(B, T1)
                'If MyDebug(debugLevel) Then
                If Len(B) <> T1 Then logA(2387, T1.ToString, B)
                If Len(C) <> T1 Then logA(2387, T1.ToString, C)
                'End If
                If MyLeft(A, T1) = B Then
                    If MyInStr(C, A, T1 + 1) <> 0 Then
                        'todo need to remove from CL before returning
                        Return Mid(A, T1 + 1, MyInStr(C, A, T1 + 1) - Len(Language_Blocks(I)))
                    End If
                End If
            End If
        Next
        'find the first block
        ''< >'      ' '     ""   ( )   { }   ( )    < >
        Return "" 'todo
    End Function







    Friend Function NoBlock(Quoted As String) As String
        Return Block(Quoted)
    End Function

    Friend Function MyShowFormSize(A As Control) As String
        Return "(" & A.Top.ToString & ", " & A.Left.ToString & ")_(" & A.Size.Height.ToString & ", " & A.Size.Width.ToString & ")"
    End Function



    Friend Function MyShowAForm(ByRef SourceForm As Source, A As Form) As String
        Dim B As String
        Dim E As Control
        B = "--->" & A.Name & "<--- , " & MyShowLineXYXY(A.Left, A.Top, A.Left + A.Width, A.Top + A.Height)
        For Each E In A.Controls
            'if MyDebug(a_fmb) then log_X ( 2678, E.Name,  E.Text)
            B &= E.Name & ", " & E.Text & ", "
            If E.Name = "PictureBox1" Then
                B &= " Picture size " & E.Name & ",top " & E.Top.ToString & ",left " & E.Left.ToString & ",height " & E.Size.Height.ToString & ",width " & E.Size.Width.ToString & "," & MyShowFormSize(E)
            End If
        Next
        B &= " Number of Controls " & A.Controls.Count.ToString & VBSpace
        B &= " Size of window " & MyShowPoints(SourceForm, A.Left, A.Top, A.Width, A.Height)
        Return B
    End Function



    Friend Function TranslateWord(EnglishWord As String) As String
        Dim I As Integer
        If EnglishWord = "" Then Return ""
        If MySizeOf(English2Word) < 2 Then
            Return EnglishWord
        End If
        For I = LBound(English2) To MySizeOf(English2)
            If English2(I) = EnglishWord Then
                Return English2Word(I)
            End If
        Next
        Return Trim(EnglishWord)
    End Function

    Friend Function Translate(EnglishWord_In As String) As String
        Dim Temp As String
        Temp = EnglishWord_In
        Translate = ""
        While Len(Temp) > 0
            Translate &= TranslateWord(Pop(Temp, " ,")) & VBSpace
        End While
        Translate = Translate.Replace(",", ", ")
        Translate = Translate.Replace(" ", VBSpace)
    End Function


    Friend Function E2S(MyError As String) As String
        Return ErrorLevel2String(String2ErrorLevel(MyError))
    End Function


    Friend Function ErrorLevel2String(MyErrorLevel As Integer) As String
        Select Case MyErrorLevel
            Case 1
                Return "Error"
            Case 2
                Return "Warning"
            Case 3
                Return "Notice"
            Case 4
                Return "Information"
            Case 5
                Return "Display"
            Case 6
                Return "Status"
            Case 7
                Return "FlowChart"
            Case 8
                Return "debugging"
            Case 9
                Return "FindMyBugs"
            Case 10
                Return "BUG"
            Case Else
                logA(1717, MyErrorLevel.ToString)
                Return "ERROR"
        End Select

    End Function



    Friend Function String2ErrorLevel(Err As String) As Integer
        Select Case Err
'A_BUG ,msgbox, log
'A_ERROR ,msgbox, log
            Case "error", "bug", "msgbox", "1"
                Return 1
        'A_WARNING, msgbox, log
            Case "warning", "2"
                Return 2
        'A_NOTICE, msgbox, log
            Case "wrong", "Notice", "3"
                Return 3
        'A_INFORMATION, log
            Case "information", "4"
                Return 4
        'A_DISPLAY, log
            Case "display", "follow", "log", "5"
                Return 5
        'A_STATUS, no msg or log
            Case "status", "sort", "sorts", "graphics", "loops", "while", "for", "6"
                Return 6
        'A_FLOWCHART, ERROR@(), log
            Case "flowchart", "7"
                Return 7
        'A_DEBUG, msgbox, log
            Case "debug", "debugging", "8"
                Return 8
        'A_FMB, msgbox, log
            Case "FindMyBugs", "FMB", "9"
                Return 9
            Case Else 'default to a bug/error
                Return 1
        End Select

    End Function


    Friend Function MyDebug(debugLevel As Integer) As Boolean
        If MyUniverse.FCCLDebugLevel_1 = 0 Then Return False      'not set yet
        If MyUniverse.FCCLDebugLevel_1 >= debugLevel Then Return True
        Return False
    End Function

    Friend Function MyDebug2(debugLevel As Integer) As Boolean
        If MyUniverse.FCCLDebugLevel_2 = 0 Then Return False      'not set yet (or set to disable msgbox()
        If MyUniverse.FCCLDebugLevel_2 >= debugLevel Then Return True
        Return False
    End Function

    'Use these to follow all graphic draws
    Friend Sub FlowChartDelete(ByRef SourceForm As Source, IndexFlowChart As Integer)
        If MyDebug(A_INFORMATION) Then logA(4280, IndexFlowChart.ToString)
        FlowChart_TableCode(SourceForm, IndexFlowChart, "/delete")
    End Sub
    Friend Function FlowChartRecordMatches(ByRef SourceForm As Source, IndexFlowChart1 As Integer, IndexFlowChart2 As Integer) As Boolean
        If IndexFlowChart1 = IndexFlowChart2 Then Return False
        If FlowChart_tablePathSymbolName(SourceForm, IndexFlowChart1) <> FlowChart_tablePathSymbolName(SourceForm, IndexFlowChart2) Then Return False
        If FlowChart_tableCoded(SourceForm, IndexFlowChart1) <> FlowChart_tableCoded(SourceForm, IndexFlowChart2) Then Return False
        If FlowChart_TableX1(SourceForm, IndexFlowChart1) <> FlowChart_TableX1(SourceForm, IndexFlowChart2) Then Return False
        If FlowChart_TableY1(SourceForm, IndexFlowChart1) <> FlowChart_TableY1(SourceForm, IndexFlowChart2) Then Return False
        If FlowChart_TableX2(SourceForm, IndexFlowChart1) <> FlowChart_TableX2(SourceForm, IndexFlowChart2) Then Return False
        If FlowChart_TableY2(SourceForm, IndexFlowChart1) <> FlowChart_TableY2(SourceForm, IndexFlowChart2) Then Return False
        If FlowChart_TableDataType(SourceForm, IndexFlowChart1) <> FlowChart_TableDataType(SourceForm, IndexFlowChart2) Then Return False


        Return True
    End Function


    'looking if inside the flow chart window
    Friend Sub FMB(A As String, B As String)
        Dim cmpText, cmpBinary, MyCombare, MyCmp As Integer
        cmpText = StrComp(A, B, CompareMethod.Text)
        cmpBinary = StrComp(A, B, CompareMethod.Binary)

        If A = B Then MyCombare = 0
        If A > B Then MyCombare = 1
        If A < B Then MyCombare = -1

        MyCmp = 0
        If Len(A) = 0 Then
            A = VBSpace
            MyCmp = -2
        End If
        If Len(B) = 0 Then
            B = VBSpace
            MyCmp = 2
        End If
    End Sub

    Friend Function ISAMErrorAt(LB As ListBox) As Integer
        Dim I As Integer
        I = 1
        While I < TopOfListBox(LB) - 1 And I > 0 And I + 1 > 0
            LogDebug(3474, Err7, I.ToString & vbTab & vbTab & I.ToString & vbTab & vbTab & GetMyRecord(LB, I) & vbTab & vbTab & GetMyRecord(LB, I + 1))
            If MyStrComp(GetMyRecord(LB, I), GetMyRecord(LB, I + 1)) > 0 Then
                Return I
            End If
            I += 1
        End While
        Return 0
    End Function



    Friend Function Do_Not_Use_IsThisAHexDigitRange(A As String) As Boolean
        Dim I, J, K As Integer
        'todo this needs to return all of the following formats
        '0X0000-0X0000'
        'X-0X0000'
        'X-Z'
        If Len(A) = 3 And Do_Not_Use_IsThisALiteral(A) Then Return False '   IE '-'
        If Len(A) < 3 Then Return False
        'I=InStr(A, "0X027")
        If Len(A) = 3 Then
            If Mid(A, 2, 1) = "-" Then
                If Mid(A, 1, 1) > Mid(A, 3, 1) Then Return True
            End If
        End If

        I = MyInStr("0X", A)
        J = MyInStr("-", A)
        K = MyInStr("0X", A, I + 1)
        If I = 0 And J = 0 And K = 0 Then Return False

        If K = 0 And I > J And I > 0 Then
            Return True
        End If
        If I > 0 And J > 0 And K > 0 And J > I And K < J Then
            Return True
        End If

        If I > J And I < K And J > K Then
            Return True
        End If
        If I = 0 And K = 0 And J <> 0 Then
            If Do_Not_Use_IsThisALiteral(A) Then
                If Len(A) = 5 And J = 3 Then
                    Return True
                End If
                Return False
            Else
                If Len(A) = 3 And Mid(A, 2, 1) = "-" Then
                    Return True
                End If
            End If
        End If
        Return False

    End Function


    Friend Function Do_Not_Use_IsThisAHexDigit(A As String) As Boolean
        Dim I As Integer
        If Len(A) = 0 Then Return False

        For I = 1 To Len(A)
            Select Case Mid(A, I, 1)
                Case "1", "2", "3", "4", "5", "6", "7", "8", "9", "0", "a", "b", "c", "d", "e", "f", "A", "B", "C", "D", "E", "F"
                Case Else
                    Return False
            End Select
        Next I
        Return True

        'If MyUnicode.FindUnicodeClass(A) = "Nd" Then Return True
        'If MyUnicode.FindUnicodeClass(A) = "Nl" Then Return True
        'If MyUnicode.FindUnicodeClass(A) = "No" Then Return True
        'if MyDebug(a_fmb) then log_X ( 2829)
    End Function



    Friend Function Bin2Hex(N As Long) As String
        Dim Rtn As String
        Rtn = Hex(N)
        If Len(Rtn) < 4 Then
            Rtn = MyRight("000000" & Rtn, 4)
        End If
        Return "0X" & Rtn
    End Function


    Friend Function Str2Hex(a As String) As String
        If "0" & MyRight("0000" & Hex(AscW(a)), 4) <> MyRight("0000" & Hex(AscW(a)), 5) Then
            If MyDebug(A_ERROR) Then logA(2736, MyRight("0000" & Hex(AscW(a)), 4), MyRight("0000" & Hex(AscW(a)), 5))
        End If
        Str2Hex = MyRight("0000" & Hex(AscW(a)), 4) 'add leading zeros
    End Function

    Friend Function Fix0X(A As String) As String
        'Convert the 0x???? to be the uniCode character
        Dim C, D As String
        Dim I As Integer
        Fix0X = A.Replace("0x", "0X")
        Fix0X = Fix0X.Replace("&h", "0X")
        Fix0X = Fix0X.Replace("&H", "0X")
        I = MyInStr("0X", Fix0X)
        While I <> 0
            C = Mid(Fix0X, I, 6)
            D = Mid(Fix0X, I - 1, 8)
            logA(1116, Fix0X, D, C, ChrW(Hex2Bin(C)), A)
            Fix0X = Fix0X.Replace(D, ChrW(Hex2Bin(C)))
            I = MyInStr("0X", Fix0X)
        End While
    End Function


    Friend Function Hex2Bin(HEX0x0000 As String) As Integer
        Dim A As String

        If HEX0x0000 = MyUniverse.MyStaticData.LastHex Then Return MyUniverse.MyStaticData.LastValue
        If HEX0x0000 = "" Then Return -1
        A = MyTrim(HEX0x0000)
        A = TrimOff(A, "'")
        A = TrimOff(A, ";")
        'todo this should also have an error message
        If A = "0X" Then Return &HFFFFF 'todo should not return everything, and should have log_X error 
        If MyLeft(A, 2) = "0X" And MyInStr("-", A) = 0 Then
            A = Mid(A, 3) 'remove the 0x
        Else
            'should return
            'log_X(1032, "Hex string only " & HEX0x0000)
            Return ConstantMyErrorCode
        End If
        A = Trim(A)

        If Do_Not_Use_IsThisAHexDigit(A) = True Then
            MyUniverse.MyStaticData.LastHex = HEX0x0000
            MyUniverse.MyStaticData.LastValue = Convert.ToInt32(A, 16)
            Return Convert.ToInt32(A, 16)
        Else
            LogDebug(1045, Err7, "@ HEX2BIN can not convert " & A & vbTab & vbTab & HEX0x0000)
            LogDebug(3475, Err7, Convert.ToInt32(A, 16).ToString)
        End If
        Return -1
    End Function


    Friend Function MyLine(X1 As Integer, Y1 As Integer, X2 As Integer, y2 As Integer) As MyLineStructure
        MyLine = Nothing
        MyLine.a.x = X1
        MyLine.a.y = Y1
        MyLine.b.x = X2
        MyLine.b.y = y2
    End Function
    Friend Function MyLine(A As MyPointStructure, B As MyPointStructure) As MyLineStructure
        MyLine = Nothing
        MyLine.a.x = A.x
        MyLine.a.y = A.y
        MyLine.b.x = B.x
        MyLine.b.y = B.y
    End Function

    Friend Function MyLine(ByRef SourceForm As Source, Index As Integer) As MyLineStructure
        Dim X As String
        MyLine = Nothing
        X = GetMyRecord(SourceForm.ListBoxFlowChart, Index)
        DropParse(X, ",", "")
        MyLine.a.x = My_INT(Parse(X, ",", "")) : X = DropParse(X, ",", "")
        MyLine.a.y = My_INT(Parse(X, ",", "")) : X = DropParse(X, ",", "")
        MyLine.b.x = My_INT(Parse(X, ",", "")) : X = DropParse(X, ",", "")
        MyLine.b.y = My_INT(Parse(X, ",", "")) : X = DropParse(X, ",", "")
    End Function


    Friend Function Hex2BinX(HEX0x0000 As String) As Integer
        If MyLeft(HEX0x0000, 2) = "0x" Then
            Return Convert.ToInt32(Mid(HEX0x0000, 3), 16)
        Else
            Return Convert.ToInt32(HEX0x0000, 16)
        End If
    End Function


    Friend Function XTrim(StringToTrim As String) As String
        Return TrimOff(StringToTrim, FD)
    End Function

    Friend Function TrimOff(A As String, Remove As String) As String
        If Len(Remove) = 0 Then Return A
        TrimOff = Trim(A)
        While MyLeft(TrimOff, Len(Remove)) = Remove
            TrimOff = Mid(TrimOff, Len(Remove) + 1)
        End While
        While MyRight(TrimOff, Len(Remove)) = Remove
            TrimOff = MyLeft(TrimOff, Len(TrimOff) - Len(Remove))
        End While
    End Function



    Friend Function IsHex(A As String) As Boolean
        ' DIM   I As Integer
        'For I = 1 To Len(A)
        'If Not  Do_Not_Use_IsThisAHexDigit(Mid(A, I, 1)) Then
        If Not Do_Not_Use_IsThisAHexDigit(A) Then
            Return False
        End If
        'Next
        Return True
    End Function


    'this returns what this is
    'character '?'
    'character <Unicode '0X####'>
    'letter (Unicode) <Unicode ... > )
    Friend Function GetHex(A As String) As String
        Dim I As Integer

        GetHex = ""
        I = MyInStr("0X", A) + 2
        If I = 0 Then Return ""
        If I < 1 Or I > Len(A) Then I = 1

        While Do_Not_Use_IsThisAHexDigit(Mid(A, I, 1)) = True
            GetHex &= Mid(A, I, 1)
            If I > Len(A) + 2 Then
                If Len(GetHex) <> 4 Then
                    Log(1074, Err1, "H " & "ERROR all hex needs to be 4 characters:" & Len(A))
                End If

                Return "0X" & GetHex
            End If
            I += 1
        End While

        Return "0X" & GetHex '"0X" & GetHex
    End Function


    Friend Sub FixDataType(ByRef SourceForm As Source, IndexFlowChart As Integer)
        Dim X As String
        If Len(FlowChart_TableDataType(SourceForm, IndexFlowChart)) > 1 Then Return
        X = FlowChart_TableCode(SourceForm, IndexFlowChart)
        Select Case X
            Case "/path"
                ' this is a path with out a datatype so see if there is a datatype that can be used.
                'First check for the netLinks
                ' next check for another path segment with the same name that has a dataType define
                ' last assign this to Errored data type
                If Len(FlowChart_TableDataType(SourceForm, IndexFlowChart)) < 1 Then
                    FlowChart_TableDataType(SourceForm, IndexFlowChart, "Errored")
                End If
            Case Else
                Return
        End Select
    End Sub


    'change all <variable space name>   to variable_space_name
    Friend Function FixEBNFbrackets(Code_Line As String) As String
        Dim I, J, K As Integer
        Dim RTN As String = Code_Line
        Dim FLAG As Boolean = True
        If MyOptionTest(57) Then Return Code_Line
        If MyStrComp(UCase(Code_Line), "/GRAMMAR") <> 0 Then Return Code_Line
        While FLAG = True
            FLAG = False
            I = MyInStr("<", RTN)
            J = MyInStr(">", RTN)
            If I = 0 Or J = 0 Then Return RTN
            For K = I To J
                If Mid(RTN, K, 1) = VBSpace Then
                    Mid(RTN, K, 1) = "_"
                    FLAG = True
                End If
            Next
            If FLAG = True Then
                Mid(RTN, I, 1) = VBSpace
                Mid(RTN, J, 1) = VBSpace
            End If
        End While
        Return RTN
    End Function


    Friend Function MyHex2Char(Code_Line As String) As String ' This will change '<0X????>' and '<0X????-0X????>' to characters
        Dim I As Integer
        Dim Temp As String
        Dim ErrorCount As Integer = 64

        MyHex2Char = MyTrim(Code_Line)

        'todo this needs to only replace on an option()
        MyHex2Char = MyHex2Char.Replace("&h", "0X") 'change from basic default to other HEX
        MyHex2Char = Trim(FixEBNFbrackets(MyHex2Char))

        'Temp = Trim(Code_Line)
        If MyInStr("::=", Code_Line) = 0 Then Return Code_Line 'todo need to add an error message, because every grammar should have a ::= 
        'Temp = Trim(FixEBNFbrackets(MyHex2Char))
        'Temp = Trim(Mid(Temp, 1, MyInStr("::=", Temp) - 1))

        While MyInStr("0X", MyHex2Char) > 0 And ErrorCount > 0
            ErrorCount -= 1 ' This is because 0X000C will never be replaced because there is an upper case and a lower case, and I test for all the same case
            'todo fix this hack above, and change all 0X???? to decimal
            Temp = GetHex(MyHex2Char)
            I = Hex2Bin(Temp)
            'todo Note that hex values must all be upper or lower case so that 0X000D is invalid - Need to fix
            If I >= -32768 And I <= 65535 Then
                MyHex2Char = MyReplace(MyHex2Char, Temp, ChrW(I))
            Else
                MyHex2Char = MyHex2Char.Replace(Temp, Char.ConvertFromUtf32(I))
                logA(1851, Bin2Hex(I), Temp, Code_Line, MyHex2Char, Len(Temp).ToString)
            End If
        End While

        Return MyHex2Char
    End Function


    Friend Function WhatIsThisBlock(CodeLine As String) As String
        Dim I, J As Integer
        Dim T1, T2, T3 As String

        'todo this should see what this code Line block does (assume that it is a Unicode character for now, but add the others things later.
        WhatIsThisBlock = ""
        If Trim(CodeLine) = "" Then
            Return ""
        End If
        If Len(CodeLine) = 1 Then
            Return CodeLine
        End If
        If MyInStr("0X", CodeLine) <> 0 And MyInStr("Unicode", LCase(CodeLine)) <> 0 Then 'this has a Unicode character defined maybe
            I = MyInStr("0X", CodeLine)
            J = MyInStr("Unicode", CodeLine)
            If J > I Then Return "" 'error?
            'not used? WhatIsThisBlock=Mid(CodeLine, I + 2, 4) 'debug only
            If IsMyDigit(Mid(CodeLine, I + 2, 1)) = False Then
                Return ""
            End If
            If IsMyDigit(Mid(CodeLine, I + 3, 1)) = False Then
                Return ""
            End If
            If IsMyDigit(Mid(CodeLine, I + 4, 1)) = False Then
                Return ""
            End If
            If IsMyDigit(Mid(CodeLine, I + 5, 1)) = False Then
                Return ""
            End If
            WhatIsThisBlock = CodeLine.Replace(Mid(CodeLine, I, 6), ChrW(Hex2Bin(Mid(CodeLine, I + 2, 4))))
        ElseIf MyInStr("Unicode", CodeLine) <> 0 Then
            Return "X"
        ElseIf MyLeft(CodeLine, 1) = "'" And MyInStr("'", CodeLine, 2) <> 0 Then 'it is a Constant
            If MyInStr(VBSpace, CodeLine) <> 0 Then
                logA(2198, CodeLine)
                Return ""
            Else

                If Len(CodeLine) < 2 Then
                    Return Trim(CodeLine)
                End If
                Return Mid(CodeLine, 2, Len(CodeLine) - 2) 'keyword
            End If
        ElseIf MyLeft(CodeLine, 10) = "'<Unicode " Then
            ' removed not needed ?                T1=Pop(CodeLine, VBSpace) 'Unicode
            T2 = Pop(CodeLine, VBSpace) 'name of character
            Select Case LCase(T2)
                Case "classes"

                    While Len(CodeLine) > 0
                        T3 = Pop(CodeLine, " |,>'")
                        Select Case T3
                            Case "Unicode.Ll"
                                WhatIsThisBlock &= " Ll "
                            Case "Unicode.Cc"
                                WhatIsThisBlock &= " ??? "
                            Case "Unicode.Cf"
                                WhatIsThisBlock &= " ??? "
                            Case "Unicode.Co"
                                WhatIsThisBlock &= " ??? "
                            Case "Unicode.Cs"
                                WhatIsThisBlock &= " ??? "
                            Case "Unicode.Ll"
                                WhatIsThisBlock &= " ??? "
                            Case "Unicode.Lm"
                                WhatIsThisBlock &= " Lm "
                            Case "Unicode.Lo"
                                WhatIsThisBlock &= " Lo "
                            Case "Unicode.Lt"
                                WhatIsThisBlock &= " Lt "
                            Case "Unicode.Lu"
                                WhatIsThisBlock &= " Lu "
                            Case "Unicode.Mc"
                                WhatIsThisBlock &= " ??? "
                            Case "Unicode.Me"
                                WhatIsThisBlock &= " ??? "
                            Case "Unicode.Mn"
                                WhatIsThisBlock &= " ??? "
                            Case "Unicode.Nd"
                                WhatIsThisBlock &= " ??? "
                            Case "Unicode.Nl"
                                WhatIsThisBlock &= " Nl "
                            Case "Unicode.No"
                                WhatIsThisBlock &= " ??? "
                            Case "Unicode.Pc"
                                WhatIsThisBlock &= " ??? "
                            Case "Unicode.Pd"
                                WhatIsThisBlock &= " ??? "
                            Case "Unicode.Pe"
                                WhatIsThisBlock &= " ??? "
                            Case "Unicode.Pf"
                                WhatIsThisBlock &= " ??? "
                            Case "Unicode.Pi"
                                WhatIsThisBlock &= " ??? "
                            Case "Unicode.Po"
                                WhatIsThisBlock &= " ??? "
                            Case "Unicode.Ps"
                                WhatIsThisBlock &= " ??? "
                            Case "Unicode.Sc"
                                WhatIsThisBlock &= " ??? "
                            Case "Unicode.Sk"
                                WhatIsThisBlock &= " ??? "
                            Case "Unicode.Sm"
                                WhatIsThisBlock &= " ??? "
                            Case "Unicode.So"
                                WhatIsThisBlock &= " ??? "
                            Case "Unicode.Zl"
                                WhatIsThisBlock &= " ??? "
                            Case "Unicode.Zp"
                                WhatIsThisBlock &= " ??? "
                            Case "Unicode.Zs"
                                WhatIsThisBlock &= " ??? "
                            Case Else
                                WhatIsThisBlock &= " unknown "
                        End Select
                    End While

                    Return WhatIsThisBlock
                Case Else 'todo add this
                    logA(2149, CodeLine)
            End Select
            ' removed not needed ?J=InStr(I + 1, CodeLine, VBSpace)
            If MyDebug(A_FMB) Then logA(2159, CodeLine, WhatIsThisBlock)
        Else

            While Len(CodeLine) > 0
                T1 = Pop(CodeLine, " ,|")
                T2 = Pop(CodeLine, " ,|")
                WhatIsThisBlock &= VBSpace & T1 'WhatIsThisBlock(T1)
                WhatIsThisBlock &= VBSpace & T2 'WhatIsThisBlock(T2)
            End While

            Return Trim(WhatIsThisBlock)
        End If
    End Function

    Friend Function IsThisASymbolName(ByRef SourceForm As Source, TPar As String) As Boolean
        If FindInSymbolList(SourceForm, TPar) > 0 Then
            Return True
        End If
        Return False
    End Function
    Friend Function Do_Not_Use_IsThisABlock(CodeLine As String) As Boolean ' returns is this is the start of a quote
        If Block(CodeLine) = "" Then Return False
        Return True
    End Function

    Friend Function Pop_Block(CodeLine As String) As String ' returns is this is the start of a quote
        Dim A As String
        A = Block(CodeLine)
        CodeLine = MyReplace(CodeLine, A, "")
        Return A
    End Function









    'Test if imbedded mark for a quote
    Friend Function Do_Not_Use_IsThisAQuote(CodeLine As String) As Boolean ' returns is this is the start of a quote
        If MyLeft(CodeLine, Len(MyUniverse.SysGen.Constants.ConstantQuote)) <> MyUniverse.SysGen.Constants.ConstantQuote Then Return False
        If MyInStr(MyUniverse.SysGen.Constants.ConstantQuote, CodeLine, Len(MyUniverse.SysGen.Constants.ConstantQuote)) = 0 Then Return False
        Return True
    End Function



    ' We are still not finding it in the list even tho it is there (Found with a loop through them all
    Friend Function Do_Not_Use_IsThisAKeyWord(ByRef SourceForm As Source, CodeLine As String) As Boolean ' returns is this is in the keyword list (ignores markers)
        Dim I As Integer
        Dim B As String
        If CodeLine = "" Then Return False
        B = TrimOff(CodeLine, "'")
        B = Trim(Pop1(SourceForm, B, MyUniverse.SysGen.Constants.ConstantWhiteSpaces))  ' Trim(Pop1(SourceForm, B, MyUniverse.SysGen.Constants.ConstantDelimiters))
        If MyIsNothing(B) Or B = "" Then Return False
        'MyUniverse.SysGen.Markers.KeyWords
        I = BinarySearch4Index(Options.ListBox_KeyWords, B)
        If I > Options.ListBox_KeyWords.Items.Count - 1 Then
            logA(1265, I.ToString, (Options.ListBox_KeyWords.Items.Count - 1).ToString)
        End If
        If I > 0 Then
            If Options.ListBox_KeyWords.Items(I) = B Then
                Return True
            Else
                I = BinarySearch4Index(Options.ListBox_KeyWords, B, Options.ListBox_KeyWords) 'todo debug only remove
                Return False
            End If
        End If

        ' Else we have to search it item by item (and resort it also
        For I = 1 To Options.ListBox_KeyWords.Items.Count
            If MyStrComp(B, Options.ListBox_KeyWords.Items(I).ToString) = 0 Then
                logA(1129, B, I.ToString)
                Return True
            End If
            If MyStrComp(MyLeft(B, Len(MyUniverse.SysGen.Constants.RMStart)), MyUniverse.SysGen.Constants.RMStart) = 0 Then
                If MyLeft(NoRM(B), 7) = "keyword" Then
                    Return True
                End If
            End If
        Next
        Return False
    End Function


    'Test if this is in the input operator list
    Friend Function IsThisA_Operator(ByRef SourceForm As Source, CodeLine As String) As Integer ' returns is this is in the keyword list (ignores markers)
        Dim I, K As Integer
        Dim A, B As String
        Dim C As Boolean
        If CodeLine = "''" Then
            Return ConstantMyErrorCode
        End If

        K = 0
        A = CodeLine
        B = A
        B = Trim(Pop1(SourceForm, B, MyUniverse.SysGen.Constants.ConstantWhiteSpaces)) ' to get just one word
        If MyIsNothing(B) Or B = "" Then Return 0
        ' Hardcoded for now all keyWord I can think of until I put it in a /Keyword,language,keyWord

        I = BinarySearch4Index(MyUniverse.SysGen.Markers.Operators, B, Language_Operator)
        If I > ConstantMyErrorCode Then
            'A=Language_Operator(I)
            If Language_Operator(I) = B Then
                Return I
            End If
            If Language_Operator(I) = TrimOff(B, "'") Then
                Return I
            End If
        Else
            C = False
            For I = 1 To MySizeOf(Language_Operator)
                If MyStrComp(B, Language_Operator(I)) = 0 Then
                    logA(2201, CodeLine, B, I.ToString)
                    C = True
                    K = I
                End If
                If A = Language_Operator(I) Then C = True
            Next
            If C = True Then Return K
        End If

        ' Else we have to search it item by item (and resort it also
        'todo need to remove this loop after debugging 
        If Do_Not_Use_IsThisAMarker(SourceForm, CodeLine) <> "" Then Return 0
        Return 0 ' Not an operator
    End Function

    Friend Function EndOfVariableName(ByRef SourceForm As Source, A As String) As Integer
        Dim rtn As Integer

        'todo tie all of the is this ... to the BNF input
        rtn = 1
        If Len(A) = 0 Then Return 0 'not the name of a variable
        If Do_Not_Use_IsThisAnAlpha(SourceForm, A) Then

            While rtn < Len(A) And Do_Not_Use_IsThisAnAlphaNumeric(SourceForm, Mid(A, rtn, 1))
                rtn += 1
            End While

            If rtn = Len(A) Then
                Return rtn
            Else
                Return rtn - 1 'cause the last letter is not an alpha
            End If
        End If
        Return 0
    End Function

    'Test if imbedded mark for a variable name
    Friend Function IsThisAVariableNameCharacter(ByRef SourceForm As Source, InputString As String) As Boolean
        Static LastInputString As String
        Static LastRtn As Boolean
        Dim A As String
        If MyStrComp(LastInputString, InputString) = 0 Then Return LastRtn
        LastInputString = InputString
        If Len(InputString) = 0 Then
            LastRtn = False
            Return False
        End If
        'A = MyLeft(InputString, 1)
        A = MyUnicode.UnicodeClassCode(InputString)
        Select Case A
            Case "Unicode.Lu", "Unicode.Ll", "unicode.Nd" 'letters and digits
                LastRtn = True
                Return True
            Case "Unicode.Nd", "Unicode.Nl", "Unicode.No"
                logA(1075, InputString)
            Case "Unicode.Sm", "Unicode.Ws"
                LastRtn = False
                Return False
            Case "Unicode.Cc", "Unicode.Cf", "Unicode.Co", "Unicode.Cs", "Unicode.Lm", "Unicode.Lo", "Unicode.Lt", "Unicode.Mc", "Unicode.Me", "Unicode.Mn", "Unicode.Pc", "Unicode.Pd", "Unicode.Pe", "Unicode.Pf", "Unicode.Pi", "Unicode.Po", "Unicode.Ps", "Unicode.Sc", "Unicode.Sk", "Unicode.So", "Unicode.Zl", "Unicode.Zp", "Unicode.Zs"
                ' test for other belowLogA(1056, A, InputString)
            Case Else
                logA(1057, A)
        End Select

        If MyFirstOne(MyUniverse.ProgramOptions.FCCL_VarChars, InputString) = 1 Then
            LastRtn = True
            Return True ' special characters that are also allowed
        End If
        LastRtn = False
        Return False
    End Function
    Friend Function Do_Not_Use_IsThisAVariableNameX(ByRef SourceForm As Source, InputLine As String) As Boolean
        Dim TS, TE, CodeLine As String
        If MyInStr("::=", InputLine) <> 0 Then Return False
        TS = MyUniverse.SysGen.Constants.RMStart
        TE = MyUniverse.SysGen.Constants.RMEnd
        CodeLine = InputLine
        If Len(InputLine) = 0 Then
            Return False
        End If

        If MyLeft(CodeLine, Len(TS)) = TS Then
            If MyInStr(TE, CodeLine) <> 0 Then
                If MyInStr(".", CodeLine) < MyInStr(TE, CodeLine) Then
                    Return True 'format ⬂???.????⬃
                End If
            End If
        End If

        If MyLeft(CodeLine, Len(TS)) = TS Then
            If MyRight(CodeLine, Len(TE)) = TE Then
                If MyInStr(".", CodeLine) <> 0 Then
                    Return True
                End If
            End If
        End If

        If Do_Not_Use_IsThisAMarker(SourceForm, CodeLine) <> "" Then
            Return False
        End If

        'todo this also has to include _ and other possible characters .
        CodeLine = InputLine
        If Pop_VariableName(SourceForm, CodeLine) <> "" Then
            Return True
        End If
        Return False
    End Function



    Friend Function MyInStr(find As String, InString As String, Optional StartAt As Integer = 1) As Integer
        Dim I, L As Integer

        'todo remove this 



        If Len(find) = 0 Then
            Return 0
        End If
        'L=AscW(find)
        'todo This needs to check that it is all ASCII, since instr() does not work with all Unicode character sets
        If AscW(find) < 255 Then
            I = InStr(StartAt, InString, find)
            If I <> 0 Then
                Return I
            End If
        End If
        I = InStr(StartAt, InString, find, CompareMethod.Binary)
        If I <> 0 Then
            Return I
        End If

        If Len(find) > Len(InString) Then
            Return 0
        End If

        'todo The following is because there is a 'bug' in inStr when the find is character 11011 or 11010 (and maybe others )
        L = Len(find)
        For I = StartAt To Len(InString) - Len(find)
            If I + L < Len(InString) Then
                If MyStrComp(find, InString.Substring(I, L)) = 0 Then
                    'LogDebug(3477,err7,MyStrComp(find, InString.Substring(I, L)).ToString & "mystr() error " & AscW(find) & find & "&&&&" & AscW(InString.Substring(I, L)) & InString.Substring(I, L) & ".#")
                    logA(1430,
                                  I.ToString,
                                  AscW(find) & ">" & find & "<",
                                  Mid(InString, MyMinMax(I - 8, 1, I + L + 8), L),
                                  find,
                                  InString,
                                  InStr(StartAt, InString, find).ToString,
                                  InStr(StartAt, InString, find, CompareMethod.Binary).ToString)
                    Return I
                End If
            End If
        Next
        Return 0
    End Function




    'returns the length of the marker (if any)
    ' returns zero if not a marker
    '21/02/2021 changed to return then name instead of the length
    Friend Function Do_Not_Use_IsThisAMarker(ByRef SourceForm As Source, CodeLine As String) As String ' this returns the length of the marker (Which is always 3, except for one case, and if it changes in the future)
        Dim X As String
        Dim Len1, Len2 As Integer
        Dim at1 As Integer

        Len1 = Len(MyUniverse.SysGen.Constants.RMStart)
        Len2 = Len(MyUniverse.SysGen.Constants.RMEnd)
        If Len(CodeLine) < Len1 + Len2 Then
            Return "" 'todo need to add error message here also
        End If

        at1 = MyInStr(MyUniverse.SysGen.Constants.RMEnd, CodeLine)
        If at1 = 0 Then Return ""
        ' All markers must start with ⬂
        If MyLeft(CodeLine, Len1) = MyUniverse.SysGen.Constants.RMStart And
                    Mid(CodeLine, at1, Len2) = MyUniverse.SysGen.Constants.RMEnd Then
            Return Mid(CodeLine, 1, at1)
            'todo need to make sure that there are not two markers in this code line
        Else
        End If
        If MyLeft(CodeLine, Len1) <> MyUniverse.SysGen.Constants.RMStart Then
            Return ""
        End If
        If MyLeft(CodeLine, Len(MyUniverse.SysGen.Markers.Quotes)) = MyUniverse.SysGen.Markers.Quotes Then Return MyUniverse.SysGen.Markers.Quotes
        'todo need to make this also look for ⬂name.PATH⬃ (or what ever ... )
        If MyLeft(CodeLine, Len(MyUniverse.SysGen.Markers.Numbers)) = MyUniverse.SysGen.Markers.Numbers Then Return MyUniverse.SysGen.Markers.Numbers
        If MyLeft(CodeLine, Len(MyUniverse.SysGen.Markers.Alphas)) = MyUniverse.SysGen.Markers.Alphas Then Return MyUniverse.SysGen.Markers.Alphas
        If MyLeft(CodeLine, Len(MyUniverse.SysGen.Markers.BranchToNextLine)) = MyUniverse.SysGen.Markers.BranchToNextLine Then Return MyUniverse.SysGen.Markers.BranchToNextLine
        If MyLeft(CodeLine, Len(MyUniverse.SysGen.Markers.CameFromLine)) = MyUniverse.SysGen.Markers.CameFromLine Then Return MyUniverse.SysGen.Markers.CameFromLine
        If MyLeft(CodeLine, Len(MyUniverse.SysGen.Markers.Comments)) = MyUniverse.SysGen.Markers.Comments Then Return MyUniverse.SysGen.Markers.Comments
        X = MyUniverse.ProgramOptions.FCCL_MultiLine : If MyLeft(CodeLine, Len(X)) = X Then Return X
        X = Options.ListBoxSymbolData.Items.Item(21).ToString : If MyLeft(CodeLine, Len(X)) = X Then Return X
        X = Options.ListBoxSymbolData.Items.Item(25).ToString : If MyLeft(CodeLine, Len(X)) = X Then Return X
        '    If MyLeft(CodeLine, Len(MyUniverse.SysGen.Markers.Variables))=MyUniverse.SysGen.Markers.Variables Then Return MyUniverse.SysGen.Markers.Variables
        If MyLeft(CodeLine, Len1) = MyUniverse.SysGen.Constants.RMStart Then
            If MyInStr(MyUniverse.SysGen.Constants.RMEnd, CodeLine) <> 0 Then
                If MyInStr(".", CodeLine) < MyInStr(MyUniverse.SysGen.Constants.RMEnd, CodeLine) Then
                    Return MyLeft(CodeLine, MyInStr(MyUniverse.SysGen.Constants.RMEnd, CodeLine)) 'todo removed +2 here 
                End If
            End If
        End If
        If Do_Not_Use_IsThisAMarker2(SourceForm, CodeLine) <> "" Then Return Do_Not_Use_IsThisAMarker2(SourceForm, CodeLine) ' Returns the length of this marker format MyFD(point.name )
        ' All special characters are after language special characters
        If MyLeft(CodeLine, Len(MyUniverse.SysGen.Markers.SpecialCharacter)) = MyUniverse.SysGen.Markers.SpecialCharacter Then Return MyUniverse.SysGen.Markers.SpecialCharacter

        Return Do_Not_Use_IsThisAMarker2(SourceForm, CodeLine) ' Not a marker but might still be one of this kind
    End Function

    Friend Function Do_Not_Use_IsThisAValidWord(ByRef SourceForm As Source, ReservedWord As String) As Boolean
        Dim X As String
        X = NoRM(ReservedWord)
        If Do_Not_Use_IsThisAKeyWord(SourceForm, X) Then Return True
        If Do_Not_Use_IsThisAVariableNameX(SourceForm, X) Then Return True
        '''''If Do_Not_Use_IsThisA_Function(X) Then Return True
        '''''If Do_Not_Use_IsThisA_Operator(SourceForm, X) > 0 Then Return True
        If Do_Not_Use_IsThisAFCKeyword(X) Then Return True
        If Do_Not_Use_IsThisAGrammarRuleName(SourceForm, X) Then Return True
        If Do_Not_Use_IsThisABranchToNextLine(X) Then Return True
        If Do_Not_Use_IsThisACameFromLine(X) Then Return True
        If IsthisADataType(X) <> "" Then Return True
        Return False
    End Function



    'This will return the variable if in the form variable.variable 
    'This has not be verified to work
    '02/21/2021 THis return s the marker now
    Friend Function Do_Not_Use_IsThisAMarker2(ByRef SourceForm As Source, CodeLine As String) As String ' this will return the variable if in formation [variable.option]
        Dim X, VariableName, PartName As String
        Dim M1, M2, M3, M4 As Integer

        X = CodeLine
        If MyLeft(X, Len(MyUniverse.SysGen.Constants.RMStart)) = MyUniverse.SysGen.Constants.RMStart Then
            M1 = 1
            M2 = MyInStr(".", CodeLine)
            M3 = MyInStr(MyUniverse.SysGen.Constants.RMEnd, CodeLine)
            M4 = Len(CodeLine)
            If M4 < M3 Then Return ""
            If M3 < M2 Then Return ""
            If M2 < M1 Then Return ""
            If M3 <> 0 And M2 - Len(MyUniverse.SysGen.Constants.RMStart) = 1 Then Return ""
            VariableName = Mid(CodeLine, Len(MyUniverse.SysGen.Constants.RMStart), M2 - Len(MyUniverse.SysGen.Constants.RMEnd))
            PartName = Mid(CodeLine, M2 + 1, M3 - M2 - 1)

            If Do_Not_Use_IsThisAValidWord(SourceForm, VariableName) Then
                Return AddRM(VariableName & "." & PartName)
            End If
            If Do_Not_Use_IsThisAVariableNameX(SourceForm, VariableName) Then
                If Do_Not_Use_IsThisAPointAttribute(PartName) <> "" Then
                    Return AddRM(VariableName & "." & PartName)
                Else
                    If MyDebug(A_FMB) Then logA(2161, VariableName)
                End If
            End If
            If Len(VariableName) = 0 Then
                If Len(PartName) <> 0 Then
                    logA(1269, Mid(X, 1, Len(PartName) + 7), PartName)
                    Return "" 'Mid(X, 1, Len(PartName) + 7)' unknown marker with only part name 
                End If
            End If
        Else 'it does not start with a RMStart
            Return ""
        End If
        logA(1117, CodeLine)
        Return ""
    End Function

    Friend Function Do_Not_Use_IsThisAPointAttribute(CodeLine As String) As String
        'todo need to document these ⬂name.PointAttribute⬃

        Select Case LCase(CodeLine)
            Case "author"
                Return CodeLine
            Case "bytes"
                Return CodeLine
            Case "DataType"
                Return CodeLine
            Case "DataTypeName"
                Return CodeLine
            Case "DataTypeDescription"
                Return CodeLine
            Case "DataTypeColor"
                Return CodeLine
            Case "distance"
                Return CodeLine
            Case "filename"
                Return CodeLine
            Case "index"
                Return CodeLine
            Case "indexes"
                Return CodeLine
            Case "io"
                Return CodeLine
            Case "name", "variable"
                Return CodeLine
            Case "notes"
                Return CodeLine
            Case "opcode"
                Return CodeLine
            Case "rotation"
                Return CodeLine
            Case "stroke"
                Return CodeLine
            Case "version"
                Return CodeLine
            Case "xa"
                Return CodeLine
            Case "x"
                Return CodeLine
            Case "ya"
                Return CodeLine
            Case "y"
                Return CodeLine
            Case "pathname"
                Return CodeLine
    'Case MyUniverse.SysGen.Markers.Variables
    'Return CodeLine
            Case "path"
                Return CodeLine
            Case "pathX"
                Return CodeLine
            Case "pathY"
                Return CodeLine
            Case "width"
                Return CodeLine
            Case Else
                Return ""
        End Select
        Return ""
    End Function



    Friend Function NoRightRule(T As String) As String
        'grammar rules can have no quotes, only keywords, operators ... 
        'If MyLeft(T, 1)="'" And MyRight(T, 1)="'" Then
        ' T=TrimOff(T, "'")
        ' End If
        If MyTrim(T) = "" Then Return ""
        If MyRight(T, 1) = "?" Or MyRight(T, 1) = "*" Or MyRight(T, 1) = "+" Or MyRight(T, 1) = "-" Then
            Return MyLeft(T, Len(T) - 1)
        End If
        Return T
    End Function

    Friend Function GetGrammarRuleName(ByRef SourceForm As Source, CodeLine As String) As String
        Dim I As Integer
        Dim Debug1 As String
        If CodeLine = "" Then Return ""
        For I = 1 To TopOfFile(SourceForm, "Grammar")
            '''''ShowProgressBar(1, I, TopOfFile(SourceForm,  "Grammar"))
            Debug1 = Language_Grammar(I)
            If GetGrammarName(Language_Grammar(I)) = CodeLine Then
                Return MyTrim(Language_Grammar(I))
            End If
        Next
        Return ""
    End Function
    Friend Function GetGrammarName(BNFRule As String) As String
        If MyInStr("::=", BNFRule) <> 0 Then
            Return MyTrim(Mid(BNFRule, 1, MyInStr("::=", BNFRule) - 1))
        End If
        Return ""
    End Function
    Friend Function Do_Not_Use_IsThisAGrammarRuleName(ByRef SourceForm As Source, BNFRule As String) As Boolean
        Dim I As Integer
        For I = 1 To TopOfFile(SourceForm, "Grammar")
            '''''ShowProgressBar(1, I, TopOfFile(SourceForm,  "Grammar"))
            If GetGrammarRuleName(SourceForm, Language_Grammar(I)) = BNFRule Then Return True
        Next
        Return False
    End Function

    Friend Function Do_Not_Use_IsThisAColor(PassedColorName As String) As Boolean
        If BinarySearch4Index(Options.ListBoxColors, PassedColorName) > 0 Then Return True
        Return False
    End Function


    Friend Function FindGrammarRule(ByRef SourceForm As Source, Rule As String) As Integer 'return the index of this rule
        Dim I As Integer
        Dim hi, lo, half As Integer
        'todo language_grammar is in order, so change this to a binary search.
        lo = 1
        hi = TopOfFile(SourceForm, "grammar")
        'half = CInt((hi + lo) / 2)

        While Rule >= Mid(Language_Grammar(lo), 1, MyInStr("::=", Language_Grammar(lo)) - 1) And Rule <= Mid(Language_Grammar(hi), 1, MyInStr("::=", Language_Grammar(hi)) - 1)
            half = CInt((hi + lo) / 2) - lo
            If Rule = GetGrammarName(Language_Grammar(lo)) Then Return lo
            If Rule = GetGrammarName(Language_Grammar(hi)) Then Return hi
            If Rule >= GetGrammarName(Language_Grammar(lo + half)) Then lo += half
            If Rule <= GetGrammarName(Language_Grammar(hi - half)) Then hi -= half
        End While

        'just in case, lets look at every thing
        Rule = Trim(Rule)
        For I = 1 To TopOfFile(SourceForm, "Grammar")
            If Rule = Trim(Mid(Language_Grammar(I), 1, MyInStr("::=", Language_Grammar(I)) - 1)) Then
                logA(1083, Rule)
                Return I
            End If
        Next
        Return ConstantMyErrorCode
    End Function

    'return -1 if not in the list
    'Return 1 If above or below
    'return 0 if match
    Friend Function GrammarNameHere(Index As Integer, S As String) As Integer
        Dim D1, D2, D3 As String
        Dim I As Integer
        Static LastIndex As Integer = 0
        Static LastRTN As Integer = -1
        Static LastS As String = "xxx"

        If LastIndex = Index And LastS = S Then Return LastRTN
        I = Index
        If Len(S) = 0 Then
            LastRTN = 1 : LastIndex = Index : LastS = S
            Return 1
        End If
        If MyStrComp(GetGrammarName(Language_Grammar(I)), S) = 0 Then
            LastRTN = 0 : LastIndex = Index : LastS = S
            Return 0
        End If
        D1 = GetGrammarName(Language_Grammar(I - 1))
        D2 = GetGrammarName(Language_Grammar(I))
        D3 = GetGrammarName(Language_Grammar(I + 1))

        If D3 = "" Then D3 = ChrW(&HFFFF) & ChrW(&HFFFF) & ChrW(&HFFFF) & ChrW(&HFFFF) & ChrW(&HFFFF) & ChrW(&HFFFF)
        logA(1033, Index.ToString & "   " & S & vbTab & vbTab & vbTab & vbTab & vbTab & D1 & vbTab & vbTab & vbTab & vbTab & vbTab & D2 & vbTab & vbTab & vbTab & vbTab & vbTab & D3)
        If MyStrComp(D2, S) = 0 Then
            LastRTN = 0 : LastIndex = Index : LastS = S
            Return 0
        End If
        If MyStrComp(D1, S) < 0 Then
            LastRTN = 1 : LastIndex = Index : LastS = S
            Return 1
        End If
        If MyStrComp(D3, S) < 0 Then
            LastRTN = 1 : LastIndex = Index : LastS = S
            Return 1
        End If
        If MyStrComp(D1, S) > 0 Then
            LastRTN = -1 : LastIndex = Index : LastS = S
            Return -1
        End If
        If MyStrComp(D3, S) < 0 Then
            LastRTN = -1 : LastIndex = Index : LastS = S
            Return -1
        End If
        If MyStrComp(GetGrammarName(Language_Grammar(I + 1)), S) > 0 Or Len(Language_Grammar(I + 1)) = 0 Then
            LastRTN = 1 : LastIndex = Index : LastS = S
            Return 1 'search more
        End If
        If MyStrComp(GetGrammarName(Language_Grammar(I - 1)), S) < 0 Or Len(Language_Grammar(I - 1)) = 0 Then
            LastRTN = 1 : LastIndex = Index : LastS = S
            Return 1 ' search more
        End If
        logA(1542, I.ToString, SHL(S), GetGrammarName(Language_Grammar(I - 1)), GetGrammarName(Language_Grammar(I)), GetGrammarName(Language_Grammar(I + 1)))
        LastRTN = -1 : LastIndex = Index : LastS = S
        Return -1
    End Function


    Friend Function FindMyGrammarName_New(ByRef SourceForm As Source, GrammarName As String) As String
        Dim Lowest As Integer = 1
        Dim Highest As Integer = TopOfFile(SourceForm, "Grammar")
        Dim I As Integer
        Dim GrammarNameX As String
        Dim debug1, debug2 As String

        GrammarNameX = MyGrammarNameOnly(GrammarName)
        If GrammarNameX = "" Then Return ""
        If MyLeft(GrammarNameX, 8) = "Unicode." Then Return MyUniverse.SysGen.Markers.UnicodeClass
        If MyLeft(GrammarNameX, 1) = "'" Then Return "" ' a grammar name can not be a literal

        debug1 = Language_Grammar(Lowest)
        debug2 = Language_Grammar(Highest)
        If MyStrComp(MyGrammarNameOnly(Language_Grammar(Lowest)), GrammarNameX) = 0 Then Return Language_Grammar(Lowest)
        If MyStrComp(MyGrammarNameOnly(Language_Grammar(Highest)), GrammarNameX) = 0 Then Return Language_Grammar(Highest)


        I = CInt((Highest - Lowest) / 2)
        While MyStrComp(MyGrammarNameOnly(Language_Grammar(Lowest)), GrammarNameX) <= 0 And MyStrComp(MyGrammarNameOnly(Language_Grammar(Highest)), GrammarNameX) >= 0 And Highest - Lowest > 1
            debug1 = MyGrammarNameOnly(Language_Grammar(Lowest))
            debug2 = MyGrammarNameOnly(Language_Grammar(Highest))
            If MyStrComp(MyGrammarNameOnly(Language_Grammar(Lowest)), GrammarNameX) = 0 Then Return Language_Grammar(Lowest)
            If MyStrComp(MyGrammarNameOnly(Language_Grammar(Highest)), GrammarNameX) = 0 Then Return Language_Grammar(Highest)

            'not in the grammar list
            If MyStrComp(GrammarNameX, MyGrammarNameOnly(Language_Grammar(I))) > 0 And MyStrComp(GrammarNameX, MyGrammarNameOnly(Language_Grammar(I + 1))) < 0 Then Return ""


            'I = PercentSearch(Language_Grammar(Lowest), GrammarNameX, Language_Grammar(Highest))
            I = MyMinMax(Lowest + CInt(PercentSearch(Language_Grammar(Lowest), GrammarNameX, Language_Grammar(Highest)) * (Highest - Lowest) / 100), Lowest, Highest)

            If MyStrComp(GrammarNameX, Language_Grammar(I)) > 0 Then Lowest = I + 1
            If MyStrComp(GrammarNameX, Language_Grammar(I)) < 0 Then Highest = I - 1
        End While
        If MyStrComp(MyGrammarNameOnly(Language_Grammar(Highest + 1)), GrammarNameX) = 0 Then Return Language_Grammar(Highest + 1)
        If MyStrComp(MyGrammarNameOnly(Language_Grammar(Lowest)), GrammarNameX) = 0 Then Return Language_Grammar(Lowest)
        If MyStrComp(MyGrammarNameOnly(Language_Grammar(Lowest - 1)), GrammarNameX) = 0 Then Return Language_Grammar(Lowest - 1)
        If MyStrComp(MyGrammarNameOnly(Language_Grammar(Lowest + 1)), GrammarNameX) = 0 Then Return Language_Grammar(Lowest + 1)
        If MyStrComp(MyGrammarNameOnly(Language_Grammar(Lowest)), GrammarNameX) = 0 Then Return Language_Grammar(Lowest)
        If MyStrComp(MyGrammarNameOnly(Language_Grammar(Highest - 1)), GrammarNameX) = 0 Then Return Language_Grammar(Highest - 1)
        If MyStrComp(MyGrammarNameOnly(Language_Grammar(Highest + 1)), GrammarNameX) = 0 Then Return Language_Grammar(Highest + 1)
        If MyStrComp(MyGrammarNameOnly(Language_Grammar(Highest)), GrammarNameX) = 0 Then Return Language_Grammar(Highest)
        'log_X(1062, MyGrammarNameOnly(Language_Grammar(Lowest)), GrammarNameX, MyGrammarNameOnly(Language_Grammar(Highest)))

        'todo need to add bug message if found otherwise below
        'todo fix this
        I = CInt(TopOfFile(SourceForm, "grammar") / 2)
        While I > 0 And MyStrComp(MyGrammarNameOnly(Language_Grammar(I)), GrammarNameX) >= 0
            If MyStrComp(MyGrammarNameOnly(Language_Grammar(I)), GrammarNameX) = 0 Then
                logA(1063, "Error Find My Grammar Name New did not find :", ">" & GrammarNameX & "<")
                Return Language_Grammar(I)
            End If
            I -= 1
        End While
        While I < TopOfFile(SourceForm, "Grammar") And MyStrComp(MyGrammarNameOnly(Language_Grammar(I)), GrammarNameX) <= 0
            If MyStrComp(MyGrammarNameOnly(Language_Grammar(I)), GrammarNameX) = 0 Then
                logA(1064, "Error Find My Grammar Name New did not find :", ">" & GrammarNameX & "<")
                Return Language_Grammar(I)
            End If
            I += 1
        End While

        If MyStrComp(MyGrammarNameOnly(Language_Grammar(Lowest)), GrammarNameX) = 0 Then
            logA(1065, "Error Find My Grammar Name New did not find :", ">" & GrammarNameX & "<")
            Return Language_Grammar(Lowest)
        End If
        If MyStrComp(MyGrammarNameOnly(Language_Grammar(Highest)), GrammarNameX) = 0 Then
            logA(1066, "Error Find My Grammar Name New did not find :", ">" & GrammarNameX & "<")
            Return Language_Grammar(Highest)
        End If
        Return ""

    End Function



    Friend Function Indents(ByRef SourceForm As Source, TheSourceCode As String) As Integer ' Counts the number of whitespaces at the beginning
        Dim I As Integer
        Dim SourceCode As String
        SourceCode = TheSourceCode
        SourceCode = SourceCode.Replace("    ", vbTab)
        SourceCode = SourceCode.Replace(vbLf, VBSpace)
        SourceCode = SourceCode.Replace(vbCr, VBSpace)
        SourceCode = SourceCode.Replace("  ", VBSpace)
        I = 1

        While I < Len(SourceCode)
            If IsThisAWhiteSpace(Mid(SourceCode, I, 1)) <> "" Then
                I += 1
            Else
                Return I - 1
            End If
        End While

        Return ConstantMyErrorCode
    End Function


    'Routine This returns and removes till a carriage return or Line Feed
    Friend Function PopLine(ByRef A As String) As String ' Return up to the first CRLF, CR or LF
        Dim B As String
        Dim I As Integer

        While MyLeft(A, 1) = vbCrLf Or MyLeft(A, 1) = vbCr Or MyLeft(A, 1) = vbLf
            A = Mid(A, 2, Len(A))
        End While


        I = MyInStr(vbCrLf, A)
        If I > 3 Then
            PopLine = Mid(A, 1, I)
            A = Mid(A, I, Len(A))
            Return PopLine
        End If

        PopLine = MyLeft(A, 1)
        A = Mid(A, 2)
        B = MyLeft(A & Chr(10), 1)

        While Len(A) >= 1 And B <> vbCr And B <> vbCrLf And B <> vbLf 'B > Chr(16) And '
            PopLine &= MyLeft(A, 1)
            A = Mid(A, 2)
            B = MyLeft(A & Chr(10), 1)
        End While


    End Function

    Friend Function S2N(A As String) As Integer
        Dim X As String
        X = MyLeft(A, 1)
        Select Case A
            Case "0" : Return 0
            Case "1" : Return 1
            Case "2" : Return 2
            Case "3" : Return 3
            Case "4" : Return 4
            Case "5" : Return 5
            Case "6" : Return 6
            Case "7" : Return 7
            Case "8" : Return 8
            Case "9" : Return 9
            Case Else
                logA(1271, X, A)
        End Select
        Return ConstantMyErrorCode
    End Function

    Friend Function My_INT(Text As String) As Integer ' Cint() ignore all first ,'s.
        Dim Sign As Integer
        Dim Temp As String
        Temp = Text
        If MyLeft(Temp, Len(FD)) = FD Then
            Temp = Mid(Temp, Len(FD), Len(Temp))
        End If
        Sign = 1
        My_INT = 0

        While Len(Temp) > 0
            Select Case MyLeft(Temp, 1)
                Case "-"
                    Sign = -1
                Case "9"
                    My_INT = My_INT * 10 + 9
                Case "8"
                    My_INT = My_INT * 10 + 8
                Case "7"
                    My_INT = My_INT * 10 + 7
                Case "6"
                    My_INT = My_INT * 10 + 6
                Case "5"
                    My_INT = My_INT * 10 + 5
                Case "4"
                    My_INT = My_INT * 10 + 4
                Case "3"
                    My_INT = My_INT * 10 + 3
                Case "2"
                    My_INT = My_INT * 10 + 2
                Case "1"
                    My_INT = My_INT * 10 + 1
                Case "0"
                    My_INT = My_INT * 10 + 0
                Case FD

                    Exit Function
                Case Else
                    logA(1272, CStr(My_INT), Text)
                    My_INT = My_INT 'This should never happen 
            End Select
            Temp = Mid(Temp, 2, Len(Temp))
        End While

        My_INT *= Sign
    End Function


    Friend Function PopNonZeroValue(ByRef B As String) As Integer

        PopNonZeroValue = 0

        While Len(B) > 0 And PopNonZeroValue = 0
            PopNonZeroValue = PopValue(B)
        End While

    End Function


    Friend Function MyPathTextValues2Line(ByRef SourceForm As Source, IndexFlowChart As Integer, ByRef S As String) As MyLineStructure
        MyPathTextValues2Line = Nothing
        MyPathTextValues2Line.a.Named.PathName = FlowChart_Table_Path_SymbolName(SourceForm, IndexFlowChart)
        MyPathTextValues2Line.a.x = PopValue(S)
        MyPathTextValues2Line.a.y = PopValue(S)
        MyPathTextValues2Line.b.x = PopValue(S)
        MyPathTextValues2Line.b.y = PopValue(S)
        MyPathTextValues2Line = MyPathSnap(MyPathTextValues2Line)
    End Function



    Friend Function MyUseTextValues2Line(ByRef SourceForm As Source, IndexFlowChart As Integer, ByRef S As String) As MyLineStructure
        MyUseTextValues2Line = Nothing
        MyUseTextValues2Line.a = Nothing
        MyUseTextValues2Line.a.x = PopValue(S)
        MyUseTextValues2Line.a.y = PopValue(S)
        MyUseTextValues2Line.a = MySymbolSnap(MyUseTextValues2Line.a)
        FlowChart_TableX1(SourceForm, IndexFlowChart, MyUseTextValues2Line.a.x)
        FlowChart_TableY1(SourceForm, IndexFlowChart, MyUseTextValues2Line.a.y)
    End Function




    'Routine This returns and removes all numbers before 'white' space
    Friend Function PopValueY(ByRef NumberAsString As String) As Integer ' Returns a number from the string My_Int() & Value()
        Dim XString As String
        Dim YString As String
        Dim Sign, Multiplyer As Integer

        Sign = 1 ' final sign of the number
        Multiplyer = 10 ' stops when there is a period .
        PopValueY = 0
        NumberAsString = MyTrim(NumberAsString)
        XString = ""
        YString = VBSpace
        ' This needs to be changed so that we find where the trim is, and then move the string only once, because this way is VERY slow.

        While (YString >= "0" And YString <= "9") Or YString = VBSpace Or YString = "-"
            XString &= YString
            Select Case YString
                Case "0", "1", "2", "3", "4", "5", "6", "7", "8", "9"
                    PopValueY = PopValueY * Multiplyer + S2N(YString)
                Case "."
                    Multiplyer = 1
                Case "-"
                    Sign = -1
                Case Else
                    logA(2070, YString)
            End Select
            YString = MyLeft(NumberAsString, 1)
            If Len(NumberAsString) > 0 Then NumberAsString = Mid(NumberAsString, 2, Len(NumberAsString))
        End While

        'flow10'Change to get the value character by character 
        PopValueY *= Sign ' My_Int(Trim(XString) & ".0")
        Return PopValueY
    End Function


    Friend Function PopFirstValue(ByRef Number As String) As Integer ' only return when a number is not zero, return Z if nothing left
        PopFirstValue = PopValue(Number)

        While Len(Number) > 0 And PopFirstValue = 0
            PopFirstValue = PopValue(Number)
        End While

    End Function


    'Routine This returns and removes all numbers before 'white' space
    Friend Function PopValue(ByRef NumberAsString As String) As Integer ' Returns a number from the string My_Int() & Value()
        Dim XString As String
        Dim YString As String
        Dim Sign, Multiplyer As Integer
        Sign = 1 ' final sign of the number
        Multiplyer = 10 ' stops when there is a period .
        PopValue = 0
        NumberAsString = MyTrim(NumberAsString)

        If MyLeft(NumberAsString, 2) = "0X" Then Return Hex2Bin(Pop(NumberAsString, FD))

        XString = ""
        YString = VBSpace
        ' This needs to be changed so that we find where the trim is, and then move the string only once, because this way is VERY slow.

        While (YString >= "0" And YString <= "9") Or YString = VBSpace Or YString = "-"
            XString &= YString
            Select Case YString
                Case "0", "1", "2", "3", "4", "5", "6", "7", "8", "9"
                    PopValue = PopValue * Multiplyer + S2N(YString)
                Case "."
                    Multiplyer = 1
                Case "-"
                    Sign = -1
                Case "", Nothing, VBSpace
                Case Else
                    logA(2071, YString)
            End Select
            YString = MyLeft(NumberAsString, 1)
            If Len(NumberAsString) > 0 Then NumberAsString = Mid(NumberAsString, 2, Len(NumberAsString))
        End While

        'flow10'Change to get the value character by character 
        PopValue *= Sign ' My_Int(Trim(XString) & ".0")
    End Function


    Friend Function FindInDropDownButton(ItemName As String, TSDD As ListBox) As Integer
        Dim I As Integer
        Dim Temp As String

        For I = 0 To TSDD.Items.Count - 1 '   TSDD.items.Count - 1
            '''''Temp = TSDD.items.item(I).Text
            Temp = TSDD.Items.Item(I).ToString
            If ItemName = Pop(Temp, FD) Then Return I
        Next
        Return ConstantMyErrorCode
    End Function




    'Returns the whole list of this record
    Friend Function MyUnEnum(LB As ListBox, RecordNumber As Integer, ItemNumberOffset As Integer) As String
        Dim I As Integer, Temp As String
        Dim Count As Integer
        '''''ReDim Preserve MyUniverse.MyStaticData.MyUnEnum.LastResults(20)

        Count = LB.Items.Count
        MyUnEnum = ""

        ' Test if this is a number and not a Indexes to the ComboBox
        If RecordNumber > Count - 1 Then
            MyUnEnum = CStr(RecordNumber)
            Exit Function
        End If
        Temp = LB.Items.Item(MyMinMax(RecordNumber, 0, Count - 1)).ToString ' Should this allow ComboBox.items(0)?

        For I = 0 To ItemNumberOffset
            Temp = Trim(Temp)
            MyUnEnum = Pop(Temp, FD)
        Next I
    End Function


    'converts from a number into the cap start/end type
    'This is erroring out, and not return a valid type of data for this
    Friend Function MyCapCode(ANumber As Integer) As Drawing2D.LineCap
        Select Case ANumber
            Case 1
                Return Drawing2D.LineCap.AnchorMask
            Case 2
                Return Drawing2D.LineCap.ArrowAnchor
            Case 3
                Return Drawing2D.LineCap.DiamondAnchor
            Case 4
                Return Drawing2D.LineCap.Flat
            Case 5
                Return Drawing2D.LineCap.NoAnchor
            Case 6
                Return Drawing2D.LineCap.Round
            Case 7
                Return Drawing2D.LineCap.RoundAnchor
            Case 8
                Return Drawing2D.LineCap.Square
            Case 9
                Return Drawing2D.LineCap.SquareAnchor
            Case 10
                Return Drawing2D.LineCap.Triangle
            Case Else
                Return Drawing2D.LineCap.AnchorMask 'if cant / DoNot know what it is 
        End Select
    End Function



    'Returns the number of the first item in this number

    Friend Function MyEnumValue(WhatString As String, LB As ListBox) As Integer
        Dim I As Integer, Low, LocalIndex, JIndex, KIndex, ErrorCounter As Integer
        Dim SearchingFor As String
        Dim Count As Integer
        '''''If MyUniverse.MyStaticData.MyEnum.LastComboBox = LB.Name Then ' same as last 
        '''''If MyUniverse.MyStaticData.MyEnum.LastWhatString = WhatString Then
        '''''        Return MyUniverse.MyStaticData.MyEnum.Last_Enum ' return shortcut
        '''''End If
        '''''End If


        Count = LB.Items.Count
        If Count < 1 Then Return 0
        Low = 0
        SearchingFor = MyTrim(WhatString)
        If Len(SearchingFor) < 1 Then
            logA(1281, LB.Name)
            '''''MyUniverse.MyStaticData.MyEnum.LastComboBox = LB.Name
            '''''MyUniverse.MyStaticData.MyEnum.LastWhatString = WhatString
            '''''MyUniverse.MyStaticData.MyEnum.Last_Enum = ConstantMyErrorCode
            MyEnumValue = ConstantMyErrorCode
            Exit Function
        End If

        'Lets try a binary search first
        KIndex = Count - 1
        LocalIndex = MyMinMax(CInt(KIndex / 2), Low, KIndex)
        JIndex = MyMinMax(CInt(LocalIndex / 2), Low, KIndex)
        ErrorCounter = -(Count + 8) ' Try to find it eight times to many
        'Temp=LB.Items.Item(LocalIndex).ToString 'hack
        'Temp=Trim(Pop(LB.Items.Item(LocalIndex).ToString, MyUniverse.SysGen.Constants.ConstantDelimiters)) 'hack
        I = MyCompared1_a(SearchingFor, Trim(Pop(LB.Items.Item(LocalIndex).ToString, MyUniverse.SysGen.Constants.ConstantDelimiters)))


        While I <> 0
            ErrorCounter += 1
            If ErrorCounter + 2 > Count Then
                ' Not found and searched almost for ever.
                '''''MyUniverse.MyStaticData.MyEnum.LastComboBox = LB.Name
                '''''MyUniverse.MyStaticData.MyEnum.LastWhatString = WhatString
                '''''MyUniverse.MyStaticData.MyEnum.Last_Enum = Nothing
                'MyEnumValue=Nothing

                GoTo FailedBinarySearch
            End If
            If I < 0 Then
                LocalIndex = MyMinMax(LocalIndex - JIndex, Low, KIndex)
            Else
                LocalIndex = MyMinMax(LocalIndex + JIndex, Low, KIndex)
            End If
            JIndex = MyMinMax(CInt(JIndex / 2), 1, KIndex)

            I = MyCompared1_a(SearchingFor, Pop(Trim(LB.Items.Item(LocalIndex).ToString), MyUniverse.SysGen.Constants.ConstantDelimiters))

        End While

        '''''MyUniverse.MyStaticData.MyEnum.LastComboBox = LB.Name
        '''''MyUniverse.MyStaticData.MyEnum.LastWhatString = WhatString
        '''''MyUniverse.MyStaticData.MyEnum.Last_Enum = LocalIndex
        MyEnumValue = LocalIndex
        Exit Function
        ' The above should replace the below, but should add an escape incase it's not in the List to avoid a forever loop
FailedBinarySearch:
        SearchingFor = MyTrim(WhatString)
        If SearchingFor = "" Or SearchingFor = MyUniverse.ProgramOptions.FCCL_WhiteSpace Then
            '''''MyUniverse.MyStaticData.MyEnum.LastComboBox = LB.Name
            '''''MyUniverse.MyStaticData.MyEnum.LastWhatString = WhatString
            '''''MyUniverse.MyStaticData.MyEnum.Last_Enum = ConstantMyErrorCode
            MyEnumValue = ConstantMyErrorCode
            Exit Function
        End If
        '''''MyUniverse.MyStaticData.MyEnum.LastComboBox = LB.Name
        '''''MyUniverse.MyStaticData.MyEnum.LastWhatString = WhatString
        '''''MyUniverse.MyStaticData.MyEnum.Last_Enum = Nothing
        MyEnumValue = Nothing

    End Function


    ' Swaps the two places of the keyWord array (Sorting them to keep them in order, should look into an insert sort method)
    Friend Sub MySwapLanguageKeyWord(ByRef LB As ListBox, A As Integer, B As Integer)
        Dim T As String

        If A < 0 Then Return
        If B < 0 Then Return
        If A > TopOfListBox(LB) Then Return
        If B > TopOfListBox(LB) Then Return
        FMB(GetMyRecord(LB, A), GetMyRecord(LB, B))
        T = GetMyRecord(LB, A)
        GetMyRecord(LB, A, GetMyRecord(LB, B))
        GetMyRecord(LB, B, T)
        If MyStrComp(GetMyRecord(LB, A), GetMyRecord(LB, B)) = 0 Then
            FMB(GetMyRecord(LB, A), GetMyRecord(LB, B))
            If MyDebug(A_STATUS) Then logA(2164, LB.Name, GetMyRecord(LB, A), GetMyRecord(LB, B))
            GetMyRecord(LB, B, MyConstantIgnoreFunctionOperatorKeyWord & MyRnd(6))
        End If

    End Sub


    'Routine changes places between two number locations in a number MyArray

    Friend Sub MyCopySymbolList(A As Integer, B As Integer)
        Symbol_FileCoded(B) = Symbol_FileCoded(A)
        Symbol_File_NameOfPoint(B) = Symbol_File_NameOfPoint(A)
        Symbol_FileSymbolName(B) = Symbol_FileSymbolName(A)
        Symbol_FileX1(B) = Symbol_FileX1(A)
        Symbol_FileY1(B) = Symbol_FileY1(A)
        Symbol_FileX2_io(B) = Symbol_FileX2_io(A)
        Symbol_FileY2_dt(B) = Symbol_FileY2_dt(A)
    End Sub

    'Routine swaps in all Symbol MyArrays two locations
    Friend Sub MySwapSymbolList(ByRef SourceForm As Source, A As Integer, B As Integer) ' With one higher ' inserting records in a non-index-file
        'Const MyTable As String = "Symbol"
        If MyDebug(A_STATUS) Then
            logA(2112, A.ToString, MyShowSymbolRecord(SourceForm, False, A), B.ToString, MyShowSymbolRecord(SourceForm, False, B))
        End If
        '
        If Symbol_TableCoded_String(A) = "/unknown" Then
            If Symbol_TableCoded_String(B) = "/unknown" Then
                Return                'DoNot bother to swap two invalid
            End If
        Else
            MyCopySymbolList(A, B)
        End If


    End Sub




    'Routine returns from 'real' world to Window scale
    Friend Function ScaledSize(MyNumber As Integer) As Integer 'single
        LimitScale()
        ScaledSize = CInt(MyNumber * MyUniverse.SysGen.MyFlowChartScale)
    End Function


    'invalid use point-path-Symbol snap

    'Move the point to the grid
    Friend Function MyLineSnap(XY As MyLineStructure) As MyLineStructure
        MyLineSnap = Nothing
        MyLineSnap.a.x = CInt(XY.a.x / MyUniverse.SysGen.Snaps.MyPointSnap) * MyUniverse.SysGen.Snaps.MyPointSnap
        MyLineSnap.a.y = CInt(XY.a.y / MyUniverse.SysGen.Snaps.MyPointSnap) * MyUniverse.SysGen.Snaps.MyPointSnap
        MyLineSnap.b.x = CInt(XY.b.x / MyUniverse.SysGen.Snaps.MyPointSnap) * MyUniverse.SysGen.Snaps.MyPointSnap
        MyLineSnap.b.y = CInt(XY.b.y / MyUniverse.SysGen.Snaps.MyPointSnap) * MyUniverse.SysGen.Snaps.MyPointSnap
    End Function
    Friend Function MyLineSnap(XY As Integer) As Integer
        Return CInt(XY / MyUniverse.SysGen.Snaps.MySnap) * MyUniverse.SysGen.Snaps.MySnap
    End Function

    Friend Function MyLineXY(A As MyPointStructure, B As MyPointStructure) As MyLineStructure
        MyLineXY = Nothing
        MyLineXY.a.x = A.x
        MyLineXY.a.y = A.y
        MyLineXY.b.x = B.x
        MyLineXY.b.y = B.y
    End Function


    Friend Function MyPathSnap(XY As MyLineStructure) As MyLineStructure
        'todo XY.a.Named.PathName=XY.a.Named.PathName
        If MyUniverse.SysGen.Snaps.MyPointSnap = 0 Then
            Return XY
        End If
        MyPathSnap = Nothing
        MyPathSnap.a.x = CInt(XY.a.x / MyUniverse.SysGen.Snaps.MyPointSnap) * MyUniverse.SysGen.Snaps.MyPointSnap
        MyPathSnap.a.y = CInt(XY.a.y / MyUniverse.SysGen.Snaps.MyPointSnap) * MyUniverse.SysGen.Snaps.MyPointSnap
        MyPathSnap.b.x = CInt(XY.b.x / MyUniverse.SysGen.Snaps.MyPointSnap) * MyUniverse.SysGen.Snaps.MyPointSnap
        MyPathSnap.b.y = CInt(XY.b.y / MyUniverse.SysGen.Snaps.MyPointSnap) * MyUniverse.SysGen.Snaps.MyPointSnap
        MyPathSnap.a.Named.IsWorldWindow = WorldOrWindow(MyPathSnap.a)
        MyPathSnap.b.Named.IsWorldWindow = WorldOrWindow(MyPathSnap.b)
        Return MyPathSnap
    End Function



    Friend Function MyPointSnap(XY As MyPointStructure) As MyPointStructure
        MyPointSnap = Nothing
        XY.Named.PointName = XY.Named.PointName 'incase it is a path, or a point get them both, and leave the symbol name null
        XY.Named.PathName = XY.Named.PathName
        MyPointSnap.x = CInt(XY.x / MyUniverse.SysGen.Snaps.MyPointSnap) * MyUniverse.SysGen.Snaps.MyPointSnap
        MyPointSnap.y = CInt(XY.y / MyUniverse.SysGen.Snaps.MyPointSnap) * MyUniverse.SysGen.Snaps.MyPointSnap
        MyPointSnap.Named.IsWorldWindow = WorldOrWindow(MyPointSnap)
    End Function
    Friend Function MySymbolSnap(XY As MyPointStructure) As MyPointStructure
        MySymbolSnap = Nothing
        MySymbolSnap.x = CInt(XY.x / MyUniverse.SysGen.Snaps.MySymbolSnap) * MyUniverse.SysGen.Snaps.MySymbolSnap
        MySymbolSnap.y = CInt(XY.y / MyUniverse.SysGen.Snaps.MySymbolSnap) * MyUniverse.SysGen.Snaps.MySymbolSnap
    End Function


    'todo need to make sure that paths are not made to overlap each other.
    Friend Function MakePathOrthogonal(ByRef SourceForm As Source, IndexFlowChart As Integer) As Boolean ' returns if changed the Line
        Dim DX, DY, IndexFlowChart1 As Integer
        MakePathOrthogonal = False ' Didn't change anything
        If MyOptionTest(14) = False Then Exit Function 'Orthogonal paths
        ' Need to make sure this is a path first
        If FlowChart_TableCode(SourceForm, IndexFlowChart) <> "/path" Then
            Exit Function ' this is not a path to be able to change
        End If

        'It's check so make this rectangle Orthogonal 
        ' Get the distances between the two points on the Line
        DX = MyABS(FlowChart_TableX1(SourceForm, IndexFlowChart) - FlowChart_TableX2(SourceForm, IndexFlowChart))
        DY = MyABS(FlowChart_TableY1(SourceForm, IndexFlowChart) - FlowChart_TableY2(SourceForm, IndexFlowChart))
        If DX = 0 Or DY = 0 Then Exit Function ' The X or Y is already stright up/down OR level right/left

        If MyOptionTest(34) Then
            PanToWindowXY(SourceForm, FlowChart_TableX1(SourceForm, IndexFlowChart), FlowChart_TableX1(SourceForm, IndexFlowChart))
            PaintAll(SourceForm, IndexFlowChart, IndexFlowChart)
            PaintErase(SourceForm, IndexFlowChart)
        End If

        IndexFlowChart1 = InsertFlowChartRecord(SourceForm, FlowChart_TablePathName(SourceForm, IndexFlowChart), "/path", MyPoint1XY(FlowChart_TableX1(SourceForm, IndexFlowChart), FlowChart_TableY1(SourceForm, IndexFlowChart)), MyPoint2XY(FlowChart_TableX2(SourceForm, IndexFlowChart), FlowChart_TableY2(SourceForm, IndexFlowChart)), FlowChart_TableDataType(SourceForm, IndexFlowChart))
        '
        'todo need to erase the old line
        PaintAll(SourceForm, IndexFlowChart, IndexFlowChart)
        PaintAll(SourceForm, IndexFlowChart1, IndexFlowChart1)
        If DX >= DY Then
            DX = FlowChart_TableX1(SourceForm, IndexFlowChart)
            DY = FlowChart_TableY2(SourceForm, IndexFlowChart)
            FlowChart_TableX1(SourceForm, IndexFlowChart1, DX)
            FlowChart_TableY1(SourceForm, IndexFlowChart1, DY)
            FlowChart_TableX2(SourceForm, IndexFlowChart, DX)
            FlowChart_TableY2(SourceForm, IndexFlowChart, DY)
            PaintAll(SourceForm, IndexFlowChart, IndexFlowChart)
            PaintAll(SourceForm, IndexFlowChart1, IndexFlowChart1)
        Else
            DX = FlowChart_TableX2(SourceForm, IndexFlowChart)
            DY = FlowChart_TableY1(SourceForm, IndexFlowChart)
            FlowChart_TableX1(SourceForm, IndexFlowChart1, DX)
            FlowChart_TableY1(SourceForm, IndexFlowChart1, DY)
            FlowChart_TableX2(SourceForm, IndexFlowChart, DX)
            FlowChart_TableY2(SourceForm, IndexFlowChart, DY)
            PaintAll(SourceForm, IndexFlowChart, IndexFlowChart)
            PaintAll(SourceForm, IndexFlowChart1, IndexFlowChart1)
            '2020 07 20 changed to also add a record ThisArea.MyWorldXY.a.x=ThisArea.MyWorldXY.b.x
        End If
        OLD.Clear_Window(SourceForm.FlowChartPictureBox)
    End Function

    Friend Sub SetMyLimitWindow(FromXY As MyPointStructure)
        'todo put a follow here
        Dim debugLevel As Integer = A_DISPLAY
        Dim Flag As Boolean = False

        If MyUniverse.MyStaticData.MinXY.x > FromXY.x Then
            MyUniverse.MyStaticData.MinXY.x = FromXY.x - 1000
            Flag = True
            If MyDebug(debugLevel) Then logA(2687, FromXY.x.ToString, MyUniverse.MyStaticData.MinXY.x.ToString, FromXY.y.ToString, MyUniverse.MyStaticData.MinXY.y.ToString)
        End If
        If MyUniverse.MyStaticData.MinXY.y > FromXY.y Then
            If MyDebug(debugLevel) Then logA(2688, FromXY.x.ToString, MyUniverse.MyStaticData.MinXY.x.ToString, FromXY.y.ToString, MyUniverse.MyStaticData.MinXY.y.ToString)
            MyUniverse.MyStaticData.MinXY.y = FromXY.y - 1000
            Flag = True
        End If
        If MyUniverse.MyStaticData.MaxXY.x < FromXY.x Then
            If MyDebug(debugLevel) Then logA(2689, FromXY.x.ToString, MyUniverse.MyStaticData.MinXY.x.ToString, FromXY.y.ToString, MyUniverse.MyStaticData.MinXY.y.ToString)
            MyUniverse.MyStaticData.MaxXY.x = FromXY.x + 1000
            Flag = True
        End If
        If MyUniverse.MyStaticData.MaxXY.y < FromXY.y Then
            If MyDebug(debugLevel) Then logA(2690, FromXY.x.ToString, MyUniverse.MyStaticData.MinXY.x.ToString, FromXY.y.ToString, MyUniverse.MyStaticData.MinXY.y.ToString)
            MyUniverse.MyStaticData.MaxXY.y = FromXY.y + 1000
            Flag = True
        End If
        If Flag Then
            If MyDebug(debugLevel) Then
                logA(2883, MyShowPoint(MyUniverse.MyStaticData.MinXY), MyShowPoint(MyUniverse.MyStaticData.MaxXY), MyShowPoint(FromXY))
            End If
        End If
    End Sub


    Friend Function FixSymbolLimits2Window(XY1 As MyPointStructure) As MyPointStructure
        FixSymbolLimits2Window = XY1
        FixSymbolLimits2Window.x = MyMinMax(FixSymbolLimits2Window.x, 0, Library.PictureBox1.Width - 2)
        FixSymbolLimits2Window.y = MyMinMax(FixSymbolLimits2Window.y, 0, Library.PictureBox1.Height - 2)
        If FixSymbolLimits2Window.x <> XY1.x Or FixSymbolLimits2Window.y <> XY1.y Then
            If MyDebug(A_INFORMATION) Then logA(1303, MyShowPoint(FixSymbolLimits2Window), MyShowPoint(XY1))
        End If
    End Function



    'Routine returns from 'real' world to Window scale
    Friend Function Copy2WindowXY(ByRef SourceForm As Source, FromXY As MyPointStructure) As MyPointStructure
        Dim Temp As MyPointStructure
        Copy2WindowXY = Nothing
        LimitScale()
        Select Case LCase(SourceForm.Parent.Name)
            Case "FlowChartWindow"
                SetMyLimitWindow(FromXY)
                If MyOptionTest(23) = True Then ' the origin is set by either CmdMoveHand or by scroll bars.
                    Temp.x = MyUniverse.MyMouseAndDrawing.MyScreen00.x
                    Temp.y = MyUniverse.MyMouseAndDrawing.MyScreen00.y
                Else
                    MsgBox("halt")
                    '''''Temp.x = CInt((MyUniverse.MyMouseAndDrawing.MouseWindow.b.x + MyUniverse.MyMouseAndDrawing.MouseWindow.a.x) * FlowChartWindow.HScrollBar1.Value / FlowChartWindow.HScrollBar1.Maximum)
                    '''''Temp.y = CInt((MyUniverse.MyMouseAndDrawing.MouseWindow.b.y - MyUniverse.MyMouseAndDrawing.MouseWindow.a.y) * FlowChartWindow.VScrollBar1.Value / FlowChartWindow.VScrollBar1.Maximum)
                End If
                Copy2WindowXY.x = CInt((FromXY.x - Temp.x) * MyUniverse.SysGen.MyFlowChartScale)
                Copy2WindowXY.y = CInt((FromXY.y - Temp.y) * MyUniverse.SysGen.MyFlowChartScale)
            Case "SymbolWindow"
                'hack debugging

                Copy2WindowXY.x = CInt((FromXY.x + MyUniverse.SysGen.Constants.ConstantSymbolCenter) * MyUniverse.SysGen.MySymbolScale)
                Copy2WindowXY.y = CInt((FromXY.y + MyUniverse.SysGen.Constants.ConstantSymbolCenter) * MyUniverse.SysGen.MySymbolScale)

                Copy2WindowXY = FixSymbolLimits2Window(Copy2WindowXY)


                'I think this should be 0?
                If Copy2WindowXY.x < 0 Then
                    logA(1305, MyShowPoint(FromXY), MyShowPoint(Copy2WindowXY), MyShowPoint(MyPoint1XY(-MyUniverse.SysGen.Constants.ConstantSymbolCenter, MyUniverse.SysGen.Constants.ConstantSymbolCenter)), MyShowPoint(MyUniverse.MyStaticData.ZeroZero))
                End If
                'I think this should be picture width?
                If Copy2WindowXY.x > Library.PictureBox1.Width Then
                    logA(1306, MyShowPoint(FromXY), MyShowPoint(Copy2WindowXY), MyShowPoint(MyPoint1XY(-MyUniverse.SysGen.Constants.ConstantSymbolCenter, MyUniverse.SysGen.Constants.ConstantSymbolCenter)), MyShowPoint(MyPoint1XY(Library.PictureBox1.Width, Library.PictureBox1.Height)))
                End If
                'I think this should be 0?
                If Copy2WindowXY.y < 0 Then
                    logA(1307, MyShowPoint(FromXY), MyShowPoint(Copy2WindowXY), MyShowPoint(MyPoint1XY(-MyUniverse.SysGen.Constants.ConstantSymbolCenter, MyUniverse.SysGen.Constants.ConstantSymbolCenter)), MyShowPoint(MyPoint1XY(Library.PictureBox1.Width, Library.PictureBox1.Height)))
                End If
                'I think this should be picture height?
                If Copy2WindowXY.y > Library.PictureBox1.Height Then
                    logA(1308, MyShowPoint(FromXY), MyShowPoint(Copy2WindowXY), MyShowPoint(MyPoint1XY(-MyUniverse.SysGen.Constants.ConstantSymbolCenter, MyUniverse.SysGen.Constants.ConstantSymbolCenter)), MyShowPoint(MyPoint1XY(Library.PictureBox1.Width, Library.PictureBox1.Height)))
                End If
            Case Else
                Copy2WindowXY.x = -1
                Copy2WindowXY.y = -1
                logA(1309, SourceForm.Parent.Name, SourceForm.Name)
        End Select
        Copy2WindowXY.Named.IsWorldWindow = WorldOrWindow(Copy2WindowXY)
    End Function


    'Routine copies from Window scale to 'real' world scale

    'todo rename the X in the x( routine(s) and remove the debug test this string parameter
    Friend Function Copy2WorldXY(ByRef SourceForm As Source, CodeString As String, FromXY As MyPointStructure) As MyPointStructure
        Const debugLevel As Integer = A_DISPLAY
        Dim TempH, TempV As Single
        Copy2WorldXY = Nothing
        LimitScale()
        Select Case LCase(SourceForm.Parent.Name)
            Case "FlowChartWindow"
                'todo need to hide scroll bars if the hand option is used.
                If MyOptionTest(23) = True Then ' the origin is set by either CmdMoveHand or by scroll bars.
                    TempH = MyUniverse.MyMouseAndDrawing.MyScreen00.x
                    TempV = MyUniverse.MyMouseAndDrawing.MyScreen00.y
                Else
                    MsgBox("Halt")
                    '''''TempH = CInt((MyUniverse.MyMouseAndDrawing.MouseWindow.b.x + MyUniverse.MyMouseAndDrawing.MouseWindow.a.x) * FlowChartWindow.HScrollBar1.Value / FlowChartWindow.HScrollBar1.Maximum)
                    '''''TempV = CInt((MyUniverse.MyMouseAndDrawing.MouseWindow.b.y - MyUniverse.MyMouseAndDrawing.MouseWindow.a.y) * FlowChartWindow.VScrollBar1.Value / FlowChartWindow.VScrollBar1.Maximum)
                End If

                Select Case LCase(CodeString)
                    Case My_keyWord(My_KeyConstUse) 'Symbol grid snap
                        MyUniverse.Area.MyWorldXY.a = MySymbolSnap(MyUniverse.Area.MyWorldXY.a)
                        Copy2WorldXY = MySymbolSnap(MyPoint1XY(CInt(FromXY.x + TempH), CInt(FromXY.y + TempV)))
                    Case "/Constant" 'Point / Path grid snap
                        MyUniverse.Area.MyWorldXY.a = MyPointSnap(MyUniverse.Area.MyWorldXY.a)
                        Copy2WorldXY = MySymbolSnap(MyPoint1XY(CInt(FromXY.x + TempH), CInt(FromXY.y + TempV)))
                    Case "/path" 'point/path grid snap
                        MyUniverse.Area.MyWorldXY = MyPathSnap(MyUniverse.Area.MyWorldXY)
                        Copy2WorldXY = MySymbolSnap(MyPoint1XY(CInt(FromXY.x + TempH), CInt(FromXY.y + TempV)))
                    Case "/", Nothing
                        Copy2WorldXY.x = CInt((FromXY.x / MyUniverse.SysGen.MyFlowChartScale) + TempH)
                        Copy2WorldXY.y = CInt((FromXY.y / MyUniverse.SysGen.MyFlowChartScale) + TempV)
                    Case Else
                        logA(1311, CodeString)
                        Copy2WorldXY.x = CInt(CInt(FromXY.x / MyUniverse.SysGen.MyFlowChartScale) + TempH)
                        Copy2WorldXY.y = CInt(CInt(FromXY.y / MyUniverse.SysGen.MyFlowChartScale) + TempV)
                End Select
            Case "SymbolWindow"
                Select Case LCase(CodeString)
                    Case "/point"
                        Copy2WorldXY.x = CInt(FromXY.x / MyUniverse.SysGen.MySymbolScale) - MyUniverse.SysGen.Constants.ConstantSymbolCenter
                        Copy2WorldXY.y = CInt(FromXY.y / MyUniverse.SysGen.MySymbolScale) - MyUniverse.SysGen.Constants.ConstantSymbolCenter
                        Copy2WorldXY = MyPointSnap(Copy2WorldXY)
                    Case "/Line" ' no snapping of Lines.
                        Copy2WorldXY.x = CInt(FromXY.x / MyUniverse.SysGen.MySymbolScale) - MyUniverse.SysGen.Constants.ConstantSymbolCenter
                        Copy2WorldXY.y = CInt(FromXY.y / MyUniverse.SysGen.MySymbolScale) - MyUniverse.SysGen.Constants.ConstantSymbolCenter
                    Case "/", "", Nothing
                        Copy2WorldXY.x = CInt(CSng(FromXY.x - MyUniverse.SysGen.Constants.ConstantSymbolCenter) * MyUniverse.SysGen.MySymbolScale - MyUniverse.SysGen.Constants.ConstantSymbolCenter)
                        Copy2WorldXY.y = CInt(CSng(FromXY.y - MyUniverse.SysGen.Constants.ConstantSymbolCenter) * MyUniverse.SysGen.MySymbolScale - MyUniverse.SysGen.Constants.ConstantSymbolCenter)
                    Case "?"
                        Copy2WorldXY.x = CInt(FromXY.x / MyUniverse.SysGen.MySymbolScale) - MyUniverse.SysGen.Constants.ConstantSymbolCenter
                        Copy2WorldXY.y = CInt(FromXY.y / MyUniverse.SysGen.MySymbolScale) - MyUniverse.SysGen.Constants.ConstantSymbolCenter
                    Case Else
                        logA(1312, CodeString.ToString, SourceForm.Parent.Name)
                        Copy2WorldXY.x = CInt(CSng(FromXY.x - MyUniverse.SysGen.Constants.ConstantSymbolCenter) * MyUniverse.SysGen.MySymbolScale + MyUniverse.SysGen.Constants.ConstantSymbolCenter)
                        Copy2WorldXY.y = CInt(CSng(FromXY.y - MyUniverse.SysGen.Constants.ConstantSymbolCenter) * MyUniverse.SysGen.MySymbolScale + MyUniverse.SysGen.Constants.ConstantSymbolCenter)
                End Select 'point-Line
                'todo This is for debugging only.
                If Copy2WorldXY.x < -MyUniverse.SysGen.Constants.ConstantSymbolCenter Then
                    logA(1313, MyShowPoint(Copy2WorldXY), MyShowPoint(FromXY), MyShowPoint(MyPoint1XY(0, 2 * MyUniverse.SysGen.Constants.ConstantSymbolCenter)))
                    Copy2WorldXY.x = -MyUniverse.SysGen.Constants.ConstantSymbolCenter + 10
                End If
                If Copy2WorldXY.x > MyUniverse.SysGen.Constants.ConstantSymbolCenter Then
                    logA(1314, MyShowPoint(Copy2WorldXY), MyShowPoint(FromXY) & MyShowPoint(MyPoint1XY(0, 2 * MyUniverse.SysGen.Constants.ConstantSymbolCenter)))
                    Copy2WorldXY.x = MyUniverse.SysGen.Constants.ConstantSymbolCenter - 10
                End If
                If Copy2WorldXY.y < -MyUniverse.SysGen.Constants.ConstantSymbolCenter Then
                    logA(1315, MyShowPoint(Copy2WorldXY), MyShowPoint(FromXY))
                    Copy2WorldXY.y = -MyUniverse.SysGen.Constants.ConstantSymbolCenter + 10
                End If
                If Copy2WorldXY.y > MyUniverse.SysGen.Constants.ConstantSymbolCenter Then
                    logA(1316, MyShowPoint(Copy2WorldXY), MyShowPoint(FromXY))
                    Copy2WorldXY.y = MyUniverse.SysGen.Constants.ConstantSymbolCenter - 10
                End If
            Case Else
                logA(1317, SourceForm.Parent.Name)
                Copy2WorldXY.x = -1
                Copy2WorldXY.y = -1
        End Select

        If MyDebug(debugLevel) Then
            logA(1363,
                          MyShowPoint(FromXY.x, FromXY.y),
                          MyShowPoint(Copy2WorldXY.x, Copy2WorldXY.y),
                          MyShowPoint(MyUniverse.MyMouseAndDrawing.MyScreen00.x,
                                      MyUniverse.MyMouseAndDrawing.MyScreen00.y),
                          MyShowPoint(FromXY),
                          MyShowPoint(Copy2WorldXY))
        End If
    End Function


    Friend Function Copy2WorldXYXY(ByRef SourceForm As Source, CodeString As String, FromXY As MyLineStructure) As MyLineStructure
        Dim TempH, TempV As Single
        Copy2WorldXYXY = Nothing
        LimitScale()
        Select Case LCase(SourceForm.Parent.Name)
            Case "FlowChartWindow"
                'todo need to hide scroll bars if the hand option is used.
                If MyOptionTest(23) = True Then ' the origin is set by either CmdMoveHand or by scroll bars.
                    TempH = MyUniverse.MyMouseAndDrawing.MyScreen00.x
                    TempV = MyUniverse.MyMouseAndDrawing.MyScreen00.y
                Else
                    MsgBox("Halt")
                    '''''TempH = CInt((MyUniverse.MyMouseAndDrawing.MouseWindow.b.x + MyUniverse.MyMouseAndDrawing.MouseWindow.a.x) * FlowChartWindow.HScrollBar1.Value / FlowChartWindow.HScrollBar1.Maximum)
                    '''''TempV = CInt((MyUniverse.MyMouseAndDrawing.MouseWindow.b.y - MyUniverse.MyMouseAndDrawing.MouseWindow.a.y) * FlowChartWindow.VScrollBar1.Value / FlowChartWindow.VScrollBar1.Maximum)
                End If

                Select Case LCase(CodeString)
                    Case "/path" 'point/path grid snap
                        MyUniverse.Area.MyWorldXY = MyPathSnap(MyUniverse.Area.MyWorldXY)
                        Copy2WorldXYXY = MyLineSnap(MyLine1(SourceForm, CInt(FromXY.a.x + TempH), CInt(FromXY.a.y + TempV), CInt(FromXY.b.x + TempH), CInt(FromXY.b.y + TempV)))
                    Case Else
                        logA(1311, CodeString)
                End Select
            Case "SymbolWindow"
                logA(1312, CodeString.ToString, SourceForm.Parent.Name)
                'todo This is for debugging only.
            Case Else
                logA(1317, SourceForm.Parent.Name)
        End Select
    End Function



    Friend Function ThisExtension(extensions As String, whichOne As Integer) As String
        Dim j As Integer
        Dim Z, A As String
#If DEBUGMODE Then
           LogA(1146, extensions)
#End If
        A = extensions
        Z = extensions
        For j = 1 To whichOne
            A = Pop(Z, FD)
        Next j
        If A <> "" Then
            If MyLeft(A, 1) <> "." Then
                A = "." & A
            End If
        End If
        Return A
    End Function


    Friend Function WorldOrWindow(xy As MyPointStructure) As String
        If (MyABS(xy.x) > 2000 Or MyABS(xy.y) > 2000) Then
            Return "WORLD"
        Else
            Return "WINDOW"
        End If
    End Function

    Friend Function Point2MyPointStruct(xy As Point) As MyPointStructure
        Point2MyPointStruct.Named.PathName = ""
        Point2MyPointStruct.Named.PointName = ""
        Point2MyPointStruct.Named.SymbolName = ""
        Point2MyPointStruct.Named.IsWorldWindow = ""
        Point2MyPointStruct.x = xy.X
        Point2MyPointStruct.y = xy.Y
        Point2MyPointStruct.Named.IsWorldWindow = WorldOrWindow(Point2MyPointStruct)
        Return Point2MyPointStruct
    End Function

    Friend Function MyPointStruct2Point(x As Integer, y As Integer) As Point
        MyPointStruct2Point.X = x
        MyPointStruct2Point.Y = y
    End Function

    Friend Function MyPointStruct2Point(xy As MyPointStructure) As Point
        MyPointStruct2Point.X = xy.x
        MyPointStruct2Point.Y = xy.y
    End Function


    'Routine This will write out one Line of text to the file stream I/O
    Friend Sub MyWriteLine1(Writer As StreamWriter, OutPutString As String)
        While MyRight(OutPutString, 1) = vbCr Or MyRight(OutPutString, 1) = vbLf
            OutPutString = Mid(OutPutString, 1, Len(OutPutString) - 1)
        End While
        Writer.WriteLine(OutPutString)
        'Debug . Print ( OutPutString)
    End Sub


    Friend Function NoComments(MyCodeLine As String) As String
        Dim TempComment As String
        NoComments = MyCodeLine
        TempComment = Options.ListBoxSymbolData.Items.Item(21).ToString
        If MyInStr(TempComment, MyCodeLine) > 0 Then
            NoComments = Mid(MyCodeLine, 1, MyInStr(TempComment, MyCodeLine) - 1)
            Exit Function
        End If
    End Function



    ' This is parsing the import file from the format /keyword=options ... 
    Friend Function TrimEqual(InputString As String) As String
        If MyLeft(InputString, 1) = "=" Then ' change in the delimiters 2020 08 13
            TrimEqual = Trim(Mid(InputString, 2, Len(InputString)))
        Else
            TrimEqual = InputString
        End If
    End Function


    Friend Function MyTrim(S As String) As String
        MyTrim = Trim(S)
        MyTrim = TrimOff(MyTrim, vbCrLf)
        MyTrim = TrimOff(MyTrim, vbLf)
        MyTrim = TrimOff(MyTrim, vbCr)
        MyTrim = TrimOff(MyTrim, vbTab)
        If S <> FD Then
            MyTrim = TrimOff(MyTrim, FD)
        End If
        MyTrim = Trim(MyTrim) 'doing it again just to make sure
    End Function


    Friend Sub Export_FlowChartSettings(ByRef SourceForm As Source, expanded As Boolean, MyWriter As StreamWriter)
        Dim I As Integer
        Dim OutputLine As String
        If expanded = False Then Return

        ' Write out all of the options that are turned OFF
        MyWriteLine1(MyWriter, "/FCCL_Case=" & MyBin2HEX(Options.ListBoxSymbolData.Items.Item(20).ToString))
        MyWriteLine1(MyWriter, "/FCCL_Comment= " & MyBin2HEX(Options.ListBoxSymbolData.Items.Item(21).ToString))
        MyWriteLine1(MyWriter, "/FCCL_Extension=" & MyBin2HEX(Options.ListBoxSymbolData.Items.Item(25).ToString))
        MyWriteLine1(MyWriter, "/FCCL_MultiLine=" & MyBin2HEX(MyUniverse.ProgramOptions.FCCL_MultiLine))
        MyWriteLine1(MyWriter, "/FCCL_VarChars=" & MyBin2HEX(MyUniverse.ProgramOptions.FCCL_VarChars))

        OLD.DisplayStatus(3219, " Formats ")

        OutputLine = FormatSet_

        While Len(OutputLine) > 0
            MyWriteLine1(MyWriter, "/Ignore= Format= " & PopLine(OutputLine) & vbCrLf)
            OutputLine = MyTrim(OutputLine)
        End While

        OLD.DisplayStatus(3219, " Options ")
        For I = 0 To Options.CheckedListBoxFlowChartOptions.Items.Count - 1

            If Options.CheckedListBoxFlowChartOptions.GetItemChecked(I) = True Then
                MyWriteLine1(MyWriter, "/Set=Option" & COMMA & I.ToString & COMMA & "On, " & Options.CheckedListBoxFlowChartOptions.Items.Item(I).ToString)
            Else
                MyWriteLine1(MyWriter, "/Set=Option" & COMMA & I.ToString & COMMA & "Off, " & Options.CheckedListBoxFlowChartOptions.Items.Item(I).ToString)
            End If
        Next I


        MyWriteLine1(MyWriter, "/Ignore= Format= " & FormatErrorMessage & vbCrLf) '⬂string1⬃

        MyWriteLine1(MyWriter, "/ignore= Markers/Constants ")
        MyWriteLine1(MyWriter, "/ConstantQuote=" & MyBin2HEX(MyUniverse.SysGen.Constants.ConstantQuote))
        MyWriteLine1(MyWriter, "/MarkerQuotes=" & MyBin2HEX(MyUniverse.SysGen.Markers.Quotes))
        '" SyntaxVariable=" & myBin2hex(MyUniverse.SysGen.Markers.Variables & vbCrLf)
        MyWriteLine1(MyWriter, "/MarkerNumber=" & MyBin2HEX(MyUniverse.SysGen.Markers.Numbers))
        MyWriteLine1(MyWriter, "/MarkerAlpha=" & MyBin2HEX(MyUniverse.SysGen.Markers.Alphas))
        MyWriteLine1(MyWriter, "/MarkerSpecialCharacters=" & MyBin2HEX(MyUniverse.SysGen.Markers.SpecialCharacter))
        MyWriteLine1(MyWriter, "/MarkerComment=" & MyBin2HEX(MyUniverse.SysGen.Markers.Comments))
        MyWriteLine1(MyWriter, "/ConstantSymbolCenter=" & MyUniverse.SysGen.Constants.ConstantSymbolCenter)
        MyWriteLine1(MyWriter, "/ConstantSpacingFactor=" & MyUniverse.SysGen.Constants.ConstantSpacingFactor)
        MyWriteLine1(MyWriter, "/ConstantMinPenSize=" & MyUniverse.SysGen.Constants.ConstantMinPenSize)
        MyWriteLine1(MyWriter, "/ConstantMaxPenSize=" & MyUniverse.SysGen.Constants.ConstantMaxPenSize)
        MyWriteLine1(MyWriter, "/ConstantMinBoxSize=" & MyUniverse.SysGen.Constants.ConstantMinBoxSize)
        MyWriteLine1(MyWriter, "/ConstantDistanceBetweenControls=" & MyUniverse.SysGen.Constants.ConstantDistanceBetweenControls)
        MyWriteLine1(MyWriter, "/ConstantRecordsBeforeSaveIsAllowed=" & MyUniverse.SysGen.Constants.ConstantRecordsBeforeSaveIsAllowed)
        MyWriteLine1(MyWriter, "/ConstantDistanceToMovePaths=" & MyUniverse.SysGen.Constants.ConstantDistanceToMovePaths)
        MyWriteLine1(MyWriter, "/ConstantSpecialCharacters=" & MyUniverse.SysGen.Constants.ConstantSpecialCharacters)
        '    (FileName, "/ConstantWhiteSpace=" & MyUniverse.SysGen.Constants.ConstantWhiteSpaces & vbCrLf)
        'todo this is a bug, it should Output the hex values of the delimiters (as in import ... 
        MyWriteLine1(MyWriter, "/ConstantDelimiters=" & MyBin2HEX(MyUniverse.SysGen.Constants.ConstantDelimiters))
        MyWriteLine1(MyWriter, "/MarkerCameFromLine=" & MyBin2HEX(MyUniverse.SysGen.Markers.CameFromLine))
        MyWriteLine1(MyWriter, "/MarkerBranchToNextLine=" & MyBin2HEX(MyUniverse.SysGen.Markers.BranchToNextLine))
        MyWriteLine1(MyWriter, "/ignore=/route= (optional start,finish) tries to connect all paths with the same name " & vbCrLf)
        'MyWriteLine1(MyWriter, "/ignore= " & MyBin2HEX(MyUniverse.MySS.Inputs.KPar))
        MyWriteLine1(MyWriter, "/ignore=  option=" & FormatOption & vbCrLf)
        MyWriteLine1(MyWriter, "/Ignore= FormatColor=" & formatColor & vbCrLf)
        MyWriteLine1(MyWriter, "/Ignore= FormatDataType=" & formatDataType & vbCrLf)
        MyWriteLine1(MyWriter, "/Ignore= FormatFileName=" & formatNameOfFile & vbCrLf)
        MyWriteLine1(MyWriter, "/Ignore= FormatLanguage=" & formatLanguage & vbCrLf)
        MyWriteLine1(MyWriter, "/Ignore= FormatLine=" & formatLine & vbCrLf)
        MyWriteLine1(MyWriter, "/Ignore= FormatLines=" & formatLines & vbCrLf)
        MyWriteLine1(MyWriter, "/Ignore= FormatMicroCodeText=" & FormatMacroText & vbCrLf)
        MyWriteLine1(MyWriter, "/Ignore= FormatNotes=" & formatNotes & vbCrLf)
        MyWriteLine1(MyWriter, "/Ignore= FormatPath=" & formatPath & vbCrLf)
        MyWriteLine1(MyWriter, "/Ignore= FormatPoint=" & formatPoint & vbCrLf)
        'MyWriteLine1(MyWriter, "/Ignore= FormatSet=" & FormatSet_ & vbCrLf)
        MyWriteLine1(MyWriter, "/Ignore= FormatStroke=" & formatStroke & vbCrLf)
        MyWriteLine1(MyWriter, "/Ignore= FormatSyntax=" & FormatSyntax & vbCrLf)
        MyWriteLine1(MyWriter, "/Ignore= FormatUse=" & formatUse & vbCrLf)
        MyWriteLine1(MyWriter, "/Ignore= FormatVersion=" & formatVersion & vbCrLf)
        MyWriteLine1(MyWriter, "/Ignore= FormatAuthor=" & formatAuthor & vbCrLf)
        MyWriteLine1(MyWriter, "/Ignore= FormatOpCode=" & formatOpcode & vbCrLf)
        MyWriteLine1(MyWriter, "/Ignore= FormatConstant=" & formatConstant & vbCrLf)
        MyWriteLine1(MyWriter, "/Ignore= FormatError=" & FormatError & vbCrLf)
        MyWriteLine1(MyWriter, "/Ignore= FormatDelete=" & FormatDelete & vbCrLf)
        MyWriteLine1(MyWriter, "/Ignore= FormatKeyWord=" & FormatLanguage_KeyWord & vbCrLf)
        MyWriteLine1(MyWriter, "/Ignore= FormatOperator=" & FormatLanguage_Operator & vbCrLf)
        MyWriteLine1(MyWriter, "/Ignore= FormatFunction=" & FormatLanguage_Function & vbCrLf)
        MyWriteLine1(MyWriter, "/Ignore= FormatGrammar=" & FormatLanguage_Grammar & vbCrLf) 'todo need to fix this one day


        For I = 0 To MySizeOf(MyUniverse.MySymbolPoints)
            MyWriteLine1(MyWriter, "/set=points," & I.ToString & COMMA & MyUniverse.MySymbolPoints(I).x & COMMA & MyUniverse.MySymbolPoints(I).y & vbCrLf)
        Next I
        For I = 0 To MyUniverse.OptionDisplay.Count - 1
            MyWriteLine1(MyWriter, "/set=text," & MyBin2HEX(MyUniverse.OptionDisplay(I).x.ToString & COMMA & MyUniverse.OptionDisplay(I).y.ToString & COMMA & MyUniverse.OptionDisplay(I).TextWidth.ToString & COMMA & MyUniverse.OptionDisplay(I).TextHeight.ToString & COMMA & MyUniverse.OptionDisplay(I).ColorName))
        Next I

        For I = 0 To Options.CheckedListBoxFlowChartOptions.Items.Count - 1
            If Len(Options.CheckedListBoxFlowChartOptions.Items(I).ToString) > 0 Then
                MyWriteLine1(MyWriter, "/set=options," & I.ToString & COMMA & TrueOrFalse(MyOptionTest(I).ToString) & COMMA & Options.CheckedListBoxFlowChartOptions.Items(I).ToString & vbCrLf)
            End If
        Next I

        'TempFormat=formatColor
        MyWriteLine1(MyWriter, "/Ignore= Format= " & formatColor & vbCrLf)
        For I = 1 To TopOfFile(SourceForm, "Color") - 1
            OutputLine = MyShowColor(SourceForm, False, I) & vbCrLf
            MyWriteLine1(MyWriter, OutputLine)
        Next


        OLD.DisplayStatus(3219, " Colors and DataTypes")
        'TempFormat=formatDataType
        'DataTypes are not getting sorted before export

        MyWriteLine1(MyWriter, "/Ignore= Format= " & formatDataType & vbCrLf)
        For I = 1 To TopOfFile(SourceForm, "DataType")
            OutputLine = MyShowDataTypeTable(SourceForm, False, I) & vbCrLf
            MyWriteLine1(MyWriter, OutputLine)
        Next
        OutputLine = Nothing

        ' We have to Output it in the order of the file.
        MyWriteLine1(MyWriter, "/Ignore= Format=   " & formatSymbolName & vbCrLf)
        MyWriteLine1(MyWriter, "/Ignore= Format=   " & formatAuthor & vbCrLf)
        MyWriteLine1(MyWriter, "/Ignore= Format=   " & formatVersion & vbCrLf)
        MyWriteLine1(MyWriter, "/Ignore= Format=   " & formatNameOfFile & vbCrLf)
        MyWriteLine1(MyWriter, "/Ignore= Format=   " & formatStroke & vbCrLf)
        MyWriteLine1(MyWriter, "/Ignore= Format=   " & formatNotes & vbCrLf)
        MyWriteLine1(MyWriter, "/Ignore= Format=   " & formatOpcode & vbCrLf)
        MyWriteLine1(MyWriter, "/Ignore= Format=   " & FormatMacroText & vbCrLf)
        MyWriteLine1(MyWriter, "/Ignore= Format=   " & FormatSyntax & vbCrLf)
        MyWriteLine1(MyWriter, "/Ignore= Format=   " & formatPoint & vbCrLf)
        MyWriteLine1(MyWriter, "/Ignore= Format=   " & formatLine & vbCrLf)

        'todo need to change all of this to use my show FlowChart()
        MyWriteLine1(MyWriter, "/Ignore= Format=   " & formatPath & vbCrLf)
        MyWriteLine1(MyWriter, "/Ignore= Format=   " & formatUse & vbCrLf)
        MyWriteLine1(MyWriter, "/Ignore= Format=   " & formatConstant & vbCrLf)
        MyWriteLine1(MyWriter, "/Ignore= Format=   " & FormatError & vbCrLf)
        MyWriteLine1(MyWriter, "/Ignore= Format=   " & FormatDelete & vbCrLf)



        MyWriteLine1(MyWriter, "/Ignore= Format=   " & FormatConstantBranchToNextLine & vbCrLf)
        MyWriteLine1(MyWriter, "/Ignore= Format=   " & FormatConstantDelimiter & vbCrLf)
        MyWriteLine1(MyWriter, "/Ignore= Format=   " & FormatConstantDelimiters & vbCrLf)
        MyWriteLine1(MyWriter, "/Ignore= Format=   " & FormatConstantDistanceBetweenControls & vbCrLf)
        MyWriteLine1(MyWriter, "/Ignore= Format=   " & FormatConstantDistanceToMovePaths & vbCrLf)
        MyWriteLine1(MyWriter, "/Ignore= Format=   " & FormatConstantMaxPenSize & vbCrLf)
        MyWriteLine1(MyWriter, "/Ignore= Format=   " & FormatConstantMinBoxSize & vbCrLf)
        MyWriteLine1(MyWriter, "/Ignore= Format=   " & FormatConstantMinPenSize & vbCrLf)
        MyWriteLine1(MyWriter, "/Ignore= Format=   " & FormatConstantQuote & vbCrLf)
        MyWriteLine1(MyWriter, "/Ignore= Format=   " & FormatConstantRecordsBeforeSaveIsAllowed & vbCrLf)
        MyWriteLine1(MyWriter, "/Ignore= Format=   " & FormatConstantSpacingFactor & vbCrLf)
        MyWriteLine1(MyWriter, "/Ignore= Format=   " & FormatConstantSpecialCharacters & vbCrLf)
        MyWriteLine1(MyWriter, "/Ignore= Format=   " & FormatConstantSymbolCenter & vbCrLf)
        MyWriteLine1(MyWriter, "/Ignore= Format=   " & FormatConstantWhiteSpaceD & vbCrLf)
        MyWriteLine1(MyWriter, "/Ignore= Format=   " & FormatConstantWhiteSpaceH & vbCrLf)
        MyWriteLine1(MyWriter, "/Ignore= Format=   " & Formatdebug & vbCrLf)
        MyWriteLine1(MyWriter, "/Ignore= Format=   " & FormatDelete & vbCrLf)
        MyWriteLine1(MyWriter, "/Ignore= Format=   " & Formatdrilldown & vbCrLf)
        MyWriteLine1(MyWriter, "/Ignore= Format=   " & Formatdump & vbCrLf)
        MyWriteLine1(MyWriter, "/Ignore= Format=   " & Formatexit & vbCrLf)
        MyWriteLine1(MyWriter, "/Ignore= Format=   " & Formatexport & vbCrLf)
        MyWriteLine1(MyWriter, "/Ignore= Format=   " & FormatFCCL_case & vbCrLf)
        MyWriteLine1(MyWriter, "/Ignore= Format=   " & FormatFCCL_comment & vbCrLf)
        MyWriteLine1(MyWriter, "/Ignore= Format=   " & FormatFCCL_Default_Root & vbCrLf)
        MyWriteLine1(MyWriter, "/Ignore= Format=   " & FormatFCCL_Default_Roots & vbCrLf)
        MyWriteLine1(MyWriter, "/Ignore= Format=   " & FormatFCCL_DialectName & vbCrLf)
        MyWriteLine1(MyWriter, "/Ignore= Format=   " & FormatFCCL_Dimension & vbCrLf)
        MyWriteLine1(MyWriter, "/Ignore= Format=   " & FormatFCCL_Extensions & vbCrLf)
        MyWriteLine1(MyWriter, "/Ignore= Format=   " & FormatFCCL_multiLine & vbCrLf)
        MyWriteLine1(MyWriter, "/Ignore= Format=   " & FormatFCCL_Root & vbCrLf)
        MyWriteLine1(MyWriter, "/Ignore= Format=   " & FormatFCCL_Roots & vbCrLf)
        MyWriteLine1(MyWriter, "/Ignore= Format=   " & FormatFCCL_varchars & vbCrLf)
        MyWriteLine1(MyWriter, "/Ignore= Format=   " & FormatFcfinish & vbCrLf)
        MyWriteLine1(MyWriter, "/Ignore= Format=   " & Formatfunctions & vbCrLf)
        MyWriteLine1(MyWriter, "/Ignore= Format=   " & Formatignore & vbCrLf)
        MyWriteLine1(MyWriter, "/Ignore= Format=   " & Formatimport & vbCrLf)
        MyWriteLine1(MyWriter, "/Ignore= Format=   " & FormatKeywordS & vbCrLf)
        MyWriteLine1(MyWriter, "/Ignore= Format=   " & Formatlogin & vbCrLf)
        MyWriteLine1(MyWriter, "/Ignore= Format=   " & FormatMarkerAlpha & vbCrLf)
        MyWriteLine1(MyWriter, "/Ignore= Format=   " & FormatMarkerBranchToNextLine & vbCrLf)
        MyWriteLine1(MyWriter, "/Ignore= Format=   " & FormatMarkerCameFromLine & vbCrLf)
        MyWriteLine1(MyWriter, "/Ignore= Format=   " & FormatMarkerComment & vbCrLf)
        MyWriteLine1(MyWriter, "/Ignore= Format=   " & FormatMarkerNumber & vbCrLf)
        MyWriteLine1(MyWriter, "/Ignore= Format=   " & FormatMarkerQuotes & vbCrLf)
        MyWriteLine1(MyWriter, "/Ignore= Format=   " & FormatMarkerSpecialCharacters & vbCrLf)
        MyWriteLine1(MyWriter, "/Ignore= Format=   " & FormatMessage & vbCrLf)
        MyWriteLine1(MyWriter, "/Ignore= Format=   " & Formatoperators & vbCrLf)
        MyWriteLine1(MyWriter, "/Ignore= Format=   " & Formatroute & vbCrLf)
        MyWriteLine1(MyWriter, "/Ignore= Format=   " & Formattranslate & vbCrLf)
        MyWriteLine1(MyWriter, "/Ignore= Format=   " & FormatUnknown & vbCrLf)
        MyWriteLine1(MyWriter, "/Ignore= Format=   " & Formatx1 & vbCrLf)
        MyWriteLine1(MyWriter, "/Ignore= Format=   " & Formatx2 & vbCrLf)
        MyWriteLine1(MyWriter, "/Ignore= Format=   " & Formaty1 & vbCrLf)
        MyWriteLine1(MyWriter, "/Ignore= Format=   " & Formaty2 & vbCrLf)
        MyWriteLine1(MyWriter, "/Ignore= Format=   " & FormatBlock & vbCrLf)
        MyWriteLine1(MyWriter, "/Ignore= Format=   " & FormatBlocks & vbCrLf)






    End Sub


    'Routine This writes out all of the data in the MyArrays to a file (Has error, not able to create a new file yet)

    'done needs to redo this and all of the MyShowFlowChart(), MyShowSymbol() and so on so that it ONLY returns the export (Which will then appear everywhere else yI need to show a record, (and not all of the internal junk)
    'todo need to NOT Output the /ignore format's twice (only just above where they are needed)
    Friend Sub Export(ByRef SourceForm As Source, expanded As Boolean, MyOutputFileName As String)
        Dim OutPutLine As String
        Dim I, IndexFlowChart, IndexSymbol, IndexNamed As Integer
        Dim LineCount As Integer
        LineCount = 0

        If MyDebug(A_INFORMATION) Then logA(2839, MyOutputFileName)
        If Dir(MyOutputFileName) <> "" Then ' need to create the file if it does not exist then you can ... 
            Kill(MyOutputFileName)
        End If

        Using Writer As System.IO.StreamWriter = System.IO.File.CreateText(MyOutputFileName)
        End Using



        ' Now open it for Output
        'Using MyWriter As System.IO.StreamWriter=System.IO.File.OpenText(OutputFileName)
        Using MyWriter As New StreamWriter(MyOutputFileName)
            If expanded = True Then MyWriteLine1(MyWriter, "/Ignore= Format= " & formatLanguage & vbCrLf) : LineCount += 1
            MyWriteLine1(MyWriter, "/Language=" & MyUniverse.ProgramOptions.FCCL_LanguageClassName & COMMA & Options.ListBoxSymbolData.Items.Item(23).ToString & vbCrLf) : LineCount += 1
            'MyWriteLine1(MyWriter, "/Ignore= format= /ignore=Anything and everything is ignored on this line.") : LineCount += 1

            Export_FlowChartSettings(SourceForm, expanded, MyWriter)

            MyWriteLine1(MyWriter, "/set=delimiters," & AddRM(FD) & vbCrLf)
            '"/set=language,name of language to add to the list box, which will be useless."
            MyWriteLine1(MyWriter, "/set=scale," & Int(MyUniverse.SysGen.MyFlowChartScale * 1000).ToString & vbCrLf)
            If expanded = True Then MyWriteLine1(MyWriter, "/ignore= format of set=Grids,snap=1-10,point snap =1-250, Symbol snap 1-10000, Symbol column snap 500-2500" & vbCrLf)
            MyWriteLine1(MyWriter, "/set=Grids," & MyUniverse.SysGen.Snaps.MySnap.ToString & COMMA & MyUniverse.SysGen.Snaps.MyPointSnap.ToString & COMMA & MyUniverse.SysGen.Snaps.MySymbolSnap.ToString & vbCrLf)
            MyWriteLine1(MyWriter, "/set=dump," & FileNameOnly(MyUniverse.MySystem.Dumps.OutputFileName1 & COMMA) & FileNameOnly(MyUniverse.MySystem.Dumps.OutputFileName2 & COMMA) & FileNameOnly(MyUniverse.MySystem.Dumps.OutputFileName3) & vbCrLf)
            If expanded = True Then MyWriteLine1(MyWriter, "/Ignore= Format= " & FormatLanguage_KeyWord & vbCrLf) : LineCount += 1
            For IndexFlowChart = 0 To Options.ListBox_KeyWords.Items.Count
                If MyInStr(MyConstantIgnoreFunctionOperatorKeyWord, Options.ListBox_KeyWords.Items(IndexFlowChart).ToString) = 0 Then
                    If Options.ListBox_KeyWords.Items(IndexFlowChart).ToString <> "" And
    MyLeft(Options.ListBox_KeyWords.Items(IndexFlowChart).ToString, Len(Options.ListBox_KeyWords.Items(IndexFlowChart))) <> MyConstantIgnoreFunctionOperatorKeyWord Then
                        OutPutLine = MyShowKeyWord("/keyword", Options.ListBox_KeyWords.Items(IndexFlowChart).ToString & vbCrLf)
                        MyWriteLine1(MyWriter, OutPutLine) : LineCount += 1 ': 
                    Else 'ignore blank keywords 
                        'OutPutLine = "/IGNORE=/KEYWORD=" & MyBin2HEX(Options.ListBox_KeyWords.Items(IndexFlowChart))
                        'MyWriteLine1(MyWriter, OutPutLine) : LineCount += 1 ': 
                    End If
                End If
            Next IndexFlowChart

            'TempFormat=FormatLanguage_operator
            If expanded = True Then MyWriteLine1(MyWriter, "/Ignore= Format= " & FormatLanguage_Operator & vbCrLf) : LineCount += 1
            For IndexFlowChart = LBound(Language_Operator) To MySizeOf(Language_Operator)
                If MyInStr(MyConstantIgnoreFunctionOperatorKeyWord, Language_Operator(IndexFlowChart)) = 0 Then
                    If Language_Operator(IndexFlowChart) <> "" Then
                        OutPutLine = MyShowKeyWord("/operator", Language_Operator(IndexFlowChart) & vbCrLf) : LineCount += 1
                        MyWriteLine1(MyWriter, OutPutLine)
                    Else 'do not write out blank line 
                        'OutPutLine = Language_Operator(IndexFlowChart) & MyConstantIgnoreFunctionOperatorKeyWord & vbCrLf
                        'MyWriteLine1(MyWriter, "/Ignore=operator," & OutPutLine)
                    End If
                End If
            Next IndexFlowChart

            'TempFormat=FormatLanguage_Function
            '''''If expanded = True Then MyWriteLine1(MyWriter, "/Ignore= Format= " & FormatLanguage_Function & vbCrLf) : LineCount += 1
            '''''For IndexFlowChart = LBound(Language_Function) To MySizeOf(Language_Function)
            '''''If MyInStr(MyConstantIgnoreFunctionOperatorKeyWord, Language_Function(IndexFlowChart)) = 0 Then
            '''''If Language_Function(IndexFlowChart) <> "" Then
            '''''OutPutLine = MyShowKeyWord("/Function", Language_Function(IndexFlowChart) & vbCrLf)
            '''''MyWriteLine1(MyWriter, OutPutLine) : LineCount += 1
            '''''Else
            '''''OutPutLine = Language_Function(IndexFlowChart) & MyConstantIgnoreFunctionOperatorKeyWord & vbCrLf
            '''''End If
            '''''End If
            '''''Next IndexFlowChart

            'Write out all of the key words
            'TempFormat=FormatLanguage_KeyWord
            If expanded = True Then MyWriteLine1(MyWriter, "/Ignore= Format= " & FormatLanguage_Grammar & vbCrLf) : LineCount += 1
            For IndexFlowChart = LBound(Language_Grammar) To MySizeOf(Language_Grammar)
                If MyInStr(MyConstantIgnoreFunctionOperatorKeyWord, Language_Grammar(IndexFlowChart)) = 0 Then
                    If Language_Grammar(IndexFlowChart) <> "" And MyLeft(Language_Grammar(IndexFlowChart), Len(Language_Grammar(IndexFlowChart))) <> MyConstantIgnoreFunctionOperatorKeyWord Then
                        OutPutLine = "/Grammar=" & Language_Grammar(IndexFlowChart)
                        OutPutLine = UnFixHexGrammar(OutPutLine) & vbCrLf
                        MyWriteLine1(MyWriter, OutPutLine) : LineCount += 1
                    Else
                        OutPutLine = Language_Grammar(IndexFlowChart) & MyConstantIgnoreFunctionOperatorKeyWord
                    End If
                End If
            Next IndexFlowChart

            For IndexNamed = 1 To TopOfFile(SourceForm, "Named")
                IndexSymbol = CorrectingIndexes(SourceForm, Named_TableSymbolName(IndexNamed))
                OutPutLine = MyShowNamedAndSymbolRecords(SourceForm, False, IndexSymbol)
                MyWriteLine1(MyWriter, OutPutLine) : LineCount += 1
            Next

            OLD.DisplayStatus(3221, TopOfListBox(SourceForm.ListBoxFlowChart).ToString)

            For IndexFlowChart = 1 To TopOfListBox(SourceForm.ListBoxFlowChart)
                I = IndexFlowChart
                Select Case LCase(FlowChart_TableCode(SourceForm, I))
                    Case My_keyWord(My_KeyConstUse)
                        ' Error here X3 should never be Null (-1)
                        OutPutLine = MyShowFlowChartRecord(SourceForm, False, I)
                        If expanded = True Then OutPutLine &= vbCrLf & "/ignore=" & formatUse & vbCrLf
                        MyWriteLine1(MyWriter, OutPutLine) : LineCount += 1
                    Case "/path"
                        OLD.DisplayStatus(3223, FlowChart_TablePathName(SourceForm, I))
                        OutPutLine = MyShowPath(SourceForm, False, I) & vbCrLf
                        MyWriteLine1(MyWriter, OutPutLine) : LineCount += 1
                    Case "/Constant"
                        OutPutLine = "/Constant" & "="
                        OutPutLine &= COMMA & PrintAbleNull(FindInSymbolList(SourceForm, FlowChart_TableOther_Name(SourceForm, I)).ToString)
                        OutPutLine &= COMMA & FlowChart_TableX1(SourceForm, I)
                        OutPutLine &= COMMA & FlowChart_TableY1(SourceForm, I)
                        OutPutLine &= COMMA & FlowChart_TableDataType(SourceForm, I) & vbCrLf
                        'TempFormat=formatConstant
                        MyWriteLine1(MyWriter, OutPutLine) : LineCount += 1
                    Case "/delete" 'todo should never export deleted records ? (Well maybe if expanded = true)
                        'If expanded = True Then
                        ' OutPutLine = vbCrLf & "/delete" & "="
                        ' OutPutLine &= COMMA & PrintAbleNull(FindInSymbolList(SourceForm,SourceForm ,FlowChart_TableOther_Name(SourceForm    , I)).ToString)
                        ' OutPutLine &= COMMA & FlowChart_TableX1(SourceForm ,I)
                        ' OutPutLine &= COMMA & FlowChart_TableY1(SourceForm    , SourceForm    , I)
                        ' OutPutLine &= COMMA & FlowChart_TableX2(SourceForm, I)
                        ' OutPutLine &= COMMA & FlowChart_TableY2(SourceForm, I)
                        ' OutPutLine &= COMMA & PrintAbleNull(FlowChart_TableDataType(SourceForm , I)) & vbCrLf
                        OutPutLine = MyShowFlowChartRecord(SourceForm, expanded, I)
                        MyWriteLine1(MyWriter, OutPutLine) : LineCount += 1
                            'End If
                    Case "/error"
                        'If expanded=True Then
                        'TempFormat=FormatError
                        OutPutLine = "/error" & "=" & FlowChart_TableCode(SourceForm, I)
                        OutPutLine &= COMMA & PrintAbleNull(FindInSymbolList(SourceForm, FlowChart_TableOther_Name(SourceForm, I)).ToString)
                        OutPutLine &= COMMA & FlowChart_TableX1(SourceForm, I)
                        OutPutLine &= COMMA & FlowChart_TableY1(SourceForm, I)
                        OutPutLine &= COMMA & FlowChart_TableX2(SourceForm, I)
                        OutPutLine &= COMMA & FlowChart_TableY2(SourceForm, I)
                        OutPutLine &= COMMA & FlowChart_TableDataType(SourceForm, I)   ' DataType is not required (ignored) on Import and should be '_' Null
                        OutPutLine &= COMMA & FlowChart_Table_Path_SymbolName(SourceForm, I) & vbCrLf
                        MyWriteLine1(MyWriter, OutPutLine) : LineCount += 1
                            'End If
                    Case "/raw"
                        OutPutLine = MyShowFlowChartRecord(SourceForm, expanded, I)
                        MyWriteLine1(MyWriter, OutPutLine) : LineCount += 1
                    Case Else
                        logA(3545, MyShowFlowChartRecord(SourceForm, expanded, IndexFlowChart))
                        OutPutLine = "/Error=Export FlowChart unknown /" & FlowChart_TableCode(SourceForm, I)
                        OutPutLine &= ",\Code= " & FlowChart_TableCode(SourceForm, I)
                        OutPutLine &= ",\Named= " & FindInSymbolList(SourceForm, FlowChart_TableOther_Name(SourceForm, I))
                        OutPutLine &= ",\Number= " & FlowChart_TablePathName(SourceForm, I)
                        OutPutLine &= ",\X1=" & FlowChart_TableX1(SourceForm, I)
                        OutPutLine &= ",\Y1=" & FlowChart_TableY1(SourceForm, I)
                        OutPutLine &= ",\X2=" & FlowChart_TableX2(SourceForm, I)
                        OutPutLine &= ",\Y2=" & FlowChart_TableY2(SourceForm, I)
                        OutPutLine &= ",\DataType=" & PrintAbleNull(FlowChart_TableDataType(SourceForm, I))
                        OutPutLine &= ",\ i  =" & PrintAbleNull(I.ToString) & vbCrLf
                        MyWriteLine1(MyWriter, OutPutLine) : LineCount += 1
                End Select
            Next

            If expanded = True Then MyWriteLine1(MyWriter, "/Ignore= Format= " & FormatOption & vbCrLf)
            For IndexFlowChart = 0 To MySizeOf(MyMessageBits) * 8
                If IsBitSet(IndexFlowChart) = True Then
                    'MyWriteLine1(MyWriter, "/Option=" & IndexFlowChart & COMMA & "on")
                Else
                    MyWriteLine1(MyWriter, "/Option=" & IndexFlowChart & COMMA & "off" & vbCrLf)
                    LineCount += 1
                End If
            Next


            MyWriter.Close() 'FileClose(MyWriter)
        End Using
        'End Using 'writer1
        '''''ShowAllWindows(ShowWindow, HideWindow, HideWindow, ShowWindow)
        OLD.DisplayStatus(3230, TopOfFile(SourceForm, "color").ToString,
                          TopOfFile(SourceForm, "datatype").ToString,
                          TopOfFile(SourceForm, "keyword").ToString,
                          TopOfFile(SourceForm, "Operator").ToString,
                          TopOfFile(SourceForm, "Function").ToString,
                          TopOfFile(SourceForm, "grammar").ToString,
                          TopOfFile(SourceForm, "named").ToString,
                          TopOfFile(SourceForm, "Symbol").ToString,
                          TopOfListBox(SourceForm.ListBoxFlowChart).ToString)
    End Sub



    Friend Sub ImportAllDataTypes(ByRef SourceForm As Source)

        ImportDataTypes(SourceForm, "Debugging" & FD & "50" & FD & "Green" & FD & "1" & FD & "color used to show when Path Router in progress")
        ImportDataTypes(SourceForm, "Erase" & FD & "1" & FD & "White" & FD & "1" & FD & "Used to erase anything")
        ImportDataTypes(SourceForm, "Errored" & FD & "50" & FD & "Red" & FD & "1" & FD & "Logic or data paths that has an error")
        ImportDataTypes(SourceForm, "Logic" & FD & "1" & FD & "Black" & FD & "3" & FD & "Logic Path")

        ' "/DataType=DataTypeName, Number Of Bytes, Color Name, Color Width, Description"
        'ImportDataTypes("Boolean, 1, Green, 3, A Boolean variable")

        'ImportDataTypes("Bit" & FD & "1" & FD & "Blue" & FD & "3" & FD & "A Single On/off")
        'ImportDataTypes("Byte" & FD & "8" & FD & "MidnightBlue" & FD & "4" & FD & "A Byte (8 bits) ")
        'ImportDataTypes("Floating" & FD & "8" & FD & "DodgerBlue" & FD & "8" & FD & "A floating-point variable WinDef")
        'ImportDataTypes("Int128" & FD & "16" & FD & "MediumOrchid" & FD & "12" & FD & "A 128 bit register ")
        'ImportDataTypes("Int16" & FD & "2" & FD & "MediumAquamarine" & FD & "2" & FD & "A 16-bit Or 2 bytes signed Integer BaseTsd")
        'ImportDataTypes("Int256" & FD & "32" & FD & "MediumBlue" & FD & "16" & FD & "A 256 bit register")
        'ImportDataTypes("Integer" & FD & "4" & FD & "DarkOrange" & FD & "4" & FD & "A 32-bit Or 4 bytes signed Integer -2147483648 through 2147483647 BaseTsd")
        'ImportDataTypes("Int512" & FD & "64" & FD & "MediumPurple" & FD & "19" & FD & "A 512 bit register (XMM or YMM register) ")
        'ImportDataTypes("Int64" & FD & "8" & FD & RandomColor(SourceForm) & FD & "8" & FD & "A 64-bit Or 8 bytes signed Integer ?+/- 9223372036854775807")
        'ImportDataTypes("Int8" & FD & "1" & FD & "Orange" & FD & "2" & FD & "An 8-bit Or 1 Byte signed Integer Based (use byte) ")
        'ImportDataTypes("String" & FD & "512" & FD & "Orange" & FD & "8" & FD & "pointer to string")
        'ImportDataTypes("StringArray" & FD & "512" & FD & "Orange" & FD & "8" & FD & "pointer to  an array of strings")
        '''''SortDataType()
    End Sub




    Friend Sub ImportDataTypes(ByRef SourceForm As Source, Key_Line As String)
        Dim IndexDataType As Integer
        Dim Input_Line As String
        Dim LostColorIndex As Integer

        Dim DTName, DTStyle, DTColor, DTDescribtion As String
        Dim DTSize As Integer
        Input_Line = TrimEqual(Key_Line)
        '  DataType_FileName
        '  DataType_FileDescription
        '  DataType_FileNumberOfBytes
        '  DataType_FileColorIndex
        '  DataType_FileWidth

        Input_Line = MyTrim(Input_Line)
        DTName = MyTrim(Pop(Input_Line, FD & vbLf & vbCr & COMMA & ",=/\" & vbCrLf))
        Input_Line = MyTrim(Input_Line)
        DTSize = CByte(PopValue(Input_Line))
        Input_Line = MyTrim(Input_Line)
        DTColor = Pop(Input_Line, FD & vbLf & vbCr & COMMA & ",=/\" & vbCrLf)
        Input_Line = MyTrim(Input_Line)
        DTStyle = Pop(Input_Line, FD & vbLf & vbCr & COMMA & ",=/\" & vbCrLf)
        Input_Line = MyTrim(Input_Line)
        DTDescribtion = Input_Line


        If PrintAbleNull(DTName) = PrintAbleNull(Nothing) Then
            Return
        End If

        DataType_TableColorIndex(NewTopOfFile(SourceForm, "DataType"), BinarySearch4Index(Options.ListBoxColors, "Errored"))
        DataType_TableColorIndex(NewTopOfFile(SourceForm, "DataType"), BinarySearch4Index(Options.ListBoxColors, DTColor))

        IndexDataType = BinarySearch4Index(Options.ListBoxDataTypes, "add", DTName)
        DataType_TableNumberOfBytes(IndexDataType, DTSize)
        LostColorIndex = BinarySearch4Index(Options.ListBoxColors, DTColor)
        If LostColorIndex = ConstantMyErrorCode Then
            logA(1326, DTColor, DTName, Key_Line)
        End If
        DataType_TableColorIndex(IndexDataType, BinarySearch4Index(Options.ListBoxColors, DTColor))
        If DataType_TableColorIndex(IndexDataType) < 1 Then
            DataType_TableColorIndex(IndexDataType, BinarySearch4Index(Options.ListBoxColors, "RED"))
        End If
        If DataType_TableColorIndex(IndexDataType) = ConstantMyErrorCode Then
            DataType_TableColorIndex(IndexDataType, BinarySearch4Index(Options.ListBoxColors, MyUniverse.ProgramOptions.SelectedColor))
        End If
        DataType_TableWidth(IndexDataType, DTSize)

        DataType_TableDescription(IndexDataType, DTDescribtion)
        '
        Options.ListBoxDataTypes.Items.Add(DataType_TableName(IndexDataType))
    End Sub


    Friend Sub SetOptions(ImportLine As String)
        Dim X0, X1, X2, X3, X4 As String ' DUMP FILE NAMES
        Dim I, I1, I2, I3 As Integer

        X0 = ImportLine
        X1 = Pop(X0, FD) 'What
        Select Case LCase(X1)    ' format /language=(name of language) then all of the options
            Case "points" ' Location of the points (first to last point) 1-121??
                'The first two points are the CameFromLine and BranchTo (1 and 2)
                I1 = MyMinMax(My_INT(Pop(X0, FD)), 0, MySizeOf(MyUniverse.MySymbolPoints))
                I2 = MyMinMax(My_INT(Pop(X0, FD)), -MyUniverse.SysGen.Constants.ConstantSymbolCenter, MyUniverse.SysGen.Constants.ConstantSymbolCenter)
                I3 = MyMinMax(My_INT(Pop(X0, FD)), -MyUniverse.SysGen.Constants.ConstantSymbolCenter, MyUniverse.SysGen.Constants.ConstantSymbolCenter)
                MyUniverse.MySymbolPoints(I1).x = I2
                MyUniverse.MySymbolPoints(I1).y = I3
            Case "text" ' Location of the options to display 
                'The first two points are the CameFromLine and BranchTo (1 and 2)
                I1 = MyMinMax(My_INT(Pop(X0, FD)), 0, MySizeOf(MyUniverse.OptionDisplay))
                I2 = MyMinMax(My_INT(Pop(X0, FD)), -MyUniverse.SysGen.Constants.ConstantSymbolCenter, MyUniverse.SysGen.Constants.ConstantSymbolCenter)
                I3 = MyMinMax(My_INT(Pop(X0, FD)), -MyUniverse.SysGen.Constants.ConstantSymbolCenter, MyUniverse.SysGen.Constants.ConstantSymbolCenter)
                MyUniverse.OptionDisplay(I1).x = I2
                MyUniverse.OptionDisplay(I1).y = I3
                MyUniverse.OptionDisplay(I1).TextWidth = MyMinMax(PopValue(X0), 50, MyUniverse.SysGen.Constants.ConstantSymbolCenter * 2)
                MyUniverse.OptionDisplay(I1).TextHeight = MyMinMax(PopValue(X0), 50, MyUniverse.SysGen.Constants.ConstantSymbolCenter * 16)
            Case "delimiters"
                MyUniverse.SysGen.Constants.RMStart = Pop(X0, FD)
                MyUniverse.SysGen.Constants.RMEnd = Pop(X0, FD)
            Case "language" ' Set a new language parameter (for any new language)
                'hack, need to also see if this language is already there and replace it.
                Options.ListBoxLanguageClass.Items.Add(X0)
    'todo Also Select this as the default language now
            Case "options", "option"
                'Force it to only change the available list

                While Len(X0) > 0
                    X2 = Pop(X0, FD) ' The option number 'todo need to check if this is within the range of the list.(0-63)
                    X3 = Pop(X0, FD) ' on/off, 0/1, false,true
                    X4 = Pop(X0, FD) ' The text for this option (No Commas allowed)
                    logA(2150, X2, X3, X4)
                    I = MyMinMax(My_INT(X2), 0, Options.CheckedListBoxFlowChartOptions.Items.Count - 1)
                    If TrueOrFalse(X3) = True Then
                        Options.CheckedListBoxFlowChartOptions.SetItemCheckState(I, CheckState.Checked)
                    Else
                        Options.CheckedListBoxFlowChartOptions.SetItemCheckState(I, CheckState.Unchecked)
                    End If
                    If X4 <> "" Then Options.CheckedListBoxFlowChartOptions.Items(I) = X4
                End While

            Case "scale"
                X2 = Pop(X0, FD)
                MyUniverse.SysGen.MyFlowChartScale = CSng(CInt(X2) / 1000.0)
                LimitScale()
            Case "Grids"
                'Done Add /set=grids=
                '   Symbol grid(default 250), 
                '   Point and path Grid(default 50),
                '   Line grid(default 1)
                MyUniverse.SysGen.Snaps.MySnap = MyMinMax(My_INT(Pop(X0, FD)), 1, 10)
                MyUniverse.SysGen.Snaps.MyPointSnap = MyMinMax(My_INT(Pop(X0, FD)), 1, 250)
                MyUniverse.SysGen.Snaps.MySymbolSnap = MyMinMax(My_INT(Pop(X0, FD)), 1, 10000)
                    'MyUniverse.SysGen.Snaps.MaxSymbolInYSpacing=MyMinMax(My_INT(Pop(X0, FD)), MyUniverse.SysGen.Constants.ConstantSymbolCenter * 2, MyUniverse.SysGen.Constants.ConstantSymbolCenter * 10)
            Case "dump"
                X2 = Pop(X0, FD)
                X3 = Pop(X0, FD)
                X4 = Pop(X0, FD)
                logA(2626, X2, X3, X4)
                MyUniverse.MySystem.Dumps.OutputFileName1 = X2
                MyUniverse.MySystem.Dumps.OutputFileName2 = X3
                MyUniverse.MySystem.Dumps.OutputFileName3 = X4
                'todo kill all dump file when you start and also when you import another dump file (delete the old, and also the new)
                If Dir(MyUniverse.MySystem.Dumps.OutputFileName1) <> "" Then Kill(MyUniverse.MySystem.Dumps.OutputFileName1)
                If Dir(MyUniverse.MySystem.Dumps.OutputFileName2) <> "" Then Kill(MyUniverse.MySystem.Dumps.OutputFileName2)
            Case Else
                logA(1332, ImportLine, HighLight(X0) & HighLight(X1))
        End Select
    End Sub




    'Black, Errored, and Logic colors names must be here (At Least)

    Friend Sub ImportColors(ByRef SourceForm As Source, Key_Line As String)
        Dim Temp As String
        Dim Temp2 As Integer
        Dim IndexColor As Integer
        Dim InputLine As String

        InputLine = TrimEqual(Key_Line)
        '
        Temp = Pop(InputLine, MyUniverse.SysGen.Constants.ConstantDelimiters)
        If Temp = "=" Then ' this is added because of the change in delimiters 2020 08 13
            Temp = Pop(InputLine, MyUniverse.SysGen.Constants.ConstantDelimiters)
        End If
        Temp = MyTrim(NoFD(Temp)) ' re-moved any commas
        'should never return a -1
        If PrintAbleNull(Temp) = PrintAbleNull(Nothing) Then
            Return
        End If
        'showSorts("Color", MyReSort("Color",IndexColor)) '3/13/19 incase of a color being added to the end
        IndexColor = BinarySearch4Index(Options.ListBoxColors, "add", Temp) 'hack
        'showSorts("Color", MyReSort("Color",IndexColor)) '3/13/19 incase of a color being added to the end
        'IndexColor=binarysearchlist4index(Options.listbox ... ,("Color", "add",Temp) 'hack
        If IndexColor < 0 Then 'This is if the color is not found and can not be added.
            IndexColor = AddInTable(Options.ListBoxColors, Temp) 'hack
            If IndexColor = ConstantMyErrorCode Then
                IndexColor = NewTopOfFile(SourceForm, "Color")
            End If
        Else
            Temp2 = MyMinMax(IndexColor, 1, TopOfFile(SourceForm, "Color"))
            If Temp2 <> IndexColor Then
                logA(1335, Temp2.ToString, IndexColor.ToString)
            End If
        End If
        ' Not in the table, so search for the closest name to this and make that the default color's

        'Color_TableName(Index)=Pop(KeyLine)
        Color_TableAlpha(IndexColor, PopValue(InputLine)) ' Alpha
        Color_TableRed(IndexColor, PopValue(InputLine)) 'Red
        Color_TableGreen(IndexColor, PopValue(InputLine)) 'Green
        Color_TableBlue(IndexColor, PopValue(InputLine)) 'Blue
        '** This is wrong, because all of the options are not available for all of the CAP styles, need to fix this later
        Color_TableStyle(IndexColor, Pop(InputLine, MyUniverse.SysGen.Constants.ConstantDelimiters)) ' ConstantEnumStyle, InputLine)
        Color_TableStartCap(IndexColor, MyEnumValue(Pop(InputLine, MyUniverse.SysGen.Constants.ConstantDelimiters), Options.ListboxPathStart))
        Color_TableEndCap(IndexColor, MyEnumValue(Pop(InputLine, MyUniverse.SysGen.Constants.ConstantDelimiters), Options.ListboxPathEnd))
        TopOfFile(SourceForm, "color") ' This is to update the top of file, and/or make the array bigger
        Options.ListBoxColors.Items.Add(Color_TableName(IndexColor))
    End Sub

    Friend Function YesNo(I As Integer) As String
        If I = 0 Then Return "Yes"
        Return "No"
    End Function

    Friend Sub ImportSymbolPointPreference()
        MyUniverse.MySymbolPoints(0).x = -250 : MyUniverse.MySymbolPoints(0).y = -250
        MyUniverse.MySymbolPoints(1).x = 0 : MyUniverse.MySymbolPoints(1).y = -250
        MyUniverse.MySymbolPoints(2).x = 0 : MyUniverse.MySymbolPoints(2).y = 250
        MyUniverse.MySymbolPoints(3).x = 250 : MyUniverse.MySymbolPoints(3).y = 0
        MyUniverse.MySymbolPoints(4).x = -250 : MyUniverse.MySymbolPoints(4).y = 0
        MyUniverse.MySymbolPoints(5).x = -150 : MyUniverse.MySymbolPoints(5).y = -250
        MyUniverse.MySymbolPoints(6).x = 150 : MyUniverse.MySymbolPoints(6).y = -250
        MyUniverse.MySymbolPoints(7).x = 150 : MyUniverse.MySymbolPoints(7).y = 250
        MyUniverse.MySymbolPoints(8).x = -150 : MyUniverse.MySymbolPoints(8).y = 250
        MyUniverse.MySymbolPoints(9).x = -250 : MyUniverse.MySymbolPoints(9).y = -250
        MyUniverse.MySymbolPoints(10).x = 250 : MyUniverse.MySymbolPoints(10).y = -250
        MyUniverse.MySymbolPoints(11).x = 250 : MyUniverse.MySymbolPoints(11).y = 250
        MyUniverse.MySymbolPoints(12).x = -250 : MyUniverse.MySymbolPoints(12).y = 250
        MyUniverse.MySymbolPoints(13).x = -250 : MyUniverse.MySymbolPoints(13).y = -150
        MyUniverse.MySymbolPoints(14).x = 250 : MyUniverse.MySymbolPoints(14).y = -150
        MyUniverse.MySymbolPoints(15).x = 250 : MyUniverse.MySymbolPoints(15).y = 150
        MyUniverse.MySymbolPoints(16).x = -250 : MyUniverse.MySymbolPoints(16).y = 150
        MyUniverse.MySymbolPoints(17).x = -150 : MyUniverse.MySymbolPoints(17).y = -150
        MyUniverse.MySymbolPoints(18).x = 150 : MyUniverse.MySymbolPoints(18).y = -150
        MyUniverse.MySymbolPoints(19).x = 150 : MyUniverse.MySymbolPoints(19).y = 150
        MyUniverse.MySymbolPoints(20).x = -150 : MyUniverse.MySymbolPoints(20).y = 150
        MyUniverse.MySymbolPoints(21).x = -50 : MyUniverse.MySymbolPoints(21).y = -50
        MyUniverse.MySymbolPoints(22).x = 50 : MyUniverse.MySymbolPoints(22).y = -50
        MyUniverse.MySymbolPoints(23).x = 50 : MyUniverse.MySymbolPoints(23).y = 50
        MyUniverse.MySymbolPoints(24).x = -50 : MyUniverse.MySymbolPoints(24).y = 50
        MyUniverse.MySymbolPoints(25).x = -50 : MyUniverse.MySymbolPoints(25).y = 0
        MyUniverse.MySymbolPoints(26).x = 50 : MyUniverse.MySymbolPoints(26).y = 0
        MyUniverse.MySymbolPoints(27).x = 0 : MyUniverse.MySymbolPoints(27).y = -50
        MyUniverse.MySymbolPoints(28).x = 0 : MyUniverse.MySymbolPoints(28).y = 50
        MyUniverse.MySymbolPoints(29).x = -100 : MyUniverse.MySymbolPoints(29).y = 100
        MyUniverse.MySymbolPoints(30).x = 100 : MyUniverse.MySymbolPoints(30).y = 100
        MyUniverse.MySymbolPoints(31).x = 100 : MyUniverse.MySymbolPoints(31).y = -100
        MyUniverse.MySymbolPoints(32).x = -100 : MyUniverse.MySymbolPoints(32).y = -100
        MyUniverse.MySymbolPoints(33).x = -100 : MyUniverse.MySymbolPoints(33).y = 0
        MyUniverse.MySymbolPoints(34).x = 0 : MyUniverse.MySymbolPoints(34).y = 100
        MyUniverse.MySymbolPoints(35).x = 100 : MyUniverse.MySymbolPoints(35).y = 0
        MyUniverse.MySymbolPoints(36).x = 0 : MyUniverse.MySymbolPoints(36).y = -100
        MyUniverse.MySymbolPoints(37).x = -150 : MyUniverse.MySymbolPoints(37).y = -100
        MyUniverse.MySymbolPoints(38).x = 150 : MyUniverse.MySymbolPoints(38).y = 100
        MyUniverse.MySymbolPoints(39).x = 150 : MyUniverse.MySymbolPoints(39).y = -100
        MyUniverse.MySymbolPoints(40).x = -150 : MyUniverse.MySymbolPoints(40).y = 100
        MyUniverse.MySymbolPoints(41).x = -150 : MyUniverse.MySymbolPoints(41).y = 0
        MyUniverse.MySymbolPoints(42).x = 150 : MyUniverse.MySymbolPoints(42).y = 0
        MyUniverse.MySymbolPoints(43).x = 0 : MyUniverse.MySymbolPoints(43).y = -150
        MyUniverse.MySymbolPoints(44).x = 0 : MyUniverse.MySymbolPoints(44).y = 150
        MyUniverse.MySymbolPoints(45).x = -200 : MyUniverse.MySymbolPoints(45).y = 0
        MyUniverse.MySymbolPoints(46).x = 0 : MyUniverse.MySymbolPoints(46).y = -200
        MyUniverse.MySymbolPoints(47).x = 0 : MyUniverse.MySymbolPoints(47).y = 200
        MyUniverse.MySymbolPoints(48).x = 200 : MyUniverse.MySymbolPoints(48).y = 0
        MyUniverse.MySymbolPoints(49).x = -200 : MyUniverse.MySymbolPoints(49).y = -150
        MyUniverse.MySymbolPoints(50).x = -200 : MyUniverse.MySymbolPoints(50).y = -100
        MyUniverse.MySymbolPoints(51).x = -200 : MyUniverse.MySymbolPoints(51).y = 100
        MyUniverse.MySymbolPoints(52).x = -200 : MyUniverse.MySymbolPoints(52).y = 150
        MyUniverse.MySymbolPoints(53).x = 200 : MyUniverse.MySymbolPoints(53).y = 150
        MyUniverse.MySymbolPoints(54).x = 200 : MyUniverse.MySymbolPoints(54).y = 100
        MyUniverse.MySymbolPoints(55).x = 200 : MyUniverse.MySymbolPoints(55).y = -100
        MyUniverse.MySymbolPoints(56).x = 200 : MyUniverse.MySymbolPoints(56).y = -150
        MyUniverse.MySymbolPoints(57).x = -100 : MyUniverse.MySymbolPoints(57).y = -150
        MyUniverse.MySymbolPoints(58).x = -100 : MyUniverse.MySymbolPoints(58).y = 150
        MyUniverse.MySymbolPoints(59).x = 100 : MyUniverse.MySymbolPoints(59).y = 150
        MyUniverse.MySymbolPoints(60).x = 100 : MyUniverse.MySymbolPoints(60).y = -150
        MyUniverse.MySymbolPoints(61).x = -50 : MyUniverse.MySymbolPoints(61).y = -100
        MyUniverse.MySymbolPoints(62).x = -50 : MyUniverse.MySymbolPoints(62).y = 100
        MyUniverse.MySymbolPoints(63).x = 50 : MyUniverse.MySymbolPoints(63).y = 100
        MyUniverse.MySymbolPoints(64).x = 50 : MyUniverse.MySymbolPoints(64).y = -100
        MyUniverse.MySymbolPoints(65).x = -50 : MyUniverse.MySymbolPoints(65).y = -150
        MyUniverse.MySymbolPoints(66).x = 50 : MyUniverse.MySymbolPoints(66).y = -150
        MyUniverse.MySymbolPoints(67).x = 50 : MyUniverse.MySymbolPoints(67).y = 150
        MyUniverse.MySymbolPoints(68).x = -50 : MyUniverse.MySymbolPoints(68).y = 150
        MyUniverse.MySymbolPoints(69).x = -100 : MyUniverse.MySymbolPoints(69).y = 50
        MyUniverse.MySymbolPoints(70).x = -100 : MyUniverse.MySymbolPoints(70).y = -50
        MyUniverse.MySymbolPoints(71).x = 100 : MyUniverse.MySymbolPoints(71).y = -50
        MyUniverse.MySymbolPoints(72).x = 100 : MyUniverse.MySymbolPoints(72).y = 50
        MyUniverse.MySymbolPoints(73).x = -150 : MyUniverse.MySymbolPoints(73).y = -200
        MyUniverse.MySymbolPoints(74).x = 150 : MyUniverse.MySymbolPoints(74).y = -200
        MyUniverse.MySymbolPoints(75).x = 150 : MyUniverse.MySymbolPoints(75).y = -50
        MyUniverse.MySymbolPoints(76).x = 150 : MyUniverse.MySymbolPoints(76).y = 50
        MyUniverse.MySymbolPoints(77).x = -150 : MyUniverse.MySymbolPoints(77).y = 50
        MyUniverse.MySymbolPoints(78).x = -150 : MyUniverse.MySymbolPoints(78).y = -50
        MyUniverse.MySymbolPoints(79).x = -200 : MyUniverse.MySymbolPoints(79).y = -200
        MyUniverse.MySymbolPoints(80).x = -100 : MyUniverse.MySymbolPoints(80).y = -200
        MyUniverse.MySymbolPoints(81).x = -50 : MyUniverse.MySymbolPoints(81).y = -200
        MyUniverse.MySymbolPoints(82).x = 50 : MyUniverse.MySymbolPoints(82).y = -200
        MyUniverse.MySymbolPoints(83).x = 100 : MyUniverse.MySymbolPoints(83).y = -200
        MyUniverse.MySymbolPoints(84).x = 200 : MyUniverse.MySymbolPoints(84).y = -200
        MyUniverse.MySymbolPoints(85).x = 200 : MyUniverse.MySymbolPoints(85).y = -50
        MyUniverse.MySymbolPoints(86).x = 200 : MyUniverse.MySymbolPoints(86).y = 50
        MyUniverse.MySymbolPoints(87).x = 200 : MyUniverse.MySymbolPoints(87).y = 200
        MyUniverse.MySymbolPoints(88).x = 150 : MyUniverse.MySymbolPoints(88).y = 200
        MyUniverse.MySymbolPoints(89).x = 100 : MyUniverse.MySymbolPoints(89).y = 200
        MyUniverse.MySymbolPoints(90).x = 50 : MyUniverse.MySymbolPoints(90).y = 200
        MyUniverse.MySymbolPoints(91).x = -50 : MyUniverse.MySymbolPoints(91).y = 200
        MyUniverse.MySymbolPoints(92).x = -100 : MyUniverse.MySymbolPoints(92).y = 200
        MyUniverse.MySymbolPoints(93).x = -150 : MyUniverse.MySymbolPoints(93).y = 200
        MyUniverse.MySymbolPoints(94).x = -200 : MyUniverse.MySymbolPoints(94).y = 200
        MyUniverse.MySymbolPoints(95).x = -200 : MyUniverse.MySymbolPoints(95).y = 50
        MyUniverse.MySymbolPoints(96).x = -200 : MyUniverse.MySymbolPoints(96).y = -50
        MyUniverse.MySymbolPoints(97).x = -200 : MyUniverse.MySymbolPoints(97).y = -250
        MyUniverse.MySymbolPoints(98).x = -100 : MyUniverse.MySymbolPoints(98).y = -250
        MyUniverse.MySymbolPoints(99).x = -50 : MyUniverse.MySymbolPoints(99).y = -250
        MyUniverse.MySymbolPoints(100).x = 50 : MyUniverse.MySymbolPoints(100).y = -250
        MyUniverse.MySymbolPoints(101).x = 100 : MyUniverse.MySymbolPoints(101).y = -250
        MyUniverse.MySymbolPoints(102).x = 200 : MyUniverse.MySymbolPoints(102).y = -250
        MyUniverse.MySymbolPoints(103).x = 250 : MyUniverse.MySymbolPoints(103).y = -200
        MyUniverse.MySymbolPoints(104).x = 250 : MyUniverse.MySymbolPoints(104).y = -100
        MyUniverse.MySymbolPoints(105).x = 250 : MyUniverse.MySymbolPoints(105).y = -50
        MyUniverse.MySymbolPoints(106).x = 250 : MyUniverse.MySymbolPoints(106).y = 50
        MyUniverse.MySymbolPoints(107).x = 250 : MyUniverse.MySymbolPoints(107).y = 100
        MyUniverse.MySymbolPoints(108).x = 250 : MyUniverse.MySymbolPoints(108).y = 200
        MyUniverse.MySymbolPoints(109).x = 200 : MyUniverse.MySymbolPoints(109).y = 250
        MyUniverse.MySymbolPoints(110).x = 100 : MyUniverse.MySymbolPoints(110).y = 250
        MyUniverse.MySymbolPoints(111).x = 50 : MyUniverse.MySymbolPoints(111).y = 250
        MyUniverse.MySymbolPoints(112).x = -50 : MyUniverse.MySymbolPoints(112).y = 250
        MyUniverse.MySymbolPoints(113).x = -100 : MyUniverse.MySymbolPoints(113).y = 250
        MyUniverse.MySymbolPoints(114).x = -200 : MyUniverse.MySymbolPoints(114).y = 250
        MyUniverse.MySymbolPoints(115).x = -250 : MyUniverse.MySymbolPoints(115).y = 200
        MyUniverse.MySymbolPoints(116).x = -250 : MyUniverse.MySymbolPoints(116).y = 100
        MyUniverse.MySymbolPoints(117).x = -250 : MyUniverse.MySymbolPoints(117).y = 50
        MyUniverse.MySymbolPoints(118).x = -250 : MyUniverse.MySymbolPoints(118).y = -50
        MyUniverse.MySymbolPoints(119).x = -250 : MyUniverse.MySymbolPoints(119).y = -100
        MyUniverse.MySymbolPoints(120).x = -250 : MyUniverse.MySymbolPoints(120).y = -200
        MyUniverse.MySymbolPoints(121).x = 0 : MyUniverse.MySymbolPoints(121).y = 0


    End Sub


    Friend Function FillImportLine() As ImportLineStruct
        FillImportLine = Nothing
        FillImportLine.LastName = ""
        FillImportLine.IndexName = -1
        FillImportLine.IndexSymbol = -1
        FillImportLine.TopMost = -1

        FillImportLine.Inputs.AllText = "?20"
        FillImportLine.Inputs.KPar = "?21"
        FillImportLine.Inputs.KWord = "?22"
        FillImportLine.Inputs.LineNumberIn = 1

        FillImportLine.Temps.TempInteger1 = -1
        FillImportLine.Temps.TempString2 = "off"
        FillImportLine.Temps.TempFormat = "?23"
        FillImportLine.Temps.TempRecord = -1

        FillImportLine.MyRecord.Coded = 0
        FillImportLine.MyRecord.X1 = -1
        FillImportLine.MyRecord.Y1 = -1
        FillImportLine.MyRecord.X2.MyString = ""
        FillImportLine.MyRecord.Y2.MyString = ""
        FillImportLine.MyRecord.X2.MyNumber = 0
        FillImportLine.MyRecord.Y2.MyNumber = 0
        FillImportLine.MyRecord.NameOfPoint = "?24"

    End Function



    Friend Sub MyDeCompile(ByRef SourceForm As Source, InputFileName As String)  ' Converts from language into FlowChart
        Dim InputFileText As String
        Dim IndexFlowChart As Integer
        Dim Connection As String
        ' Bugs:
        ' It does not make /paths for all of the connections to a Symbol.
        ' It does not connect paths of the same name to each other.(UpdatedLinks to do this)
        ' It does not place Symbols in the 'best' place
        ' REDIM     Named_FileSyntax_ISAM(Options.ListBoxSymbols.items.count -1) ' and deleted afterwards

        MyUniverse.MySS = FillImportLine()

        'MyPlacement( SourceForm , False) 'sets the min's

        If Len(InputFileName) < 4 Then
            InputFileName = XOpenFile("decompile", "Open The Source Code File")
        Else
            logA(4092, InputFileName)
        End If
        If InputFileName = Nothing Then Return

        If Dir(InputFileName) = "" Then ' need to create the file if it does not exist then you can ... 
            logA(1843, InputFileName)
            Return
        End If

        ' Now open it for Output

        logA(1149, InputFileName)

        ' make Symbols for everything that has MicroCodeText and no Syntax
        CheckAndFixSyntax(SourceForm)

        Using reader As System.IO.TextReader = System.IO.File.OpenText(InputFileName)
            InputFileText = reader.ReadToEnd()
        End Using
        MyUniverse.MySS.Inputs.LineNumberIn += 1
        ''''' this is wrong      MyPlacement(SourceForm, PaintErase(SourceForm, MyUniverse.MySS.Inputs.LineNumberIn)) 'todo check this
        MyPlacement(SourceForm, True)
        MyUniverse.MySS.Inputs.AllText = InputFileText
        OLD.DisplayStatus(3205, MyUniverse.MySS.Inputs.LineNumberIn.ToString)
        'A I N F O 2 (166) 'hack
        MyUniverse.Paint = False
        PaintErase(SourceForm, MyUniverse.MySS.Inputs.LineNumberIn)
        MyDeCompileLine(SourceForm, MyUniverse.MySS.Inputs.AllText)
        MyUniverse.Paint = True
        For IndexFlowChart = TopOfListBox(SourceForm.ListBoxFlowChart) To 1 Step -1
            OLD.DisplayStatus(3206, IndexFlowChart.ToString)
            'passing a /use SymbolName as a pathname here.
            Connection = MyShowAndUpDateProperties(SourceForm, IndexFlowChart) ',MyUniverse.MySS.Inputs.LineNumberIn,Net_TablePathNames(binarysearchlist4index_In_TableNetLinks(IndexFlowChart)))
            PaintEachOne(SourceForm, IndexFlowChart)
        Next
        OLD.DisplayStatus(3207)
    End Sub





    Friend Function ImportLineOrFile(ByRef SourceForm As Source, TAll As String) As String
        Dim I1, J, K, Xy1, xY2 As Integer
        Dim TKey, TPar As String 'todo these should have been for debug only, but make sure that are 'really' used before deleting.
        Dim X1, X2, X3 As String

        If TAll = "" Then Return ""
        'I = MyInStr(vbCrLf, TAll & vbCrLf) - 1
        If MyDebug(A_DISPLAY) Then logA(2437, MyLeft(TAll, MyInStr(vbCrLf, TAll & vbCrLf) - 1))

        '
        'process all 
        'make sure that i include anything left over not done.

        'tall=InputLine_or_File
        TPar = ""

        While Len(TAll) > 0 Or Len(TPar) > 0
            MyUniverse.MySS.Inputs.LineNumberIn += 1
            'If MyUniverse.MySS.Inputs.LineNumberIn = CInt(MyUniverse.MySS.Inputs.LineNumberIn / FollowNumberOfLines) * FollowNumberOfLines Then
            ' oLD.DisplayStatus(1079, MyUniverse.MySS.Inputs.LineNumberIn.ToString) 'FlowChartWindow.LabelProgramStatus.Text, 
            'DoEvent(160, "Line  " & MyUniverse.MySS.Inputs.LineNumberIn.ToString)
            'End If
            TAll = MyTrim(TAll)
            TPar = PopLine(TAll)
            If MyInStr("=,", TPar) = 0 Then
                TPar = MyTrim(TPar)
            Else
                TPar = TrimOff(TPar, vbCrLf)
                TPar = TrimOff(TPar, vbLf)
                TPar = TrimOff(TPar, vbCr)
                TPar = TrimOff(TPar, vbTab)
            End If
            If MyDebug(A_DISPLAY) Then
                logA(1284, TPar)
            End If
            TAll = MyTrim(TAll)               ' Mid(TAll, 1 + Len(TPar), Len(TAll))
            'Temp1=TPar
            TKey = MyTrim(MyReplace(Pop(TPar, "="), "=", ""))
            'TAll=TAll
            If MyUniverse.MySS.Inputs.LineNumberIn <> 0 And Int(MyUniverse.MySS.Inputs.LineNumberIn / FollowNumberOfLines) * FollowNumberOfLines = MyUniverse.MySS.Inputs.LineNumberIn Then
                DisplayStatus(3232, MyUniverse.MySS.Inputs.LineNumberIn.ToString, TKey, TPar)
            End If
            If (MyInStr("::=", TKey) <> 0) And (MyLeft(TKey, 1) <> "/") Then
                If MyDebug(A_ERROR) Then logA(2727, TKey, Mid(TAll, 1, MyMinMax(Len(TAll), 32, 128)), Len(TAll).ToString, TKey, TPar)
            End If
            Select Case LCase(MyTrim(TKey))
                Case "/login"
                Case "/FCfinish", "", Nothing ' do nothing
                Case "/import"
                Case "/export"
                    Dump2(SourceForm)
                Case "/Grammar"
                    MyUniverse.Grammar = True 'This is to tell that a Grammar has been entered.
                    TPar = MyTrim(MyHex2Char(TPar))
                    If MyInStr("::=", TPar) <> 0 Then
                        AddSortedList(NoRM(MyUniverse.SysGen.Markers.Grammar), TPar, Language_Grammar)
                    Else
                        logA(2346, TPar)
                    End If
                Case "/debug"
                    MyUniverse.FCCLDebugLevel_1 = PopValue(TPar)
                    MyUniverse.FCCLDebugLevel_2 = PopValue(TPar)
                    If MyUniverse.FCCLDebugLevel_1 > 10 Or MyUniverse.FCCLDebugLevel_1 < 1 Then
                        logA(1224, MyUniverse.FCCLDebugLevel_1.ToString)
                        MyUniverse.FCCLDebugLevel_1 = DefaultDebugLevel1
                    End If
                    If MyUniverse.FCCLDebugLevel_2 > 10 Or MyUniverse.FCCLDebugLevel_2 < 1 Then
                        logA(1224, MyUniverse.FCCLDebugLevel_2.ToString)
                        MyUniverse.FCCLDebugLevel_2 = DefaultDebugLevel2
                    End If
                        'If MyUniverse.FCCLDebugLevel_2 < MyUniverse.FCCLDebugLevel_1 Then
                        ' MyUniverse.FCCLDebugLevel_2 = MyUniverse.FCCLDebugLevel_1
                       ' End If
                Case "/drilldown"

                    If MyInStr(":", TPar) = 0 Then
                        If MyRight(TPar, 1) = "/" Or MyRight(TPar, 1) = "\" Then
                            TPar = MyUniverse.MyDir_s.Working & TPar
                        Else
                            TPar = MyUniverse.MyDir_s.Working & "\" & TPar
                        End If
                    End If
                    MyDeCompile(SourceForm, TPar)
                    Dump2(SourceForm)

                Case "/dump"
                    'Dump1
                    Dump2(SourceForm)
                        'Dump3
                Case "/ConstantQuote"
                    MyUniverse.SysGen.Constants.ConstantQuote = TPar
                Case "/MarkerQuotes"
                    MyUniverse.SysGen.Markers.Quotes = AddRM(TPar)
                Case "/MarkerNumber"
                    MyUniverse.SysGen.Markers.Numbers = AddRM(TPar)
                Case "/MarkerAlpha"
                    MyUniverse.SysGen.Markers.Alphas = AddRM(TPar)
                Case "/MarkerSpecialCharacters"
                    MyUniverse.SysGen.Markers.SpecialCharacter = AddRM(TPar)
                Case "/MarkerComment"
                    MyUniverse.SysGen.Markers.Comments = AddRM(TPar)
                Case "/ConstantSymbolCenter"
                    MyUniverse.SysGen.Constants.ConstantSymbolCenter = PopValue(TPar)
                Case "/ConstantSpacingFactor"
                    MyUniverse.SysGen.Constants.ConstantSpacingFactor = PopValue(TPar)
                Case "/ConstantMinPenSize"
                    MyUniverse.SysGen.Constants.ConstantMinPenSize = PopValue(TPar)
                Case "/ConstantMaxPenSize"
                    MyUniverse.SysGen.Constants.ConstantMaxPenSize = PopValue(TPar)
                Case "/ConstantMinBoxSize"
                    MyUniverse.SysGen.Constants.ConstantMinBoxSize = PopValue(TPar)
                Case "/ConstantDistanceBetweenControls"
                    MyUniverse.SysGen.Constants.ConstantDistanceBetweenControls = PopValue(TPar)
                Case "/ConstantRecordsBeforeSaveIsAllowed"
                    MyUniverse.SysGen.Constants.ConstantRecordsBeforeSaveIsAllowed = PopValue(TPar)
                Case "/ConstantDistanceToMovePaths"
                    MyUniverse.SysGen.Constants.ConstantDistanceToMovePaths = PopValue(TPar)
                Case "/ConstantSpecialCharacters"
                    MyUniverse.SysGen.Constants.ConstantSpecialCharacters = TPar
                Case "/ConstantWhiteSpacesD"
                    MyUniverse.SysGen.Constants.ConstantWhiteSpaces = "" 'delete all of the previous white spaces 
                    TPar = TPar

                    While Len(TPar) > 0
                        I1 = PopValue(TPar)
                        If I1 > 0 Then
                            MyUniverse.SysGen.Constants.ConstantWhiteSpaces &= Chr(I1)
                        End If
                    End While

                Case "/ConstantWhiteSpacesH"
                    MyUniverse.SysGen.Constants.ConstantWhiteSpaces = "" 'delete all of the previous white spaces 
                    TPar = TPar
                    TPar = Fix0X(TPar)
                    MyUniverse.SysGen.Constants.ConstantWhiteSpaces = TPar
                Case "/ConstantDelimiter", "/ConstantDelimiters"
                    MyUniverse.SysGen.Constants.ConstantDelimiters = MyHex2Char(TPar)
                Case "/MarkerCameFromLine"
                    MyUniverse.SysGen.Markers.CameFromLine = AddRM(TPar)
                Case "/ConstantBranchToNextLine"
                    MyUniverse.SysGen.Markers.BranchToNextLine = AddRM(TPar)
                Case "/route" 'routes the flowchart paths 
                    J = PopValue(TPar)
                    K = PopValue(TPar)
                    If J = 0 And K = 0 Then
                        J = 1
                        K = SourceForm.ListBoxFlowChart.Items.Count - 1
                    End If

                    J = MyMinMax(J, 1, SourceForm.ListBoxFlowChart.Items.Count - 1)
                    K = MyMinMax(K, 1, SourceForm.ListBoxFlowChart.Items.Count - 1)
                    If K < J Then K = J
                    For I1 = J To K
                        MakePathOrthogonal(SourceForm, I1)
                    Next I1
                    OLD.Clear_Window(SourceForm.FlowChartPictureBox)
                    For I1 = 1 To SourceForm.ListBoxVariables.count - 1
                        If FlowChart_TableCode(SourceForm, I1) = "/path" Then
                            ROUTERNetIndex(SourceForm, I1)
                        End If
                    Next
                Case "/Message"
                    logA(2456, TPar) ' log it
                    MsgBox(TPar, MsgBoxStyle.Information, Translate("Notice"))
                Case "/ignore"
                    TPar = "" ' Ignore everything on this
                Case "/set"
                    SetOptions(TPar)
                Case "/option"
                    MyUniverse.MySS.Temps.TempFormat = FormatOption
                    If Do_Not_Use_IsThisANumber(SourceForm, TPar) Then
                        MyUniverse.MySS.Temps.TempInteger1 = PopValue(TPar)
                        'MyUniverse.MySS.Temps.TempInteger=PopValue(TPar)
                        'need to test if this is a valid number?
                        BitSet(MyMinMax(MyUniverse.MySS.Temps.TempInteger1, 1, 10000 - 1), TrueOrFalse(TPar))
                    End If
                Case "/FCCL_case"
                    If MyTrim(TPar) <> "" Then
                        Options.ListBoxSymbolData.Items.Item(20) = TrueOrFalse(TPar)
                    Else
                    End If
                Case "/FCCL_multiLine"
                    If MyTrim(TPar) <> "" Then
                        MyUniverse.ProgramOptions.FCCL_MultiLine = MyTrim(TPar)
                    End If
                    MyUniverse.ProgramOptions.FCCL_MultiLine = ReplaceWithActualControlCharacter(MyUniverse.ProgramOptions.FCCL_MultiLine)
                Case "/FCCL_comment"
                    If MyTrim(TPar) <> "" Then Options.ListBoxSymbolData.Items.Item(21) = MyTrim(TPar)
                Case "/FCCL_Extension", "/FCCL_Extensions"
                    Options.ListBoxSymbolData.Items.Item(25) = ""
                    While Len(TPar) > 0
                        TKey = Pop(TPar, FD)
                        If Len(TKey) > 0 Then
                            If MyLeft(TKey, 1) <> "." Then
                                Options.ListBoxSymbolData.Items.Item(25) = Options.ListBoxSymbolData.Items.Item(25).ToString & "." & TKey & FD
                            Else
                                Options.ListBoxSymbolData.Items.Item(25) = Options.ListBoxSymbolData.Items.Item(25).ToString & TKey & FD
                            End If
                        End If
                    End While


                Case "/FCCL_Root", "/FCCL_Roots"
                    'If Len(MyUniverse.ProgramOptions.FCCL_Roots) < 3 Then MyUniverse.ProgramOptions.FCCL_Roots &= ", "

                    While Len(TPar) > 0
                        TKey = Pop(TPar, FD)
                        If Len(Trim(TKey)) > 0 And Trim(TKey) <> FD Then
                            MyUniverse.ProgramOptions.FCCL_Roots &= ", " & TKey
                        End If
                    End While

                    MyUniverse.ProgramOptions.FCCL_Roots &= ", "
                    logA(1081, "Grammar roots set to " & MyUniverse.ProgramOptions.FCCL_Roots)
                Case "/FCCL_Default_Root", "/FCCL_Default_Roots"
                    'todo format is grammar name root ',' name of symbol to use when this grammar name is used (should include all sub grammar names aw well.
                    'todo need to also export the root (maybe only into dump2?)
                    X2 = TPar
                    X1 = Pop(X2, FD)
                    X2 = Pop(X2, FD)
                    If IsThisAGrammarRule(X1) <> "" Then 'is valid root?
                        If IsThisASymbolName(SourceForm, X2) Then 'Is valid defined symbol
                            'GROUPED BY : THEN BY ,
                            Options.ListBoxSymbolData.Items.Item(22) = Options.ListBoxSymbolData.Items.Item(22).ToString & ":," & X1 & "," & X2
                            'log_X(3546, X1, X2) 'root and symbol
                        Else
                            logA(3547, "ERROR : Symbol name not found >" & X1 & vbTab & "  -  " & vbTab & X2 & "<.") ' root but symbol not defined
                        End If
                    Else
                        If FindGrammarRule(SourceForm, X1) > 0 Then 'check if a grammar rule
                            'log_X(3551, X1, X2)
                            If IsThisASymbolName(SourceForm, X2) Then ' check if grammar rule has a valid symbol 
                                MyUniverse.ProgramOptions.FCCL_NotRoots &= ":," & X1 & "," & X2 & ","
                                'log_X(3549, "WARNING Should be saving this grammar rule name (but not a Grammar Root Name) " & X1 & vbTab & vbTab & X2)
                            Else
                                logA(3550, "ERROR : Symbol name not found for grammar rule >" & X1 & vbTab & "  -  " & vbTab & X2 & "<.")
                            End If
                        Else ' not a valid grammar root so symbol does not matter
                            logA(3548, X1, X2)
                        End If
                    End If
                Case "/FCCL_varchars"
                    If MyTrim(TPar) <> "" Then MyUniverse.ProgramOptions.FCCL_VarChars = MyTrim(TPar)
                Case "/FCCL_DialectName"
                    If MyTrim(TPar) <> "" Then Options.ListBoxSymbolData.Items.Item(23) = MyTrim(TPar)
                Case "/FCCL_ErrorMessage"
                    '''''ReplaceErrorMessage(TPar)
                Case "/FCCL_Dimension"
                    If MyInStr("variable", TPar) <> 0 And MyInStr("datatype", TPar) <> 0 Then
                        MyUniverse.ProgramOptions.FCCL_Dimension = TPar
                    Else
                        logA(3336, TPar)
                    End If
                Case "/MarkerBranchToNextLine"
                    If MyTrim(TPar) <> "" Then MyUniverse.SysGen.Markers.BranchToNextLine = MyTrim(TPar)
                Case "/color"
                    MyUniverse.MySS.Temps.TempFormat = formatColor
                    ImportColors(SourceForm, TPar)
                Case "/DataType"
                    MyUniverse.MySS.Temps.TempFormat = formatDataType
                    ImportDataTypes(SourceForm, TPar)
                Case "/name"
                    MyUniverse.MySS.Temps.TempFormat = formatSymbolName
                    '''''ShowSorts("Named", MyReSort("Named", TopOfFile(SourceForm,  "named")))
                    '''''ShowSorts("Named", MyReSort("Named", 'TopOfFile(SourceForm,  "named")))
                    MyUniverse.MySS.LastName = Pop(TPar, MyUniverse.SysGen.Constants.ConstantDelimiters)
                    ' 
                    ' is returning the wrong should be 1 and returns 0
                    MyUniverse.MySS.IndexName = AddInTable(Options.ListBoxSymbols, MyUniverse.MySS.LastName)
                    '
                    If MyUniverse.MySS.IndexName = ConstantMyErrorCode Then
                        logA(1376, TAll, MyUniverse.MySS.LastName)
                        MyUniverse.MySS.IndexName = AddNewNamedRecord(SourceForm, MyUniverse.MySS.LastName, "?1", "?2", "?3", "?4", "?5", "?6", "?7", "?8")
                        MyUniverse.MySS.IndexName = TopOfFile(SourceForm, "named")
                        MyUniverse.MySS.IndexName = BinarySearch4Index(Options.ListBoxSymbols, "Don Add Find Again after Sort", MyUniverse.MySS.LastName)
                    End If
                    If MyUniverse.MySS.IndexName = ConstantMyErrorCode Then
                        logA(1140, TAll) ' We should find it after adding it
                    Else
                        ' Get the Direct Array Indexes
                        If Named_TableSymbolName(MyUniverse.MySS.IndexName) <> MyUniverse.MySS.LastName Then
                            logA(1377, TAll) ' we should always have the name after we have just found it'
                        End If
                        'Named_TableSymbolName(MyUniverse.MySS.index name, MyUniverse.MySS.last name) ' why are we replacing it when we just found it?
                        '
                        If PrintAbleNull(TPar) = PrintAbleNull(Nothing) Then ' This is testing for all options that should be in this Symbol
                            TPar = "?" & MyUniverse.MySS.LastName
                        End If
                        MyUniverse.MySS.IndexSymbol = FindInSymbolList(SourceForm, MyUniverse.MySS.LastName)
                        If MyUniverse.MySS.IndexSymbol = ConstantMyErrorCode Then
                            AddNEWSymbolPointRecord(Source, MyUniverse.MySS.LastName, "/name", 0, 0, MyUniverse.ProgramOptions.SelectedInputOutput, MyUniverse.ProgramOptions.SelectedDataType, TPar)
                            MyUniverse.MySS.IndexSymbol = TopOfFile(SourceForm, "Symbol")
                        End If
                        If MyUniverse.MySS.IndexSymbol > ConstantMyErrorCode Then ' replace any information that is already there (If added, then is always something there
                            'Debug, check if this is updating the table after finding it above
                            Symbol_FileCoded(MyUniverse.MySS.IndexSymbol) = MyKeyword2Number("/name") ' KeyConstName '"/name"
                            'Symbol_TableSymbolName(MyUniverse.MySS.indexSymbol, MyUniverse.MySS.lastName)' Did not need to do it again!!!!!
                            Symbol_Table_NameOfPoint(MyUniverse.MySS.IndexSymbol, TPar)
                            Symbol_TableX1(MyUniverse.MySS.IndexSymbol, 1)
                            Symbol_TableY1(MyUniverse.MySS.IndexSymbol, 1)
                            Symbol_Table_X2(MyUniverse.MySS.IndexSymbol, 1)
                            Symbol_Table_Y2(MyUniverse.MySS.IndexSymbol, 1)
                            Symbol_TableX1(MyUniverse.MySS.IndexSymbol, 1)
                        Else
                            logA(1120, MyUniverse.MySS.IndexSymbol.ToString, TopOfFile(SourceForm, "Symbol").ToString, TKey, TAll, MyUniverse.MySS.Inputs.LineNumberIn.ToString)
                        End If
                    End If
                Case "/point"
                    MyUniverse.MySS.Temps.TempFormat = formatPoint
                    TPar = XTrim(TPar)
                    MyUniverse.MySS.MyRecord.a.x = PopValue(TPar)
                    TPar = XTrim(TPar)
                    MyUniverse.MySS.MyRecord.a.y = PopValue(TPar)
                    MyUniverse.MySS.MyRecord.a = MyPointSnap(MyUniverse.MySS.MyRecord.a)
                    TPar = XTrim(TPar)
                    MyUniverse.MySS.MyRecord.X2.MyString = Pop(TPar, MyUniverse.SysGen.Constants.ConstantDelimiters)
                    TPar = XTrim(TPar)
                    MyUniverse.MySS.MyRecord.Y2.MyString = Trim(Pop(TPar, MyUniverse.SysGen.Constants.ConstantDelimiters))
                    TPar = XTrim(TPar)
                    MyUniverse.MySS.MyRecord.NameOfPoint = TPar
                    TPar = XTrim(TPar)

                    ' This will insert them backwards, but who cares? (It should not make a difference because each record should be independant.
                    AddNEWSymbolPointRecord(Source, MyUniverse.MySS.LastName, "/point", MyUniverse.MySS.MyRecord.X1, MyUniverse.MySS.MyRecord.Y1, MyUniverse.MySS.MyRecord.X2.MyString, MyUniverse.MySS.MyRecord.Y2.MyString, MyUniverse.MySS.MyRecord.NameOfPoint)

                    Symbol_Table_NameOfPoint(TopOfFile(SourceForm, "Symbol"), TPar) ' For A point
                    '''''ShowSorts("DataType", MyReSort("DataType", TopOfFile(SourceForm,  "Symbol"))) '3/12/19 only sort added 
                Case "/Line"
                    LogDebug(3478, Err7, TPar)
                    MyUniverse.MySS.Temps.TempFormat = formatLine
                    TPar = ChangeFormat(formatLine, TKey, TPar)
                    MyUniverse.MySS.TopMost = NewTopOfFile(SourceForm, "Symbol")
                    Symbol_FileSymbolName(MyUniverse.MySS.TopMost) = MyUniverse.MySS.LastName ' "L_" & MyUniverse.MySS.TopMost
                    Symbol_TableCode(SourceForm, MyUniverse.MySS.TopMost, MyKeyword2Number(TKey))
                    Symbol_TableX1(MyUniverse.MySS.TopMost, MyMinMax(MyLineSnap(PopValue(TPar)), -MyUniverse.SysGen.Constants.ConstantSymbolCenter, MyUniverse.SysGen.Constants.ConstantSymbolCenter))
                    If Len(TPar) = 0 Then LogDebug(1047, Err7, "/line input error ")
                    Symbol_TableY1(MyUniverse.MySS.TopMost, MyMinMax(MyLineSnap(PopValue(TPar)), -MyUniverse.SysGen.Constants.ConstantSymbolCenter, MyUniverse.SysGen.Constants.ConstantSymbolCenter))
                    If Len(TPar) = 0 Then LogDebug(1048, Err7, "/line input error ")
                    Symbol_Table_X2(MyUniverse.MySS.TopMost, MyMinMax(MyLineSnap(PopValue(TPar)), -MyUniverse.SysGen.Constants.ConstantSymbolCenter, MyUniverse.SysGen.Constants.ConstantSymbolCenter))
                    If Len(TPar) = 0 Then LogDebug(1049, Err7, "/line input error ")
                    Symbol_Table_Y2(MyUniverse.MySS.TopMost, MyMinMax(MyLineSnap(PopValue(TPar)), -MyUniverse.SysGen.Constants.ConstantSymbolCenter, MyUniverse.SysGen.Constants.ConstantSymbolCenter))
                    If Len(TPar) = 0 Then LogDebug(1050, Err7, "/line input error ")
                    Symbol_Table_NameOfPoint(MyUniverse.MySS.TopMost, Pop(TPar, MyUniverse.SysGen.Constants.ConstantDelimiters)) ' Color
                    If Len(TPar) <> 0 Then LogDebug(1051, Err7, "/line input error ")
                    LogDebug(3479, Err7, MyShowSymbolGraphic(False, MyUniverse.MySS.TopMost))
                    'optional symbol name 
                    If TPar = "" Then
                        Symbol_TableSymbolName(MyUniverse.MySS.TopMost, MyUniverse.MySS.LastName)
                    Else 'This has a problem with the /line input syntax (maybe?)
                        logA(1000, MyUniverse.MySS.Inputs.LineNumberIn.ToString & ", " & MyUniverse.MySS.TopMost.ToString & "/Line Input error " & MyShowSymbolGraphic(False, MyUniverse.MySS.TopMost) & CT & vbTab & TPar)
                        Symbol_TableSymbolName(MyUniverse.MySS.TopMost, Pop(TPar, MyUniverse.SysGen.Constants.ConstantDelimiters)) ' Optional, but should never be a named Line, Only Paths
                        LogDebug(3480, Err7, MyShowSymbolGraphic(False, MyUniverse.MySS.TopMost))
                        LogDebug(3481, Err7, FindColorIndexFromName(Symbol_TableSymbolName(MyUniverse.MySS.TopMost)).ToString)
                    End If
                    '
                Case "/Lines" ' color, x1,y1, x2,y2, ... 
                    MyUniverse.MySS.Temps.TempFormat = formatLines
                    MyUniverse.MySS.TopMost = NewTopOfFile(SourceForm, "Symbol")
                    X3 = Pop(TPar, MyUniverse.SysGen.Constants.ConstantDelimiters) ' Color
                    Xy1 = LineLimit(PopValue(TPar))
                    xY2 = LineLimit(PopValue(TPar))
                    While Len(TPar) > 0
                        Symbol_FileSymbolName(MyUniverse.MySS.TopMost) = MyUniverse.MySS.LastName
                        Symbol_TableCode(SourceForm, MyUniverse.MySS.TopMost, MyKeyword2Number("/line"))
                        Symbol_TableX1(MyUniverse.MySS.TopMost, Xy1)
                        Symbol_TableY1(MyUniverse.MySS.TopMost, xY2)
                        Symbol_Table_X2(MyUniverse.MySS.TopMost, MyMinMax(MyLineSnap(PopValue(TPar)), -MyUniverse.SysGen.Constants.ConstantSymbolCenter, MyUniverse.SysGen.Constants.ConstantSymbolCenter))
                        Symbol_Table_Y2(MyUniverse.MySS.TopMost, MyMinMax(MyLineSnap(PopValue(TPar)), -MyUniverse.SysGen.Constants.ConstantSymbolCenter, MyUniverse.SysGen.Constants.ConstantSymbolCenter))
                        Symbol_Table_NameOfPoint(MyUniverse.MySS.TopMost, X3) ' Color
                        Xy1 = Symbol_Table_X2(MyUniverse.MySS.TopMost)
                        xY2 = Symbol_Table_Y2(MyUniverse.MySS.TopMost)
                        logA(1086, MyUniverse.MySS.TopMost.ToString, MyShowSymbolGraphic(False, MyUniverse.MySS.TopMost))
                        MyUniverse.MySS.TopMost = NewTopOfFile(SourceForm, "Symbol")
                    End While
                    If TPar = "" Then
                        Symbol_TableSymbolName(MyUniverse.MySS.TopMost, "Line" & TopOfFile(SourceForm, "Symbol"))
                    Else
                        Symbol_TableSymbolName(MyUniverse.MySS.TopMost, Pop(TPar, MyUniverse.SysGen.Constants.ConstantDelimiters)) ' Optional, but should never be a named Line, Only Paths
                    End If
                    '
                Case "/path"
                    MyUniverse.MySS.Temps.TempFormat = formatPath
                    MyUniverse.MySS.Temps.TempRecord = NewFlowChartRecord(SourceForm)
                    FlowChart_TableCode(SourceForm, MyUniverse.MySS.Temps.TempRecord, "/path") 'KeyConstPath)
                    FlowChart_tablePathSymbolName(SourceForm, MyUniverse.MySS.Temps.TempRecord, Pop(TPar, MyUniverse.SysGen.Constants.ConstantDelimiters)) 'name last
                    MyPathTextValues2Line(SourceForm, MyUniverse.MySS.Temps.TempRecord, TAll)


                    FlowChart_TableDataType(SourceForm, MyUniverse.MySS.Temps.TempRecord, Trim(Pop(TPar, MyUniverse.SysGen.Constants.ConstantDelimiters))) ' DataType
                    '''''ShowSorts("FlowChart", ReSortFlowChart(MyUniverse.MySS.Temps.TempRecord))
                    '20200709        PaintEachOne( SourceForm.flowchartpicturebox ,  myy.temps.tempRecord, myy.temps.tempRecord)
                    '
                    PaintEachOne(SourceForm, MyUniverse.MySS.Temps.TempRecord)
                Case "/Use"
                    MyUniverse.MySS.Temps.TempFormat = formatUse 'hack
                    MyUniverse.MySS.Temps.TempRecord = NewFlowChartRecord(SourceForm)
                    FlowChart_TableCode(SourceForm, MyUniverse.MySS.Temps.TempRecord, My_keyWord(My_KeyConstUse))
                    FlowChart_tablePathSymbolName(SourceForm, MyUniverse.MySS.Temps.TempRecord, Pop(TPar, MyUniverse.SysGen.Constants.ConstantDelimiters)) 'Name First
                    MyUseTextValues2Line(SourceForm, MyUniverse.MySS.Temps.TempRecord, TPar)
                    FlowChart_Table_Rotation(SourceForm, MyUniverse.MySS.Temps.TempRecord, Pop(TPar, MyUniverse.SysGen.Constants.ConstantDelimiters))
                    FlowChart_TableDataType(SourceForm, MyUniverse.MySS.Temps.TempRecord, Pop(TPar, MyUniverse.SysGen.Constants.ConstantDelimiters)) ' later for dynamic Symbols
                    '''''ShowSorts("FlowChart", ReSortFlowChart(MyUniverse.MySS.Temps.TempRecord))
                    PaintEachOne(SourceForm, MyUniverse.MySS.Temps.TempRecord)

                Case "/MicroCodeText"
                    MyUniverse.MySS.Temps.TempFormat = FormatMacroText
                    If MyUniverse.MySS.IndexName > 0 Then
                        Named_TableMicroCodeText(MyUniverse.MySS.IndexName, Named_TableMicroCodeText(MyUniverse.MySS.IndexName) & CT & TPar & MyUniverse.ProgramOptions.FCCL_MultiLine)
                    Else
                        logA(1403, MyUniverse.MySS.IndexName.ToString, TKey, TPar, MyUniverse.MySS.Inputs.LineNumberIn.ToString, MyUniverse.MySS.LastName, "/MicroCodeText")
                    End If
                Case "/syntax"
                    MyUniverse.MySS.Temps.TempFormat = FormatSyntax
                    If MyUniverse.MySS.IndexName > 0 Then
                        Named_TableSyntax(MyUniverse.MySS.IndexName, Named_TableSyntax(MyUniverse.MySS.IndexName) & vbCr & TPar)
                    Else
                        logA(1403, MyUniverse.MySS.IndexName.ToString, TKey, TPar, MyUniverse.MySS.Inputs.LineNumberIn.ToString, MyUniverse.MySS.LastName, "/syntax")
                    End If
                Case "/filename"
                    MyUniverse.MySS.Temps.TempFormat = formatNameOfFile
                    If MyUniverse.MySS.IndexName > 0 Then
                        Named_TableNameOfFile(MyUniverse.MySS.IndexName, TPar)
                    Else
                        logA(1403, MyUniverse.MySS.IndexName.ToString, TKey, TPar, MyUniverse.MySS.Inputs.LineNumberIn.ToString, MyUniverse.MySS.LastName, "/filename")
                    End If
            ' Need to change the options if it is already there 
                Case "/language"
                    MyUniverse.MySS.Temps.TempFormat = formatLanguage
                    DoEvent(39, "/Language")
                    'todo make sure that there are valid language and dialects
                    MyUniverse.ProgramOptions.FCCL_LanguageClassName = NoFD(Pop(TPar, FD & COMMA))
                    Options.ListBoxSymbolData.Items.Item(23) = NoFD(Pop(MyTrim(TPar), FD & COMMA))
                    logA(1476, MyUniverse.ProgramOptions.FCCL_LanguageClassName, Options.ListBoxSymbolData.Items.Item(23).ToString)
                    MyButtonsEnableRules(116)
                Case "/stroke"
                    MyUniverse.MySS.Temps.TempFormat = formatStroke
                    If MyUniverse.MySS.IndexName > 0 Then
                        Named_TableStroke(MyUniverse.MySS.IndexName, TPar)
                    Else
                        logA(1403, MyUniverse.MySS.IndexName.ToString, TKey, TPar, MyUniverse.MySS.Inputs.LineNumberIn.ToString, MyUniverse.MySS.LastName, "/stroke")
                    End If
                Case "/notes"
                    MyUniverse.MySS.Temps.TempFormat = formatNotes
                    If MyUniverse.MySS.IndexName > 0 Then
                        Named_TableNotes(MyUniverse.MySS.IndexName, Named_TableNotes(MyUniverse.MySS.IndexName) & vbCr & PopLine(TPar))
                    Else
                        logA(1407, TKey, TPar, MyUniverse.MySS.Inputs.LineNumberIn.ToString, MyUniverse.MySS.LastName)
                    End If
                Case "/version"
                    MyUniverse.MySS.Temps.TempFormat = formatVersion
                    If MyUniverse.MySS.IndexName > 0 Then
                        Named_TableVersion(MyUniverse.MySS.IndexName, TPar)
                    Else
                        logA(1408, TKey, TPar, MyUniverse.MySS.Inputs.LineNumberIn.ToString, MyUniverse.MySS.LastName)
                    End If
                Case "/author"
                    MyUniverse.MySS.Temps.TempFormat = formatAuthor
                    If MyUniverse.MySS.IndexName > 0 Then
                        Named_TableAuthor(MyUniverse.MySS.IndexName, TPar)
                    Else
                        logA(1409, TKey, TPar, MyUniverse.MySS.Inputs.LineNumberIn.ToString, MyUniverse.MySS.LastName)
                    End If
                Case "/opcode"
                    MyUniverse.MySS.Temps.TempFormat = formatOpcode
                    If MyUniverse.MySS.IndexName > 0 Then
                        If Len(Named_TableOpCode(MyUniverse.MySS.IndexName)) > 0 Then
                            Named_TableOpCode(MyUniverse.MySS.IndexName, Named_TableOpCode(MyUniverse.MySS.IndexName) & MyUniverse.ProgramOptions.FCCL_WhiteSpace & MyUniverse.ProgramOptions.FCCL_MultiLine & MyUniverse.ProgramOptions.FCCL_WhiteSpace & TPar)
                        Else
                            Named_TableOpCode(MyUniverse.MySS.IndexName, TPar)
                        End If
                    Else
                        logA(1410, TKey, TPar, MyUniverse.MySS.Inputs.LineNumberIn.ToString, MyUniverse.MySS.LastName)
                    End If
                Case "/Constant"
                    MyUniverse.MySS.Temps.TempFormat = formatConstant
                    MyUniverse.MySS.Temps.TempRecord = TopOfListBox(SourceForm.ListBoxFlowChart)
                    FlowChart_TableCode(SourceForm, MyUniverse.MySS.Temps.TempRecord, TKey)
                    MyUseTextValues2Line(SourceForm, MyUniverse.MySS.Temps.TempRecord, TPar)
                    FlowChart_TableDataType(SourceForm, MyUniverse.MySS.Temps.TempRecord, Pop(TPar, MyUniverse.SysGen.Constants.ConstantDelimiters))
                    FlowChart_tablePathSymbolName(SourceForm, MyUniverse.MySS.Temps.TempRecord, TPar)
                Case "/error"
                    MyUniverse.MySS.Temps.TempFormat = FormatError
        'ignore error imports
                Case "/delete"
                    MyUniverse.MySS.Temps.TempFormat = FormatDelete
        ' ignore deleted stuff also
                Case "/keyword"
                    AddSortedList(NoRM(MyUniverse.SysGen.Markers.KeyWords), TPar, Options.ListBox_KeyWords)
                Case "/KeywordS"

                    While Len(TPar) > 0
                        AddSortedList(NoRM(MyUniverse.SysGen.Markers.KeyWords), Trim(Pop(TPar, ", ")), Options.ListBox_KeyWords)
                        TPar = Trim(TPar)
                    End While
                Case "/block"
                    If Len(Language_Blocks(MySizeOf(Language_Blocks))) > 1 Then ReDim Preserve Language_Blocks(MySizeOf(Language_Blocks) + 1)
                    Language_Blocks(MySizeOf(Language_Blocks)) = MyTrim(TPar)
                Case "/blockS"

                    While Len(TPar) > 0
                        If Len(Language_Blocks(MySizeOf(Language_Blocks))) > 1 Then ReDim Preserve Language_Blocks(MySizeOf(Language_Blocks) + 1)
                        Language_Blocks(MySizeOf(Language_Blocks)) = MyTrim(Pop(TPar, ","))
                    End While

                Case "/exit"
                    logA(1148, TAll)
                    Application.Exit()
                Case "/translate"
                    I1 = MySizeOf(English2)
                    ReDim Preserve English2(I1 + 1)
                    ReDim Preserve English2Word(I1 + 1)
                    English2(I1 + 1) = Pop(TPar, ",")
                    English2Word(I1 + 1) = Pop(TPar, ",")
                Case Else
                    TKey = TKey
                    If MyLeft(TKey, 1) <> "/" Then
                        If Len(TKey) > 0 Then
                            TPar = TPar '                                TPar=TKey & "=" & TPar
                        ElseIf Do_Not_Use_IsThisABlock(TKey) = True Then
                            TPar = TKey
                        Else
                            TPar = Mid(TKey, 1, MyInStr(VBSpace, TKey & VBSpace))
                        End If

                        MyDeCompileLine(SourceForm, TKey)

                        'todo this needs to remove all of the myMsgBox stuff below the exit select
                        Exit Select
                    Else
                        logA(1067, TKey, TPar) ', TAll)
                        FindGrammarFromCode(SourceForm, TKey, 1)
                        Exit Select
                    End If
                    'todo should never get to 1211
                    Select Case MsgBox(MyUniverse.MySS.Inputs.LineNumberIn.ToString & CT & TKey & CT & TPar,, "ERROR")
                        Case vbNo

                        Case vbOK, vbYes
                            '
                            FlowChart_TableCode(SourceForm, TopOfListBox(SourceForm.ListBoxFlowChart), "/error")
                            FlowChart_TableDataType(SourceForm, TopOfListBox(SourceForm.ListBoxFlowChart), TAll)
                        Case vbCancel
                            Init()
                            Return ""

                        Case Else
                            logA(1381, TKey)
                    End Select
            End Select
        End While

        Return "" 'nothing
    End Function 'End Of import Line Or file


    Friend Function LineLimit(XY As Integer) As Integer
        Return MyMinMax(MyLineSnap(XY), -MyUniverse.SysGen.Constants.ConstantSymbolCenter, MyUniverse.SysGen.Constants.ConstantSymbolCenter)
    End Function
    Friend Function AreTheseQuoted(MyString As String, I1 As Integer, I2 As Integer, I3 As Integer) As Boolean
        Dim Debug1 As String
        Debug1 = Space(Len(MyString))
        mid(Debug1, I1, 1) = "<"
        mid(Debug1, I2, 1) = "^"
        mid(Debug1, I3, 1) = ">"
        'Debug . Print ( vbTab & I1.ToString & vbTab & I2.ToString & vbTab & I3.ToString &  ct  &  vbTab & MyString &  ct  &  vbTab & Debug1 &  ct  &  vbTab & "--->" & Mid(MyString, I1 - 1, I3 - I1 - 1) & "<---")
        If I1 <= 1 Then Return False                        'can not be quoted if it is the fir character
        If Len(MyString) <= I3 Then Return False            'cannot be quoted if it is the very last
        If Mid(MyString, I1 - 1, 1) = "'" Then Return True
        If Mid(MyString, I1 + 1, 1) = "'" Then Return True
        If Mid(MyString, I3 - 1, 1) = "'" Then Return True
        If Mid(MyString, I3 + 1, 1) = "'" Then Return True
        Return False
    End Function



    Friend Function FixBracketQuote(InputString As String) As String ' This is to change the EBNF to not have <> be quote marks
        'replace all < ... space ... > to < ... _ ... >
        Dim I1, I2, I3, I4 As Integer
        I1 = 0

        While 1 = 1
            I1 = MyInStr("<", InputString, I1 + 1)
            If I1 = 0 Then

                Return InputString
            End If
            I2 = MyInStr(VBSpace, InputString, I1)
            If I2 = 0 Then

                Return InputString
            End If
            I3 = MyInStr(">", InputString, I1)
            If I3 = 0 Then

                Return InputString
            End If


            'todo need to make sure there are no literals between then <>

            If AreTheseQuoted(InputString, I1, I2, I3) = True Then Return InputString
            While I2 > I1 And I2 < I3  ' just get rid of the <> in this rule name
                'todo this needs to make sure that only valid characters are in the rule name
                '<>  with nothing inBetween should return input
                ' a literal ' inside
                ' only spaces, letters, underscore.  
                I4 = MyInStr("'", InputString, I1)
                If I4 > I1 And I4 < I3 Then

                    Return InputString
                End If
                Mid(InputString, I2, 1) = "_"
                I2 = MyInStr(VBSpace, InputString, I1)
            End While

            Mid(InputString, I1, 1) = VBSpace
            Mid(InputString, I3, 1) = VBSpace
        End While

        Return InputString
    End Function



    Friend Sub FixGrammarMakeNewRule(ByRef SourceForm As Source, GrammarRuleNumber As Integer, StartBlock As String, EndBlock As String, CTLBlock As String)
        Dim RuleGrammar, NewGrammarRuleName, ReplaceGrammar, ModifiedGrammar, OriginalGrammarRule As String
        Dim D, E, F As Integer
        Dim debug1 As String

        RuleGrammar = VBSpace & Language_Grammar(GrammarRuleNumber) & VBSpace
        debug1 = RuleGrammar
        D = MyInStr(StartBlock, RuleGrammar)
        If D = 0 Then

            Return
        End If
        E = MyInStr(EndBlock, RuleGrammar)
        If E = 0 Then

            Return
        End If
        F = MyInStr(StartBlock, RuleGrammar, D + 1)
        If F > 0 And F < E Then
            debug1 = COMMA & Mid(debug1, D, 8) & COMMA & Mid(debug1, E, 8) & COMMA & Mid(debug1, F, 8)
            logA(1886, RuleGrammar, D.ToString, E.ToString, F.ToString, debug1)
            '''''ShowAllWindows(HideWindow, HideWindow, HideWindow, ShowWindow)

            Dump2(SourceForm)
            logA(1148, RuleGrammar & CT & debug1)
            Application.Exit()
            Return
        End If
        If E < D Then

            Return
        End If
        E += Len(EndBlock)
        ReplaceGrammar = Mid(RuleGrammar, D, E - D)


        While E - D - Len(StartBlock) - Len(EndBlock) < 1
            E += 1
        End While
        OriginalGrammarRule = Mid(RuleGrammar, D + Len(StartBlock), E - D - Len(StartBlock) - Len(EndBlock))
        'need to see if this rule is already defined
        F = FindGrammarRule(SourceForm, OriginalGrammarRule)
        If F < 1 Then
            ModifiedGrammar = RuleGrammar 'Language_Grammar(F)
            NewGrammarRuleName = Trim(Mid(ModifiedGrammar, 1, MyInStr("::=", ModifiedGrammar) - 1)) & MyRnd(3)
            ModifiedGrammar = MyReplace(RuleGrammar, ReplaceGrammar, VBSpace & NewGrammarRuleName & CTLBlock & VBSpace)
            'todo does this change the orginal grammer rule index/pointer?
            AddSortedList(NoRM(MyUniverse.SysGen.Markers.Grammar), NewGrammarRuleName & " ::= " & OriginalGrammarRule, Language_Grammar)
        Else
            NewGrammarRuleName = Trim(Mid(Language_Grammar(F), 1, MyInStr("::=", Language_Grammar(F)) - 1)) & MyRnd(3)
            'todo check this, is it an already existing grammar rule 
            ModifiedGrammar = MyReplace(RuleGrammar, ReplaceGrammar, VBSpace & NewGrammarRuleName & CTLBlock & VBSpace)
        End If
        ModifiedGrammar.Replace("  ", VBSpace) 'todo get rid of double spaces (hope that none are inside a string
        logA(1889, RuleGrammar, ModifiedGrammar, NewGrammarRuleName, OriginalGrammarRule)
        Language_Grammar(GrammarRuleNumber) = Trim(ModifiedGrammar)
        Dump2(SourceForm)

    End Sub




    Friend Sub FixGrammarFromEBNF2sBNF(ByRef SourceForm As Source)
        Const NumberOfChanges As Integer = 8
        Dim Flag As Boolean = True
        Dim I, J, MySorted As Integer
        Dim STemp, Temp As String
        Dim Start(NumberOfChanges), Ending(NumberOfChanges), ToThis(NumberOfChanges) As String
        Dim When2(NumberOfChanges) As Boolean 'either false replace or true make into new rule
        'change blocks (with white space before and after):
        '<>  to (delete)
        'repetition {} or (: :) to new rule with *
        'grouping   () to new rule with 
        'optional   [] or (/ /) to new rule with ?
        'string     "" to ''
        'comment    (* *) to end of the line with a ; inside spaces 
        'concatenate, to a space 
        'line end   ;
        'line end   .
        'or         / or ! to |
        ' in other words put a space before and after the line then replace from to
        ' replace all space between < ... > with underlines
        MySorted = 0
        I = 0 : Start(I) = " { " : Ending(I) = " } " : ToThis(I) = "+ " : When2(I) = True
        I = 1 : Start(I) = " ( " : Ending(I) = " ) " : ToThis(I) = "* " : When2(I) = True
        I = 2 : Start(I) = VBSpace & Chr(34) & VBSpace : Ending(I) = "" : ToThis(I) = "'" : When2(I) = False
        I = 3 : Start(I) = " [ " : Ending(I) = " ] " : ToThis(I) = "? " : When2(I) = True
        I = 4 : Start(I) = " (/ " : Ending(I) = " /) " : ToThis(I) = "* " : When2(I) = True
        I = 5 : Start(I) = " (* " : Ending(I) = " *) " : ToThis(I) = "- " : When2(I) = True
        I = 6 : Start(I) = " , " : Ending(I) = VBSpace : ToThis(I) = VBSpace : When2(I) = False
        I = 7 : Start(I) = " / " : Ending(I) = "" : ToThis(I) = " | " : When2(I) = False
        I = 8 : Start(I) = " ! " : Ending(I) = "" : ToThis(I) = " | " : When2(I) = False



        While Flag = True
            Flag = False

            For I = 1 To TopOfFile(SourceForm, "grammar")
                DoEvent(99, "Fix Grammar Rule # " & I.ToString)
                If MyDebug(A_INFORMATION) Then logA(2153, I.ToString, Language_Grammar(I))
                Language_Grammar(I) = FixBracketQuote(Language_Grammar(I)) ' fix < ... space ... > to ... _ ... 
                STemp = Language_Grammar(I)
                'Temp = Language_Grammar(I)


            Next I

        End While
    End Sub


    'This is to add keywords from the Grammar's
    Friend Sub CheckAllGrammar(ByRef SourceForm As Source)
        Dim I As Integer
        'If DoNotFindMyBugs() Then Return
        'MyUniverse.ProgramOptions.FCCL_Roots = ""
        If MyOptionTest(61) = False Then
            'log_X(3091)
            Exit Sub
        End If
        DoEvent(30, "Check All Grammar")

        If MyUniverse.Grammar = True Then Return
        For I = 1 To MySizeOf(Language_Grammar)
            'todo this should be display status
            DoEvent(1597, "Checking Grammar " & I.ToString & vbTab & vbTab & Language_Grammar(I))
            If Int(I / 5) * 5 = I Then
                OLD.DisplayStatus(3235, I.ToString)
            End If
            CheckGrammar2(SourceForm, Language_Grammar(I)) 'make sure every thing is knowable as a part of speech
            CheckGrammar3(SourceForm, Language_Grammar(I)) 'make sure you are not using any of the 'forbidden things line () {} [] ... 
            'DoEvent(1598, "Checking Grammar")
            If Do_Not_Use_IsThisARootGrammarRule(SourceForm, I) Then
                MyUniverse.ProgramOptions.FCCL_Roots &= MyGrammarName(Language_Grammar(I)) & ", "
            End If
        Next


        For I = 1 To TopOfFile(SourceForm, "keyword")
            CheckGrammar1(SourceForm, Options.ListBox_KeyWords.Items(I).ToString)
        Next


        'oLD.DisplayStatus(1002, "Checking Grammar Done " & I.ToString)
        OLD.DisplayStatus("Checking Grammar Done " & I.ToString)
        DoEvent(38, "All Grammar ✅")
    End Sub

    Friend Function RemoveBNFComment(A As String) As String
        If MyInStr("::=", A) = 0 Then Return A          'This is not a grammar statement
        If MyInStr(";", A) = 0 Then Return A            'This has no comment
        If MyInStr("';'", A) <> 0 Then Return A         'The comment might be be a character in the computer language
        'todo need to make sure that this is not a ';' literial
        Return Mid(A, 1, MyInStr(";", A) - 1) ' remove comment at the end of the string
    End Function



    'This is to make sure that all keywords appear in literals in the grammar

    Friend Function CheckGrammar1(ByRef SourceForm As Source, FindMyKeyword As String) As Boolean
        Dim I As Integer

        For I = 1 To TopOfFile(SourceForm, "grammar")
            If MyInStr("'" & FindMyKeyword & "'", Language_Grammar(I)) <> 0 Then Return True
        Next

        'This keyword is not in the grammar(s)
        logA(1076, FindMyKeyword)
        Return False
    End Function


    'Check grammar rules must have a ::=
    'Check each group
    Friend Sub CheckGrammar2(ByRef SourceForm As Source, GrammarString As String)
        Dim GrammarRule, ParsedWord As String
        Dim ParsedWordConditional As String
        Dim ThingsThisCouldBe, IsWhat, WhatIs As String
        GrammarRule = RemoveBNFComment(GrammarString)
        If GrammarRule = "" Then Return
        If MyInStr("::=", GrammarRule) <> 0 Then
            GrammarRule = MyTrim(Mid(GrammarRule, MyInStr("::=", GrammarRule) + 3))
            'DOC Checking that every /grammar line has defined atoms

            While Len(MyTrim(GrammarRule)) > 0
                'GrammarRule = NoComment
                ParsedWord = PopGrammar(GrammarRule)
                ParsedWordConditional = MyRight(ParsedWord, 1)
                If Len(ParsedWord) > 1 And (ParsedWordConditional = "-" Or
                            ParsedWordConditional = "+" Or
                            ParsedWordConditional = "*" Or
                            ParsedWordConditional = "?") Then ' keep it else its not a conditional so ignore it
                    ParsedWord = MyLeft(ParsedWord, Len(ParsedWord) - 1)
                    'Else
                    'ParsedWordConditional = ""
                End If

                ThingsThisCouldBe = Possible2MostLikely(SourceForm, ParsedWord, True, GrammarString)
                WhatIs = WhatCouldThisBe(SourceForm, ParsedWord)
                IsWhat = WhatIsThis(ParsedWord)

                'log_X( 1000,ParsedWord & "    " & Mid(ThingsThisCouldBe, 2, 7) & "     " & ThingsThisCouldBe)
                If Mid(ThingsThisCouldBe, 2, 7) = "Unicode" And ThingsThisCouldBe = MyUniverse.SysGen.Markers.UnicodeClass Then
                    logA(1250, "Unicode " & ParsedWord & "  " & ThingsThisCouldBe & "  " & WhatIs & "  " & IsWhat)
                ElseIf ThingsThisCouldBe <> IsWhat Then
                    logA(1040,
                                  MyStrComp(ThingsThisCouldBe, IsWhat).ToString,
                                  (ThingsThisCouldBe = IsWhat).ToString,
                                  ParsedWord,
                                  ThingsThisCouldBe,
                                  IsWhat,
                                  WhatIs,
                                  GrammarString)
                    WhatIs = WhatCouldThisBe(SourceForm, ParsedWord) 'todo remove
                    IsWhat = WhatIsThis(ParsedWord) 'todo remove 
                End If
            End While

        Else 'Does not have a ::=
            If GrammarRule = "" Then
                OLD.DisplayStatus(3236) 'nothing left to test
            Else
                If GrammarString = MyConstantIgnoreFunctionOperatorKeyWord & "Grammar ::= ' '" Then
                Else
                    logA(2357, GrammarString)
                End If
            End If
        End If
    End Sub


    Friend Sub CheckGrammar3(ByRef SourceForm As Source, GrammarString As String)
        Dim S, V, W As String
        S = RemoveBNFComment(GrammarString)
        'S=GrammarString
        If S = "" Then Return
        If MyInStr("::=", S) <> 0 Then
            S = MyTrim(Mid(S, MyInStr("::=", S) + 3))

            'DOC Checking that every /grammar line has defined atoms

            While Len(MyTrim(S)) > 0
                V = S
                W = PopGrammar(V)
                If W = "(" Then logA(1842, W, GrammarString)
                If W = ")" Then logA(1842, W, GrammarString)
                If W = "[" Then logA(1842, W, GrammarString)
                If W = "]" Then logA(1842, W, GrammarString)
                If W = "{" Then logA(1842, W, GrammarString)
                If W = "}" Then logA(1842, W, GrammarString)
                If W = " ... " Then logA(1842, W, GrammarString)
                If W = ";" Then Return ' ignore the rest of the line 
                ' log_X (1631, WhatCouldThisBe(SourceForm ,W) & vbTab & vbTab & W)
                S = MyTrim(MyReplace(S, W, ""))
            End While

        Else
            If S = "" Then
                OLD.DisplayStatus(3236)
            Else
                If GrammarString = MyConstantIgnoreFunctionOperatorKeyWord & "Grammar ::= ' '" Then
                Else
                    logA(2357, GrammarString)
                End If
            End If
        End If
    End Sub

    'check if this rule is a root or not
    Friend Function Do_Not_Use_IsThisARootGrammarRule(ByRef SourceForm As Source, GrammarRuleNumber As Integer) As Boolean 'returns if this is not called 
        Dim I, J, K, L As Integer
        Dim grn1, grn2, grn3 As String
        Dim Flag As Boolean
        Flag = True
        grn1 = VBSpace & MyGrammarName(Language_Grammar(GrammarRuleNumber)) & VBSpace

        For I = 1 To TopOfFile(SourceForm, "grammar")
            grn2 = MyGrammarName(Language_Grammar(I))
            grn3 = Language_Grammar(I)
            J = MyInStr(grn1, grn2)
            K = MyInStr("::=", grn2)
            L = MyInStr(MyGrammarName(Language_Grammar(GrammarRuleNumber)), Language_Grammar(I))
            If J = 0 And K = 0 And L = 1 Then
                'Debug . Print ( "This is its self " & J.ToString & vbTab & K.ToString & vbTab & L.ToString & vbTab & grn1 & vbTab & grn2 & vbTab & Language_Grammar(I))
            ElseIf J = 0 And K = 0 And L = 0 Then
                'Debug . print ( "?") 'no relationships
            ElseIf J = 1 And K = 0 Then
                logA(3552, "This is its self " & J.ToString & vbTab & K.ToString & vbTab & L.ToString & vbTab & grn1 & vbTab & grn2 & vbTab & Language_Grammar(I))
            ElseIf grn1 = grn2 Then
                'this is itself
                logA(3553, "This is its self " & J.ToString & vbTab & K.ToString & vbTab & L.ToString & vbTab & grn1 & vbTab & grn2 & vbTab & Language_Grammar(I))
            ElseIf MyInStr(grn1, grn2) < MyInStr("::=", grn2) Then
                'not a root
                logA(3554, "This is a root where to start searching " & J.ToString & vbTab & K.ToString & vbTab & L.ToString & vbTab & grn1 & vbTab & grn2 & vbTab & Language_Grammar(I))
            Else 'this root is used somewhere
                'Debug . Print ( "This is a used here " & J.ToString & vbTab & K.ToString & vbTab & L.ToString & vbTab & grn1 & vbTab & grn2 & vbTab & Language_Grammar(I))
                Flag = False ' because it is used somewhere else so it is not a root (terminal or rule)
                Return Flag
            End If
        Next

        Return Flag
    End Function




    'Routine This reads in an file with all of the information for a FlowChart & Symbol.
    Friend Sub Import(ByRef SourceForm As Source, InputFileName As String)
        Dim MyCompleteFileText As String
        If MyDebug(A_INFORMATION) = True Then logA(2842, InputFileName)
        MyUniverse.SysGen.DoNotAskToAdd = True
        ' Start off with junk
        MyUniverse.MySS = FillImportLine()
        '''''ShowAllWindows(LeaveWindow, LeaveWindow, LeaveWindow, ShowWindow)
        If Dir(InputFileName) = "" Then
            logA(1382, InputFileName)
            Return
        End If
        Using reader As System.IO.TextReader = System.IO.File.OpenText(InputFileName)
            MyCompleteFileText = "" ' Used to get through the first time only

            Do
                If Len(MyCompleteFileText) < 100 Then
                    MyCompleteFileText &= reader.ReadToEnd() ' add to this text if less than 100 characters long
                End If
                '
                'oLD.DisplayStatus(3238, MyUniverse.MySS.Inputs.LineNumberIn.ToString, Len(InputFileName).ToString, Len(MyCompleteFileText).ToString, MyUniverse.MySS.Inputs.KPar)
                DoEvent(44, "Import")
                MyCompleteFileText = ImportLineOrFile(SourceForm, MyCompleteFileText)
            Loop While Len(MyCompleteFileText) > 0

        End Using
        Dump2(SourceForm) 'todo need to remove this (Keep this only for expert level )
        DoEvent(45, "Import")
        MyUniverse.SysGen.DoNotAskToAdd = False
        PaintEachOne(SourceForm, TopOfListBox(SourceForm.ListBoxFlowChart)) '20200709
        OLD.DisplayStatus(3239, MyUniverse.MySS.Inputs.LineNumberIn.ToString)
        If MyDebug(A_DISPLAY) Then logA(2474, InputFileName)
        MyUniverse.Grammar = False
        FixGrammarFromEBNF2sBNF(SourceForm)
        CheckAllGrammar(SourceForm)
        Dump2(SourceForm)
        If Len(MyUniverse.ProgramOptions.FCCL_Roots) < 5 Then
            GetNewRoots(SourceForm)
        End If
        OLD.DisplayStatus(1250, "Import complete")
    End Sub

    Friend Sub GetNewRoots(ByRef SourceForm As Source)
        Dim I As Integer
        If Len(MyUniverse.ProgramOptions.FCCL_Roots) < 3 Then
            MyUniverse.ProgramOptions.FCCL_Roots = ", "
        Else
            Return 'already defined
        End If

        For I = 1 To MySizeOf(Language_Grammar)
            DoEvent(3214, "A) GetRoot:" & I.ToString)
            If Len(Language_Grammar(I)) > 4 Then
                OLD.DisplayStatus(2917, "Working on Roots : " & I.ToString & ", " & Int((I / MySizeOf(Language_Grammar) * 100)).ToString & "% " & MyUniverse.ProgramOptions.FCCL_Roots)
                If Do_Not_Use_IsThisARootGrammarRule(SourceForm, I) Then
                    If MyInStr(MyGrammarName(Language_Grammar(I)) & ", ", MyUniverse.ProgramOptions.FCCL_Roots & ",") < 1 Then
                        MyUniverse.ProgramOptions.FCCL_Roots &= MyGrammarName(Language_Grammar(I)) & ", "
                        logA(3555, MyUniverse.ProgramOptions.FCCL_Roots)
                        DoEvent(3214, "B) GetRoot:" & I.ToString)
                    Else
                        'Debug . Print ( "Root : " & MyGrammarName(Language_Grammar(I)) & ", " &  ct  &  "Already in " & MyUniverse.ProgramOptions.FCCL_Roots)
                        DoEvent(3214, "C) GetRoot:" & I.ToString)
                    End If
                Else
                End If
            End If
        Next I

        logA(3557, MyUniverse.ProgramOptions.FCCL_Roots)
        DoEvent(3214, "D) GetRoot:" & I.ToString)
    End Sub

    Friend Function PopGrammar(ByRef CodeLine As String) As String
        Dim I As Integer
        CodeLine = MyTrim(CodeLine)
        If MyLeft(CodeLine, 3) = "'''" Or CodeLine = "'" Then
            If MyDebug(A_DISPLAY) Then logA(2393, CodeLine)
            CodeLine = Mid(CodeLine, 3)
            Return "'" 'special case 'todo 
        End If
        ' get the first one.
        'if this is a '?' literial then return it
        If Do_Not_Use_IsThisALiteral(CodeLine) Then 'return this string 
            I = MyInStr("'", CodeLine, 2)
            If I = 0 Then I = 1
            PopGrammar = Mid(CodeLine, 1, I)
            CodeLine = Mid(CodeLine, I + 1, Len(CodeLine))
            Select Case MyLeft(CodeLine, 1)
                Case "?", "+", "-", "*"
                    PopGrammar &= MyLeft(CodeLine, 1)
                    CodeLine = Mid(CodeLine, 2, Len(CodeLine))
            End Select
            Return PopGrammar
        End If
        'if this is a Grammar name then return it.
        PopGrammar = Pop(CodeLine, MyUniverse.SysGen.Constants.ConstantWhiteSpaces)
        If Len(PopGrammar) = 1 Then Return PopGrammar
        'If includeOptions = True Then
        'Select Case MyRight(PopGrammar, 1)
        'Case "-", "+", "?", "*"
        'need to find Grammar???
        ''''''Return MyLeft(PopGrammar, Len(PopGrammar) - 1)
        '        Case Else
        'ignore everything else
        'End Select
        'End If
        Return PopGrammar
    End Function

    Friend Function MyFlowChartPathLine(ByRef SourceForm As Source, IndexFlowChart As Integer) As MyLineStructure
        MyFlowChartPathLine = Nothing
        MyFlowChartPathLine.a.Named.PathName = FlowChart_TablePathName(SourceForm, IndexFlowChart)
        MyFlowChartPathLine.b.Named.PathName = FlowChart_TablePathName(SourceForm, IndexFlowChart)
        MyFlowChartPathLine.a.x = FlowChart_TableX1(SourceForm, IndexFlowChart)
        MyFlowChartPathLine.a.y = FlowChart_TableY1(SourceForm, IndexFlowChart)
        MyFlowChartPathLine.b.x = FlowChart_TableX2(SourceForm, IndexFlowChart)
        MyFlowChartPathLine.b.y = FlowChart_TableY2(SourceForm, IndexFlowChart)
        MyFlowChartPathLine.a.Named.IsWorldWindow = WorldOrWindow(MyFlowChartPathLine.a)
        MyFlowChartPathLine.b.Named.IsWorldWindow = WorldOrWindow(MyFlowChartPathLine.b)
    End Function

    ' A line (distance) between two record points
    '     friend Function MyLineFlowChart(IndexFlowChart1   As Integer, IndexFlowChart2   As Integer) As MyLineStructure
    '    MyLine2=Nothing
    '    MyLine2.a.x=FlowChart_TableX1(SourceForm ,IndexFlowChart1  )
    '    MyLine2.a.y=FlowChart_TableY1(SourceForm    , SourceForm    , IndexFlowChart1  )
    '    MyLine2.b.x=FlowChart_TableX1(SourceForm ,IndexFlowChart2  )
    '    MyLine2.b.y=FlowChart_TableY1(SourceForm    , SourceForm    , IndexFlowChart2  )
    '    End Function


    ' A Line (distance) between two record points
    Friend Function MyLine1(ByRef SourceForm As Source, aXY As MyPointStructure, bXY As MyPointStructure) As MyLineStructure
        MyLine1 = Nothing
        MyLine1.a.x = aXY.x
        MyLine1.a.y = aXY.y
        MyLine1.b.x = bXY.x
        MyLine1.b.y = bXY.y
        MyLine1.a.Named = aXY.Named
        MyLine1.b.Named = bXY.Named
        Return MyLine1
    End Function

    Friend Function MyLine1(ByRef SourceForm As Source, X1 As Integer, Y1 As Integer, X2 As Integer, Y2 As Integer) As MyLineStructure
        MyLine1 = Nothing
        MyLine1.a.x = X1
        MyLine1.a.y = Y1
        MyLine1.b.x = X2
        MyLine1.b.y = Y2
        MyLine1.a.Named.PointName = "NoName"
        MyLine1.b.Named.PointName = "NoName"
    End Function


    ' a Line in one record
    Friend Function MyLine1(ByRef SourceForm As Source, IndexFlowChart As Integer) As MyLineStructure
        MyLine1 = Nothing
        MyLine1.a.x = FlowChart_TableX1(SourceForm, IndexFlowChart)
        MyLine1.a.y = FlowChart_TableY1(SourceForm, IndexFlowChart)
        MyLine1.a.Named.SymbolName = FlowChart_TableSymbol_Name(SourceForm, IndexFlowChart)
        MyLine1.a.Named.PathName = FlowChart_TablePathName(SourceForm, IndexFlowChart)
        MyLine1.a.Named.PointName = ""
        MyLine1.a.Named.IsWorldWindow = "World"

        MyLine1.b.x = FlowChart_TableX2(SourceForm, IndexFlowChart)
        MyLine1.b.y = FlowChart_TableY2(SourceForm, IndexFlowChart)
        MyLine1.b.Named.SymbolName = FlowChart_TableSymbol_Name(SourceForm, IndexFlowChart)
        MyLine1.b.Named.PathName = FlowChart_TablePathName(SourceForm, IndexFlowChart)
        MyLine1.b.Named.PointName = ""
        MyLine1.b.Named.IsWorldWindow = "World"
    End Function
    Friend Function MyLine2(ByRef SourceForm As Source, IndexFlowChart As Integer) As MyLineStructure
        MyLine2 = Nothing
        MyLine2.a.x = FlowChart_TableX1(SourceForm, IndexFlowChart)
        MyLine2.a.y = FlowChart_TableY1(SourceForm, IndexFlowChart)
        MyLine2.b.x = FlowChart_TableX2(SourceForm, IndexFlowChart)
        MyLine2.b.y = FlowChart_TableY2(SourceForm, IndexFlowChart)
    End Function
    Friend Function MyLineS(ByRef SourceForm As Source, IndexFlowChart1 As Integer, IndexFlowChart2 As Integer, WhichOne As Integer) As MyLineStructure
        MyLineS = Nothing
        Select Case WhichOne
            Case 1
                MyLineS.a.x = FlowChart_TableX1(SourceForm, IndexFlowChart1) : MyLineS.a.y = FlowChart_TableY1(SourceForm, IndexFlowChart1)
                MyLineS.b.x = FlowChart_TableX1(SourceForm, IndexFlowChart2) : MyLineS.b.y = FlowChart_TableY1(SourceForm, IndexFlowChart2)
            Case 2
                MyLineS.a.x = FlowChart_TableX1(SourceForm, IndexFlowChart1) + 10 : MyLineS.a.y = FlowChart_TableY1(SourceForm, IndexFlowChart1) + 10
                MyLineS.b.x = FlowChart_TableX1(SourceForm, IndexFlowChart2) + 10 : MyLineS.b.y = FlowChart_TableY1(SourceForm, IndexFlowChart2) + 10
            Case 3
                MyLineS.a.x = FlowChart_TableX1(SourceForm, IndexFlowChart1) + 20 : MyLineS.a.y = FlowChart_TableY1(SourceForm, IndexFlowChart1) - 20
                MyLineS.b.x = FlowChart_TableX1(SourceForm, IndexFlowChart2) + 20 : MyLineS.b.y = FlowChart_TableY1(SourceForm, IndexFlowChart2) - 20
            Case 4
                MyLineS.a.x = FlowChart_TableX1(SourceForm, IndexFlowChart1) - 20 : MyLineS.a.y = FlowChart_TableY1(SourceForm, IndexFlowChart1) + 20
                MyLineS.b.x = FlowChart_TableX1(SourceForm, IndexFlowChart2) - 20 : MyLineS.b.y = FlowChart_TableY1(SourceForm, IndexFlowChart2) + 20
            Case Else 'might as well find the closest
                MyLineS.a.x = FlowChart_TableX1(SourceForm, IndexFlowChart1) : MyLineS.a.y = FlowChart_TableY1(SourceForm, IndexFlowChart1) - 80
                MyLineS.b.x = FlowChart_TableX1(SourceForm, IndexFlowChart2) : MyLineS.b.y = FlowChart_TableY1(SourceForm, IndexFlowChart2) - 80
        End Select
    End Function


    'Routine converts from two numbers (x, y) to structure xy
    Friend Function MyPoint1XY(X As Integer, Y As Integer) As MyPointStructure
        MyPoint1XY = Nothing
        MyPoint1XY.x = X
        MyPoint1XY.y = Y
        MyPoint1XY.Named.PointName = "NoName"
    End Function

    Friend Function MyPoint1XY(ByRef SourceForm As Source, IndexFlowChart As Integer) As MyPointStructure
        Dim XYZ As MyLineStructure
        'todo is this necessary '''XYZ=Nothing
        XYZ = MySnapIndex(SourceForm, IndexFlowChart) ', FlowChart_TableX1(SourceForm ,IndexFlowChart))
        'MyPoint1XY.y=MySnap(IndexFlowChart, FlowChart_TableY1(SourceForm    , SourceForm    , IndexFlowChart))
        Return XYZ.a
    End Function

    Friend Function MyPoint1_1XY(ByRef SourceForm As Source, IndexFlowChart As Integer) As MyPointStructure
        Dim XYZ As MyLineStructure
        XYZ = MySnapIndex(SourceForm, IndexFlowChart)
        Return XYZ.a
    End Function

    Friend Function MyPoint2XY(X As Integer, Y As Integer) As MyPointStructure
        Dim XYZ As MyLineStructure
        XYZ = MySnapXYXY(Source, "/path", X, Y, X, Y)
        Return XYZ.a
    End Function

    Friend Function MyPoint2_1XY(ByRef SourceForm As Source, IndexFlowChart As Integer) As MyPointStructure
        Dim XYZ As MyLineStructure
        XYZ = MySnapIndex(SourceForm, IndexFlowChart)
        Return XYZ.a
    End Function

    Friend Function MyPoint2_2XY(ByRef SourceForm As Source, IndexFlowChart As Integer) As MyPointStructure
        Dim XYZ As MyLineStructure
        XYZ = MySnapIndex(SourceForm, IndexFlowChart)
        Return XYZ.a
        'MyPoint2_2XY=Nothing
        'MyPoint2_2XY.x=MySnap(IndexFlowChart, FlowChart_TableX2(SourceForm, IndexFlowChart))
        'MyPoint2_2XY.y=MySnap(IndexFlowChart, FlowChart_TableY2(SourceForm, IndexFlowChart))
    End Function

    Friend Function FixStringOutput2Hex(StrX As String) As String
        Dim I As Integer
        FixStringOutput2Hex = StrX

        For I = 1 To Len(FixStringOutput2Hex) - 1
            If AscW(FixStringOutput2Hex.Substring(I, 1)) > 124 Or AscW(FixStringOutput2Hex.Substring(I, 1)) < 32 Then
                FixStringOutput2Hex = FixStringOutput2Hex.Replace(FixStringOutput2Hex.Substring(I, 1), "'" & Bin2Hex(AscW(FixStringOutput2Hex.Substring(I, 1))) & "'")
            End If
        Next

    End Function

    Friend Function UnFixHexGrammar(GrammarLine As String) As String
        ' replace all special characters with hex value
        Dim RTN As String
        Dim I As Integer
        RTN = GrammarLine
        'characters to 'unfix'
        'CR LF TAB 
        RTN = FixStringOutput2Hex(RTN)

        For I = 1 To 31
            RTN = RTN.Replace(ChrW(I), "'" & Bin2Hex(I) & "'")
        Next

        Return RTN
    End Function


    'Routine 
    Friend Function MyFixLine(AString As String) As String
        Dim Index As Integer
        MyFixLine = AString

        For Index = 1 To Len(MyFixLine) - 1
            If Mid(MyFixLine, Index, 1) = FD Or Mid(MyFixLine, Index, 1) = FD Then
                If Mid(MyFixLine, Index + 1, 1) = FD Or Mid(MyFixLine, Index + 1, 1) = FD Then
                    MyFixLine = MyLeft(MyFixLine, Index) & MyUniverse.ProgramOptions.FCCL_WhiteSpace & Mid(MyFixLine, Index + 1, Len(MyFixLine))
                End If
            End If

            If Mid(MyFixLine, Index, 1) = FD Or Mid(MyFixLine, Index, 1) = FD Then
                If Mid(MyFixLine, Index + 1, 1) = vbCr Then
                    MyFixLine = MyLeft(MyFixLine, Index) & MyUniverse.ProgramOptions.FCCL_WhiteSpace & Mid(MyFixLine, Index + 1, Len(MyFixLine))
                End If
            End If

            If Mid(MyFixLine, Index, 1) = FD Or Mid(MyFixLine, Index, 1) = FD Then
                If Mid(MyFixLine, Index + 1, 1) = vbLf Then
                    MyFixLine = MyLeft(MyFixLine, Index) & MyUniverse.ProgramOptions.FCCL_WhiteSpace & Mid(MyFixLine, Index + 1, Len(MyFixLine))
                End If
            End If

            If Mid(MyFixLine, Index, 1) = FD Or Mid(MyFixLine, Index, 1) = FD Then
                If Mid(MyFixLine, Index + 1, 1) = "/" Then
                    MyFixLine = MyLeft(MyFixLine, Index) & MyUniverse.ProgramOptions.FCCL_WhiteSpace & Mid(MyFixLine, Index + 1, Len(MyFixLine))
                End If
            End If
        Next

    End Function




    'This is used to fill/refill the list of currently available lib Symbols 
    Friend Sub FillAllDropdowns(ByRef SourceForm As Source)
        Dim Index As Integer
        Dim IndexDropDown As Integer
        Dim IndexColor As Integer
        Dim ColorName As String
        If Len(MyUniverse.ProgramOptions.SelectedColor) = 0 Then
            ColorName = "Errored" ' only to avoid a warning message.
        Else
            ColorName = MyUniverse.ProgramOptions.SelectedColor
        End If
        '''''Options.ListBox14 .items.Clear()
        '''''FlowChartWindow.ToolStripDropDownSelectSymbol.items.Clear()

        '  Adding all Symbol names to the Symbol select list(S).(only button that should be on two Windows)

        For Index = 1 To TopOfFile(SourceForm, "named")
            If MyIsNothing(Named_TableSymbolName(Index)) Then
            Else
                AddSymbolToDropDown(Named_TableSymbolName(Index))
            End If
        Next
        '''''SelectInToolStripDropDownButton(Options.ListBox14 , MyUniverse.ProgramOptions.SelectedSymbolName)
        '''''SelectInToolStripDropDownButton(SELECTEDSYMBOL, MyUniverse.ProgramOptions.SelectedSymbolName)

        ' need to make the DataType selected from something
        Options.ListBoxDataTypes.Items.Clear()

        For Index = 1 To TopOfFile(SourceForm, "DataType")
            If MyIsNothing(DataType_TableName(Index)) Then
                logA(1396, Index.ToString)
            Else
                Options.ListBoxDataTypes.Items.Add(DataType_TableName(Index))
            End If
        Next



        Options.ListBoxColors.Items.Clear()

        For IndexColor = 1 To TopOfFile(SourceForm, "Color")
            If IndexColor > ConstantMyErrorCode Then
                If MyIsNothing(Color_TableName(IndexColor)) Or Color_TableName(IndexColor) = "" Then
                    logA(1397, Index.ToString, IndexColor.ToString)
                Else
                    Options.ListBoxColors.Items.Add(Color_TableName(IndexColor))
                End If
            Else
                logA(1398, IndexColor.ToString, Index.ToString, MyShowColor(SourceForm, False, Index))
            End If
        Next



        For IndexDropDown = 0 To Options.ListBoxColors.Items.Count - 1
            If MyStrComp(Options.ListBoxColors.Items.Item(IndexDropDown).ToString, ColorName) = 0 Then
                Options.ListBoxColors.Text = ColorName
                MyUniverse.ProgramOptions.SelectedColor = ColorName
                Exit For
            End If
        Next IndexDropDown

        If MyDebug(A_STATUS) = True Then
        End If
    End Sub


    Friend Sub YouHaveAnErrorMessage(WhichOne As Integer, WhatIsIt As String)
        OLD.DisplayStatus(3240, WhatIsIt, WhichOne.ToString)
        DoEvent(47, "Error Messages Made")
    End Sub



    Friend Sub MoveAllPaths(ByRef SourceForm As Source, AtX1Y1 As MyPointStructure, MoveOverXY As MyPointStructure)
        Dim AtXY As MyLineStructure
        Dim Index As Integer
        AtXY.a.x = AtX1Y1.x
        AtXY.a.y = AtX1Y1.y

        For Index = 1 To TopOfListBox(SourceForm.ListBoxFlowChart)
            Select Case LCase(FlowChart_TableCode(SourceForm, Index))
                Case "/path"
                    'Try One End 
                    ' Comparing the same code type snap ' this really is a hack, but it works
                    If DoesPointMatch(MySnapIndex(SourceForm, Index).a, MySnapXYXY(Source, "/path", AtXY.a.x, AtXY.a.y, AtXY.b.x, AtXY.b.y).a) = True Then
                        PaintErase(SourceForm, Index)
                        FlowChart_TableX1(SourceForm, Index, FlowChart_TableX1(SourceForm, Index) + MoveOverXY.x)
                        FlowChart_TableY1(SourceForm, Index, FlowChart_TableY1(SourceForm, Index) + MoveOverXY.y)
                        PaintAll(SourceForm, Index - 1, Index + 1)
                    End If
                    'Try the other end
                    If DoesPointMatch(MySnapIndex(SourceForm, Index).b, MySnapXYXY(Source, "/path", AtXY.a.x, AtXY.a.y, AtXY.b.x, AtXY.b.y).a) = True Then
                        PaintErase(SourceForm, Index)
                        FlowChart_TableX2(SourceForm, Index, FlowChart_TableX2(SourceForm, Index) + MoveOverXY.x)
                        FlowChart_TableY2(SourceForm, Index, FlowChart_TableY2(SourceForm, Index) + MoveOverXY.y)
                        PaintAll(SourceForm, Index, Index)
                    End If
                Case Else
                    logA(2072, Index.ToString & "--> " & MyShowFlowChartRecord(SourceForm, False, Index))
            End Select
        Next

    End Sub



    Friend Function MoveSymbolAndAllPaths(ByRef SourceForm As Source, IndexFlowChart As Integer, MyDistanceXY As MyPointStructure) As Boolean
        ' Need to change this to also move any connected paths before moving the Symbol
        Dim IndexPoint As Integer
        Dim XY As MyPointStructure
        Dim XDistance As Integer
        Dim YDistance As Integer


        XDistance = MyDistanceXY.x
        YDistance = MyDistanceXY.y

        IndexPoint = FindInSymbolList(SourceForm, FlowChart_TablePathName(SourceForm, IndexFlowChart))

        If IndexPoint > ConstantMyErrorCode Then
            IndexPoint += 1 ' Skip over the name

            While IndexPoint <= TopOfFile(SourceForm, "Symbol") And Symbol_TableCoded_String(IndexPoint) <> "/name"
                Select Case LCase(Symbol_TableCoded_String(IndexPoint))
                    Case "/point"
                        XY = MyRotated(SourceForm, IndexPoint, IndexFlowChart)
                        MoveAllPaths(SourceForm, XY, MyDistanceXY)
                    Case "/Line"
                    Case Else 'todo need to add this
                        logA(2158, Symbol_TableCoded_String(IndexPoint))
                End Select

                IndexPoint += 1 ' Skip over the name
            End While

        End If

        logA(1402, IndexFlowChart.ToString, MyShowFlowChartRecord(SourceForm, False, IndexFlowChart), MyPoint1XY(FlowChart_TableX1(SourceForm, IndexFlowChart) + XDistance, FlowChart_TableY1(SourceForm, IndexFlowChart) + YDistance).ToString)
        PaintErase(SourceForm, IndexFlowChart)
        FlowChart_TableX1(SourceForm, IndexFlowChart, FlowChart_TableX1(SourceForm, IndexFlowChart) + XDistance)
        FlowChart_TableY1(SourceForm, IndexFlowChart, FlowChart_TableY1(SourceForm, IndexFlowChart) + YDistance)
        PaintAll(SourceForm, IndexFlowChart, IndexFlowChart)
        Return True
    End Function


    Friend Function BlockedRectangleAt(xy1 As MyLineStructure, xy2 As MyLineStructure) As MyLineStructure
        Dim A, B As Integer


        BlockedRectangleAt = Nothing
        A = MyMax(xy1.a.x, xy1.b.x)
        B = MyMax(xy2.a.x, xy2.b.x)
        BlockedRectangleAt.a.x = MyMin(A, B)

        A = MyMax(xy1.a.y, xy1.b.y)
        B = MyMax(xy2.a.y, xy2.b.y)
        BlockedRectangleAt.a.x = MyMin(A, B)

        A = MyMin(xy1.a.x, xy1.b.x)
        B = MyMin(xy2.a.x, xy2.b.x)
        BlockedRectangleAt.a.x = MyMax(A, B)

        A = MyMin(xy1.a.x, xy1.b.x)
        B = MyMin(xy2.a.x, xy2.b.x)
        BlockedRectangleAt.a.x = MyMax(A, B)
    End Function



    Friend Function SymbolOnTopOfSymbol(ByRef SourceForm As Source, A As Integer, B As Integer) As Boolean
        Dim T2 As Integer
        If A = B Then Return False 'you can not be on top of yourself 
        If FlowChart_TableCode(SourceForm, A) <> My_keyWord(My_KeyConstUse) Then Return False
        If FlowChart_TableCode(SourceForm, B) <> My_keyWord(My_KeyConstUse) Then Return False
        'check that they are both Symbols, and not a path, because the path might be connected to it.
        T2 = MyDistance(MyPoint1XY(A), MyPoint1_1XY(SourceForm, B))
        If MyDebug(A_STATUS) Then logA(2741, T2.ToString, A.ToString, B.ToString, MyShowFlowChartRecord(SourceForm, False, A), MyShowFlowChartRecord(SourceForm, False, B))
        'todo  the * 4 should be set to the spacing factor in placement
        If T2 < MyUniverse.SysGen.Constants.ConstantSymbolCenter * 3 Then ' Not close to each other either
            If MyDebug(A_INFORMATION) Then logA(1405, T2.ToString, MyShowFlowChartRecord(SourceForm.ListBoxFlowChart, False, A), MyShowFlowChartRecord(SourceForm, False, B))
            SymbolOnTopOfSymbol = True
        Else
            SymbolOnTopOfSymbol = False
        End If

    End Function

    Friend Function LinesAboveOrBelow(A As MyLineStructure, B As MyLineStructure) As Boolean
        If PathAboveOrBelow(A.a.x, A.b.x, B.a.x) Then Return True
        If PathAboveOrBelow(A.a.y, A.b.y, B.a.x) Then Return True

        If PathAboveOrBelow(A.a.x, A.b.x, B.b.x) Then Return True
        If PathAboveOrBelow(A.a.y, A.b.y, B.b.x) Then Return True
        Return False
    End Function

    Friend Function PathAboveOrBelow(aY As Integer, bY1 As Integer, bY2 As Integer) As Boolean
        If aY > bY1 And aY > bY2 Then 'Ignore it its all above the Line
            PathAboveOrBelow = False
        ElseIf aY < bY1 And aY < bY2 Then     'ignore it is below the other
            PathAboveOrBelow = False
        Else 'they are on top of each other
            PathAboveOrBelow = True
        End If
    End Function

    Friend Function DoesFlowChartPathMatch(ByRef SourceForm As Source, IndexFlowChart1 As Integer, IndexFlowChart2 As Integer) As Boolean
        Return DoesPathMeet(MyLine1(SourceForm, IndexFlowChart1), MyLine2(SourceForm, IndexFlowChart2))
    End Function


    Friend Function DoesPointMatch(A As MyPointStructure, B As MyPointStructure) As Boolean
        If (A.x = 0 And A.y = 0) Or (B.x = 0 And B.y = 0) Then
            Return False ' never match to zeroZero
        End If
        If A.x = B.x And A.y = B.y Then Return True
        Return False
    End Function

    Friend Function DoesPathMeet(A As MyLineStructure, B As MyLineStructure) As Boolean
        If DoesPointMatch(A.a, B.a) = True Then Return True
        If DoesPointMatch(A.a, B.b) = True Then Return True
        If DoesPointMatch(A.b, B.a) = True Then Return True
        If DoesPointMatch(A.b, B.b) = True Then Return True
        Return False
    End Function


    Friend Function PathOnTop(ByRef SourceForm As Source, Index1 As Integer, Index2 As Integer) As Boolean
        Return PathOnTopHere(SourceForm, MyLine1(SourceForm, Index1), MyLine2(SourceForm, Index2))
    End Function


    Friend Function PathOnTopHere(ByRef SourceForm As Source, A As MyLineStructure, B As MyLineStructure) As Boolean ' Is the Path on top of each other
        ' I am only checking if the distance is close to each other, not if they Lines are on top of each other.
        ' On top of each other is only if they are up/down and/or right/left - angle Lines should be change 
        '(if the option is checked) other wise no checking
        Dim T1, T2, T3, T4, Temp As Integer
        'If this option is chosen
        MyDrawBox(SourceForm, MinMaxIt(A, B))
        If DoesPathMeet(A, B) = True Then
            If LinesAboveOrBelow(A, B) Then
                PathOnTopHere = True
                Exit Function
            End If

            If PathAboveOrBelow(A.a.x, B.a.x, B.b.x) = True Or
                    PathAboveOrBelow(A.a.y, B.a.y, B.b.y) = True Or
                    PathAboveOrBelow(A.b.x, B.b.x, B.b.x) = True Or
                    PathAboveOrBelow(A.b.y, B.b.y, B.b.y) = True Then
                PathOnTopHere = True
                WW3(SourceForm, A.a, A.b, B.a, RandomColor(SourceForm))
                WW3(SourceForm, B.b, B.a, A.b, RandomColor(SourceForm))
                Exit Function
            Else
                Return True
            End If
        End If

        'Else ' If the option is not chosen
        T1 = MyDistance(MyPoint1XY(A.a.x, A.a.y), MyPoint2XY(B.a.x, B.a.y)) ' a1-b1
        T2 = MyDistance(MyPoint1XY(A.a.x, A.a.y), MyPoint2XY(B.b.x, B.b.y)) ' a1-b2
        T3 = MyDistance(MyPoint1XY(A.b.x, A.b.y), MyPoint2XY(B.a.x, B.a.y)) ' a2-b1
        T4 = MyDistance(MyPoint1XY(A.b.x, A.b.y), MyPoint2XY(B.b.x, B.b.y)) ' a2-b2
        Temp = T1
        If Temp > T2 Then Temp = T2
        If Temp > T3 Then Temp = T3
        If Temp > T4 Then Temp = T4

        If Temp <= MyUniverse.SysGen.Snaps.MyPointSnap Then
            PathOnTopHere = True : Exit Function
        End If

        'End If
        PathOnTopHere = False
    End Function



    Friend Sub CheckColorTable(ByRef SourceForm As Source)
        Dim IndexColor As Integer
        Dim JIndexColor As Integer
        Dim I As Integer


        For IndexColor = 1 To TopOfFile(SourceForm, "Color") - 1
            '''''ShowProgressBar(1, I, TopOfFile(SourceForm,  "Color"))
            DoEvent(49, "Check Colors")
            JIndexColor = IndexColor + 1
            If MyStrComp(Color_TableName(IndexColor), Color_TableName(JIndexColor)) = 0 Then
                YouHaveAnErrorMessage(1, "duplicate color named " & LCase(Color_TableName(IndexColor)) & " and " & LCase(Color_TableName(JIndexColor)))
                Color_TableName(IndexColor, Color_TableName(IndexColor) & "_CopyA" & I)
            End If
        Next

    End Sub

    Friend Sub CheckDataType_Table(ByRef SourceForm As Source)
        Dim Index As Integer
        Dim JIndex As Integer
        For Index = 1 To TopOfFile(SourceForm, "DataType")
            For JIndex = Index + 1 To TopOfFile(SourceForm, "DataType")
                DoEvent(51, "Check Data Type")
                If MyStrComp(DataType_TableName(Index), DataType_TableName(JIndex)) = 0 Then
                    YouHaveAnErrorMessage(1, "duplicate data type named " & LCase(DataType_TableName(Index)) & " and " & LCase(DataType_TableName(JIndex)))
                    DataType_TableName(Index, DataType_TableName(Index) & "_CopyB")
                End If
            Next

        Next

    End Sub


    Friend Sub CheckNamed_Table(ByRef SourceForm As Source)
        Dim ISAMIndex As Integer
        Dim JIndex As Integer

        For ISAMIndex = 1 To TopOfFile(SourceForm, "named")
            JIndex = ISAMIndex + 1
            DoEvent(52, "Check Named")
            If MyStrComp(Named_TableSymbolName(Named_FileSymbolName_ISAM(ISAMIndex)), Named_TableSymbolName(Named_FileSymbolName_ISAM(JIndex))) = 0 Then
                YouHaveAnErrorMessage(1, "duplicate Symbol named " & Named_TableSymbolName(Named_FileSymbolName_ISAM(ISAMIndex)) & " and " & Named_TableSymbolName(Named_FileSymbolName_ISAM(JIndex)))
                Named_TableSymbolName(JIndex, Named_TableSymbolName(Named_FileSymbolName_ISAM(JIndex)) & "_CopyC")
            End If
        Next

    End Sub
    Friend Sub MyCheckForMovingPathEnds(ByRef SourceForm As Source, index As Integer, xy As MyPointStructure)
        Dim XY1XY As MyPointStructure = Nothing

        If LCase(FlowChart_TableCode(SourceForm, index)) <> "/path" Then Return ' not a path to modify, program should never reach here
        XY1XY.x = FlowChart_TableX1(SourceForm, index)
        XY1XY.y = FlowChart_TableY1(SourceForm, index)
        If MyDistance(XY1XY, xy) <= MyUniverse.SysGen.Constants.ConstantDistanceToMovePaths Then
            'MyStatus("Changing " & FlowChart_TableX1(SourceForm ,index) & " To " & XY.x & " and also " & FlowChart_TableY1(SourceForm    , SourceForm    , index) & " To " & xy.Y)
            PaintErase(SourceForm, index) ' get rid of where it was and
            FlowChart_TableX1(SourceForm, index, xy.x)
            FlowChart_TableY1(SourceForm, index, xy.y)
            PaintAll(SourceForm, index, index) 'repaint it where its going to
            'MyStatus("")
        End If


        XY1XY.x = FlowChart_TableX2(SourceForm, index)
        XY1XY.y = FlowChart_TableY2(SourceForm, index)
        If MyDistance(XY1XY, xy) <= MyUniverse.SysGen.Constants.ConstantDistanceToMovePaths Then
            '    MyStatus("Changing " & FlowChart_TableX2_Rotation(index) & " To " & XY.x & " and also " & FlowChart_TableY2_Option(index) & " To " & xy.y)
            PaintErase(SourceForm, index) ' get rid of where it was and
            FlowChart_TableX2(SourceForm, index, xy.x)
            FlowChart_TableY2(SourceForm, index, xy.y)
            PaintAll(SourceForm, index, index) 'repaint it where its going to
            '   MyStatus("")
        End If
    End Sub


    Friend Sub CheckAllPaths(ByRef SourceForm As Source)
        Dim Flag As Boolean
        Dim MyXY1 As MyRECTStructure
        Dim MyXY2 As MyPointStructure
        Dim FlowChartUseIndex, FlowChartPathIndex, FlowChartCheckingPathIndex As Integer



        MyXY1 = Nothing
        'todo is this necessary '''MyXY2=Nothing



        For FlowChartUseIndex = 1 To TopOfListBox(SourceForm.ListBoxFlowChart)
            Flag = False
            MyXY1.MyWorldXY.a.x = FlowChart_TableX1(SourceForm, FlowChartUseIndex)
            MyXY1.MyWorldXY.a.y = FlowChart_TableY1(SourceForm, FlowChartUseIndex)
            MyXY1.MyWorldXY.b.x = FlowChart_TableX2(SourceForm, FlowChartUseIndex)
            MyXY1.MyWorldXY.b.y = FlowChart_TableY2(SourceForm, FlowChartUseIndex)
            DoEvent(54, "Check Paths")
            Select Case LCase(FlowChart_TableCode(SourceForm, FlowChartUseIndex))
                Case "" ' ignore if nothing also
        '?Flag=True
                Case "/path", My_keyWord(My_KeyConstUse)
                    ' We are looking at a Symbol points connecting
                    For FlowChartPathIndex = FlowChartUseIndex + 1 To TopOfListBox(SourceForm.ListBoxFlowChart) ' Looking only for /use statements
                        DoEvent(55, "Check Paths")
                        PaintErase(SourceForm, FlowChartPathIndex)
                        Select Case LCase(FlowChart_TableCode(SourceForm, FlowChartPathIndex))
                            Case My_keyWord(My_KeyConstUse)
                                FlowChartCheckingPathIndex = FindInSymbolList(SourceForm, FlowChart_TableSymbol_Name(SourceForm, FlowChartPathIndex))
                                If FlowChartCheckingPathIndex = ConstantMyErrorCode Then
                                    logA(1400, FlowChart_TableSymbol_Name(SourceForm, FlowChartPathIndex), MyShowFlowChartRecord(SourceForm, False, FlowChartPathIndex))
                                    MakeErrorAt(SourceForm, MyXY1.MyInputWindowXY.a, "There is no Symbol defined in the library with the name >" & FlowChart_TableSymbol_Name(SourceForm, FlowChartPathIndex) & "< ")
                                    MakeErrorAt(SourceForm, MyXY1.MyInputWindowXY.b, "There is no Symbol defined in the library with the name >" & FlowChart_TableSymbol_Name(SourceForm, FlowChartPathIndex) & "< ")
                                Else
                                    FlowChartCheckingPathIndex += 1 ' skip over the name of the Symbol
                                    'MyStatus("Comparing " & Index & " : " & FlowChartPathIndex & " : " & FlowChartCheckingPathIndex)

                                    While FlowChartCheckingPathIndex <= TopOfFile(SourceForm, "Symbol")  ' Till the next name
                                        DoEvent(56, "Check Paths")
                                        '    MyStatus("Comparing index " & Index & " with index " & FlowChartPathIndex & " with index  " & FlowChartCheckingPathIndex)
                                        Select Case LCase(Symbol_TableCoded_String(FlowChartCheckingPathIndex))
                                            Case "/name"
                                                Exit While ' End of the Symbol (starting of the next Symbol)
                                            Case "/Line" 'Line Start so ignore - cause Lines have no meaning
                                            Case "/point" ' See if the path matches the point
                                                MyXY2 = MyRotated(SourceForm, FlowChartPathIndex, FlowChartCheckingPathIndex)
                                                ' Checking of point points to here.
                                                If MyDistance(MyXY2, MyXY1.MyWorldXY.a) < MyUniverse.SysGen.Constants.ConstantDistanceToMovePaths Then
                                                    logA(1401, Symbol_FileSymbolName(FlowChartCheckingPathIndex), MyDistance(MyXY2, MyXY1.MyWorldXY.a).ToString)
                                                    MyCheckForMovingPathEnds(SourceForm, FlowChartPathIndex, MyXY2)
                                                    '?Flag=True

                                                    Exit For
                                                End If
                                                If MyDistance(MyXY2, MyXY1.MyWorldXY.b) < MyUniverse.SysGen.Constants.ConstantDistanceToMovePaths Then
                                                    logA(1411, Symbol_FileSymbolName(FlowChartCheckingPathIndex), MyDistance(MyXY2, MyXY1.MyWorldXY.b).ToString)
                                                    MyCheckForMovingPathEnds(SourceForm, FlowChartPathIndex, MyXY2)
                                                    '?Flag=True

                                                    Exit For
                                                End If
                                            Case "/delete"
                                            Case "/error"
                                            Case Else 'todo need to add something here
                                                logA(2160, Symbol_TableCoded_String(FlowChartCheckingPathIndex))
                                        End Select ' end of the Symbols
                                        FlowChartCheckingPathIndex += 1 ' Should I ?
                                        ' MyStatus("Comparing " & Index & " : " & FlowChartPathIndex & " : " & FlowChartCheckingPathIndex)
                                    End While ' next record in the Symbols

                                End If ' Testing if this is a /use
                            Case "/path"
                                ' check if two paths are connected
                                'FlowChartPathIndex=Index
                                If LCase(FlowChart_TableCode(SourceForm, FlowChartUseIndex)) = "/path" Then
                                    For FlowChartCheckingPathIndex = FlowChartPathIndex To TopOfListBox(SourceForm.ListBoxFlowChart)
                                        DoEvent(57, "Check Paths")
                                        If FlowChartCheckingPathIndex <> FlowChartUseIndex Then ' DoNot compare the same path
                                            If LCase(FlowChart_TableCode(SourceForm, FlowChartCheckingPathIndex)) = "/path" Then ' only compart paths to other paths
                                                'xy1 to xy2
                                                If MyDistance(MyPoint1_1XY(SourceForm, FlowChartUseIndex), MyPoint2_2XY(SourceForm, FlowChartCheckingPathIndex)) = 0 Then
                                                    logA(1412, FlowChartUseIndex.ToString, FlowChartCheckingPathIndex.ToString)
                                                    ' We are matching two paths together so Ignore if it goes to another.
                                                    '*** We need to check that the names (name of the variable) are the same for the two paths (or can make them the same)
                                                    MyCheckForMovingPathEnds(SourceForm, FlowChartUseIndex, MyPoint2_2XY(SourceForm, FlowChartCheckingPathIndex))
                                                    Flag = True
                                                    ' DoNot exit, check all other paths also 'Exit For
                                                End If
                                                ' xy2 to xy1
                                                If MyDistance(MyPoint2_1XY(SourceForm, (FlowChartUseIndex)), MyPoint1XY(FlowChartCheckingPathIndex)) = 0 Then
                                                    logA(1413, FlowChartUseIndex.ToString, FlowChartCheckingPathIndex.ToString)
                                                    MyCheckForMovingPathEnds(SourceForm, FlowChartUseIndex, MyPoint1XY(FlowChartCheckingPathIndex))
                                                    Flag = True
                                                    ' DoNot exit, check all other paths also 'Exit For
                                                End If

                                                If MyDistance(MyPoint2_1XY(SourceForm, FlowChartUseIndex), MyPoint2_2XY(SourceForm, FlowChartCheckingPathIndex)) = 0 Then
                                                    logA(1414, MyShowFlowChartRecord(SourceForm, True, FlowChartUseIndex), MyShowFlowChartRecord(SourceForm, True, FlowChartCheckingPathIndex))
                                                    MyCheckForMovingPathEnds(SourceForm, FlowChartUseIndex, MyPoint2_2XY(SourceForm, FlowChartCheckingPathIndex))
                                                    Flag = True
                                                    ' DoNot exit, check all other paths also 'Exit For
                                                End If
                                                If MyDistance(MyPoint2_1XY(SourceForm, FlowChartUseIndex), MyPoint2_2XY(SourceForm, FlowChartCheckingPathIndex)) = 0 Then
                                                    logA(1415, MyShowFlowChartRecord(SourceForm, True, FlowChartUseIndex), MyShowFlowChartRecord(SourceForm, True, FlowChartCheckingPathIndex))
                                                    MyCheckForMovingPathEnds(SourceForm, FlowChartUseIndex, MyPoint2_2XY(SourceForm, FlowChartCheckingPathIndex))
                                                    Flag = True
                                                    ' DoNot exit, check all other paths also 'Exit For
                                                End If
                                            End If
                                        End If
                                    Next
                                End If
                            Case "/Constant"
                                Flag = True
                            Case "/delete"
                                Flag = True
                            Case "/error"
                                Flag = True
                            Case Else 'todo add here
                                logA(2162, FlowChart_TableCode(SourceForm, FlowChartPathIndex), MyShowFlowChartRecord(SourceForm, False, FlowChartPathIndex))
                        End Select
                        If Flag = False Then 'hack
                            logA(1416, MyShowFlowChartRecord(SourceForm, True, FlowChartUseIndex), MyShowFlowChartRecord(SourceForm, True, FlowChartCheckingPathIndex)) 'hack
                            MakeErrorAt(SourceForm, MyPoint1_1XY(SourceForm, FlowChartUseIndex), "Path goes no where")
                        End If
                    Next
                Case Else
                    logA(2083, MyShowFlowChartRecord(SourceForm, False, FlowChartPathIndex))
            End Select

        Next ' Index


    End Sub





    Friend Function CheckAllSymbolsOnFlowChart(ByRef SourceForm As Source) As Integer
        Dim IndexFlowChart, JIndex As Integer
        Dim MyXY As MyPointStructure

        MyXY = Nothing
        CheckAllSymbolsOnFlowChart = 0
        '            DoEvent(60, "Check Symbols")

        For IndexFlowChart = 1 To TopOfListBox(SourceForm.ListBoxFlowChart)
            ' removed   DoEvent(173)

            For JIndex = IndexFlowChart + 1 To TopOfListBox(SourceForm.ListBoxFlowChart)
                If MyDebug(A_STATUS) Then logA(1418, MyShowFlowChartRecord(SourceForm, True, IndexFlowChart), MyShowFlowChartRecord(SourceForm, True, JIndex))
                'DoEvent(60, "Check Symbols")
                If LCase(FlowChart_TableCode(SourceForm, JIndex)) = My_keyWord(My_KeyConstUse) Then
                    If MyOptionTest(15) = True Then ' Auto Move Symbols on top of each other


                        While SymbolOnTopOfSymbol(SourceForm, IndexFlowChart, JIndex) = True
                            MoveSymbolAndAllPaths(SourceForm, JIndex, MyPoint1XY(MyUniverse.SysGen.Snaps.MySymbolSnap, 0))
                            DoEvent(61, "Check Symbols")
                        End While


                    Else
                        If SymbolOnTopOfSymbol(SourceForm, IndexFlowChart, JIndex) = True Then
                            MyXY.x = FlowChart_TableX1(SourceForm, IndexFlowChart)
                            MyXY.y = FlowChart_TableY1(SourceForm, IndexFlowChart)
                            CheckAllSymbolsOnFlowChart += 1
                            MakeErrorAt(SourceForm, MyXY, "Symbol Overlaps " & MyShowFlowChartRecord(SourceForm, False, IndexFlowChart) & " with " & MyShowFlowChartRecord(SourceForm, False, JIndex))
                        End If
                    End If
                End If

                If MyStrComp(FlowChart_TableCode(SourceForm, IndexFlowChart), My_keyWord(My_KeyConstUse)) = 0 Then
                    CheckAllSymbolsOnFlowChart += CheckSymbolByNamedIndex(SourceForm, IndexFlowChart)
                End If
            Next

        Next

    End Function


    Friend Function CheckSymbolByNamedIndex(ByRef SourceForm As Source, IndexNamed As Integer) As Integer
        Dim IndexSymbol As Integer

        CheckSymbolByNamedIndex = ConstantMyErrorCode

        'IndexNamed=binarysearchlist4index(Options.listboxsymbols ,,'FlowChart_TablePathSymbol_Name(IndexFlowChart ))
        If IndexNamed = ConstantMyErrorCode Then Return ConstantMyErrorCode

        IndexSymbol = CorrectingIndexes(SourceForm, Named_TableSymbolName(IndexNamed))

        If IndexSymbol > ConstantMyErrorCode Then
            IndexSymbol += 1 ' go past the name 

            While IndexSymbol <= TopOfFile(SourceForm, "named")
                ' First check that the name of the point is in the program text (with " & MyFD("
                Select Case LCase(Symbol_TableCoded_String(IndexSymbol))
                    Case "/point" ' Check points
                        If MyInStr(NameOfPointOnly(Symbol_Table_NameOfPoint(IndexSymbol)), Named_TableSyntax(IndexNamed)) = 0 Then
                            CheckSymbolByNamedIndex += 1
                            If MyDebug(A_INFORMATION) Then
                                logA(1421, Symbol_Table_NameOfPoint(IndexSymbol), MyShowSymbolGraphic(True, IndexSymbol), MyShowNamedRecord(True, IndexNamed))
                                If MyOptionTest(25) Then
                                    logA(2163, IndexNamed.ToString, Named_TableSyntax(IndexNamed), Symbol_Table_NameOfPoint(IndexSymbol), NameOfPointOnly(Symbol_Table_NameOfPoint(IndexSymbol)), MakePathName(NameOfPointOnly(Symbol_Table_NameOfPoint(IndexSymbol))))
                                    Named_TableSyntax(IndexNamed, Named_TableSyntax(IndexNamed) & CT & MakePathName(NameOfPointOnly(Symbol_Table_NameOfPoint(IndexSymbol))))
                                Else
                                    'todo report bug
                                    '' "Index=" & IndexNamed.ToString & ":" & IndexSymbol.ToString,
                                    logA(1422, MyShowSymbolGraphic(False, IndexSymbol), MyShowNamedRecord(False, IndexNamed), Named_TableSyntax(IndexNamed), Symbol_Table_NameOfPoint(IndexSymbol))
                                End If
                            End If
                        End If

                        If MyInStr(NameOfPointOnly(Symbol_Table_NameOfPoint(IndexSymbol)), Named_TableSyntax(IndexNamed)) = 0 Then
                            If MyOptionTest(25) Then
                                CheckSymbolByNamedIndex += 1
                                logA(1426, Named_TableSyntax(IndexNamed), Named_TableMicroCodeText(IndexNamed), Symbol_Table_NameOfPoint(IndexSymbol))
                                'fix it
                                Named_TableMicroCodeText(IndexNamed, Named_TableMicroCodeText(IndexNamed) & CT & vbTab & NameOfPointOnly(Symbol_Table_NameOfPoint(IndexSymbol)))
                            Else
                                logA(1424, Named_TableSyntax(IndexNamed), Named_TableMicroCodeText(IndexNamed), Symbol_Table_NameOfPoint(IndexSymbol))
                            End If
                        End If
                    Case "/name"

                        Return CheckSymbolByNamedIndex 'hack Least amount of checking here 'hack
                    Case "/Line" 'ignore all Lines
                    Case "/error" 'ignore all errors in the Symbol (for now)
                        If MyDebug(A_INFORMATION) Then logA(1420)
                    Case "/unknown"
                        logA(1427, MyShowSymbolGraphic(True, IndexSymbol), Symbol_TableCoded_String(IndexSymbol))
                        'Dump3(2311, "Unknown code in the Symbol graphics " & Symbol_TableCoded_String(IndexSymbol))
                    Case Else
                        CheckSymbolByNamedIndex += 1
                        MsgBox(MyShowSymbolGraphic(True, IndexSymbol), MsgBoxStyle.Information, Translate("Unknowen Error Type"))
                End Select
                IndexSymbol += 1
            End While

        End If
        Return CheckSymbolByNamedIndex 'hack Least amount of checking here 'hack
    End Function


    Friend Sub CheckThisStringArray(BugNumber As Integer, LB As ListBox, Index As Integer)
        If Index <= 0 Then
            logA(1386, BugNumber.ToString, Index.ToString)
        End If
        If Index > TopOfListBox(LB) - 1 Then
            logA(1388, BugNumber.ToString, Index.ToString)
        End If
        If Index > TopOfListBox(LB) - 1 Then
            logA(1389, BugNumber.ToString, Index.ToString)
        End If
        If MyIsNothing(GetMyRecord(LB, Index)) Then
            logA(1393, BugNumber.ToString, Index.ToString)
        End If
        If Index < 1 Then
            logA(1394, BugNumber.ToString, Index.ToString)
        End If
        If Index >= TopOfListBox(LB) - 1 Then
            logA(1395, BugNumber.ToString, Index.ToString, (TopOfListBox(LB) - 1).ToString)
        End If
    End Sub


    ' This is to check everything (It should be a thread that is always running on new/moved/delete)
    Friend Sub CheckAll(ByRef SourceForm As Source)
        'First check for two named Symbols in the named/DataType/Color table
        CheckColorTable(SourceForm)
        CheckDataType_Table(SourceForm)
        CheckNamed_Table(SourceForm)
        CheckAllPaths(SourceForm)
        CheckAllSymbolsOnFlowChart(SourceForm)
    End Sub

    Friend Sub MyReMoveNamed(IndexNamed As Integer) ' completed destroy it (for now)

        Named_TableSymbolName(IndexNamed, Nothing)
        Named_TableMicroCodeText(IndexNamed, Nothing)
        '    Named_TableLanguage(IndexNamed, Nothing)
        Named_TableNotes(IndexNamed, Nothing)
        Named_TableOpCode(IndexNamed, Nothing)
        Named_TableSymbolIndexes(IndexNamed, Nothing)
        Named_TableNameOfFile(IndexNamed, Nothing)
        Named_TableStroke(IndexNamed, Nothing)
    End Sub

    Friend Sub MyReMoveSymbol(ByRef SourceForm As Source, SymbolName As String)
        Dim Index As Integer
        Index = FindInSymbolList(SourceForm, SymbolName)

        If Index = ConstantMyErrorCode Then
            logA(1437, SymbolName)
        Else
            If MyStrComp(Symbol_TableSymbolName(Index), SymbolName) = 0 Then
                Symbol_TableCode(SourceForm, Index, "/delete")

                While Symbol_TableCoded_String(Index) <> "/name" And Index <= TopOfFile(SourceForm, "Symbol")
                    Symbol_TableCode(SourceForm, Index, "/delete") ' consider making it nothing.
                    Index += 1
                End While

            Else
                'todo We have some kind of internal error here.
            End If
        End If
    End Sub

    'Need to make sure that we Sort after at least one of these (and reset the counter)
    Friend Sub MyDeleteDataType_Table(Index As Integer)
        DataType_TableName(Index, Nothing)
        DataType_TableColorIndex(Index, 0L)
        DataType_TableDescription(Index, Nothing)
        DataType_TableNumberOfBytes(Index, Nothing)
        DataType_TableWidth(Index, Nothing)
        'now we should move everything up (reverse insert sort)
    End Sub


    Friend Sub DeleteAllErrorMessages(ByRef SourceForm As Source)
        Dim Index As Integer
        Dim JIndex As Integer
        JIndex = 0 ' one before the usable records
        For Index = 1 To TopOfFile(SourceForm, "Symbol")
            If Symbol_TableCoded_String(Index) = "/error" Or Symbol_TableCoded_String(Index) = "/delete" Then
            Else
                JIndex += 1
            End If
            If Index <> JIndex Then
                MySwapSymbolList(SourceForm, Index, JIndex) ' Move the records forward over the bad record to compress
            End If
        Next

        JIndex = 0
        For Index = 1 To TopOfListBox(SourceForm.ListBoxFlowChart)
            If FlowChart_TableCode(SourceForm, Index) = "/error" Or FlowChart_TableCode(SourceForm, Index) = "/delete" Then
            Else
                JIndex += 1
            End If
            If Index <> JIndex Then
                MySwapSymbolList(SourceForm, Index, JIndex) ' Move the records forward over the bad record to compress
            End If
        Next
    End Sub


    Friend Function MyIsNothing(AString As String) As Boolean
        If IsNothing(AString) Then Return True
        If AString.ToString = "" Then Return True
        Return False
    End Function




    Friend Sub SetColumns(Optional A As Integer = 8, Optional B As Integer = 8, Optional C As Integer = 8, Optional D As Integer = 8, Optional E As Integer = 8, Optional F As Integer = 8, Optional G As Integer = 8, Optional H As Integer = 8, Optional I As Integer = 8, Optional J As Integer = 8, Optional K As Integer = 8, Optional L As Integer = 8, Optional M As Integer = 8, Optional N As Integer = 8, Optional O As Integer = 8, Optional P As Integer = 8, Optional Q As Integer = 8, Optional R As Integer = 8)
        If MyDebug(A_DISPLAY) Then
            logA(1496,
                       A.ToString & COMMA &
                       B.ToString & COMMA &
                       C.ToString & COMMA &
                       D.ToString & COMMA &
                       E.ToString & COMMA &
                       F.ToString & COMMA &
                       G.ToString & COMMA &
                       H.ToString & COMMA &
                       I.ToString & COMMA &
                       J.ToString & COMMA &
                       K.ToString & COMMA &
                       L.ToString & COMMA &
                       M.ToString & COMMA &
                       N.ToString & COMMA &
                       O.ToString & COMMA &
                       P.ToString & COMMA &
                       Q.ToString & COMMA &
                       R.ToString)
        End If
        MyUniverse.Column(1) = NullOrNumber(A)
        MyUniverse.Column(2) = NullOrNumber(B)
        MyUniverse.Column(3) = NullOrNumber(C)
        MyUniverse.Column(4) = NullOrNumber(D)
        MyUniverse.Column(5) = NullOrNumber(E)
        MyUniverse.Column(6) = NullOrNumber(F)
        MyUniverse.Column(7) = NullOrNumber(G)
        MyUniverse.Column(8) = NullOrNumber(H)
        MyUniverse.Column(9) = NullOrNumber(I)
        MyUniverse.Column(10) = NullOrNumber(J)
        MyUniverse.Column(11) = NullOrNumber(K)
        MyUniverse.Column(12) = NullOrNumber(L)
        MyUniverse.Column(13) = NullOrNumber(M)
        MyUniverse.Column(14) = NullOrNumber(N)
        MyUniverse.Column(15) = NullOrNumber(O)
        MyUniverse.Column(16) = NullOrNumber(P)
        MyUniverse.Column(17) = NullOrNumber(Q)
        MyUniverse.Column(18) = NullOrNumber(R)
    End Sub







    Friend Function NullOrNumber(Number As Integer) As Integer
        If Number = Nothing Then Return 0
        Return Number
    End Function


    'This makes sure that something is printable (make it an underLine instead of nothing)
    Friend Function PrintAbleNull(A As String) As String
        If IsNothing(A) Then Return "_"
        If Len(A.ToString) = 0 Or MyIsNothing(A.ToString) Then
            Return "_"
        Else
            Return A
        End If
    End Function


    Friend Function MyOffset(XY As MyPointStructure, X As String, Y As String) As MyPointStructure
        MyOffset = Nothing
        MyOffset.x = XY.x + My_INT(X)
        MyOffset.y = XY.y + My_INT(Y)
    End Function



    Friend Function FindPathNameAtLine(ByRef SourceForm As Source) As String
        Dim S1, S2 As String
        Dim LocalIndex, JIndex As Integer
        LocalIndex = FindPathNameAt(SourceForm, MyUniverse.Area.MyWorldXY.b)
        JIndex = FindPathNameAt(SourceForm, MyUniverse.Area.MyWorldXY.a)
        S1 = FlowChart_TablePathName(SourceForm, LocalIndex)
        S2 = FlowChart_TablePathName(SourceForm, JIndex)
        If S1 = S2 Then Return S1
        If Len(S1) = 0 Then
            If Len(S2) = 0 Then
                Return Nothing
            Else
                Return S2
            End If
        Else
            If Len(S2) = 0 Then
                Return S1
            Else
                Return Nothing
            End If
        End If
        Return MakePathName("Path")
    End Function



    Friend Function FindDataTypeAt(ByRef SourceForm As Source, X As Integer, Y As Integer) As String
        Dim I, IndexSymbol As Integer
        'todo search throuth the isam from x-center-1 to x+center+1
        If X >= -250 And X <= 250 And Y <= 250 And Y >= -250 Then
            logA(1087, X.ToString, Y.ToString)
        End If

        For I = 1 To TopOfListBox(SourceForm.ListBoxFlowChart)
            Select Case FlowChart_TableCode(SourceForm, I)
                Case "/path"
                    If DoesPointMatch(MyPoint1XY(X, Y), MyPoint1XY(FlowChart_TableX1(SourceForm, I), FlowChart_TableY1(SourceForm, I))) Then
                        If FlowChart_TableDataType(SourceForm, I) <> "ERRORED" Then ' if errored then search for another stat type, because the default is errored

                            logA(4326, MyUniverse.MyStaticData.LastDataType)
                            Return FlowChart_TableDataType(SourceForm, I)
                        End If
                    End If
                    If DoesPointMatch(MyPoint1XY(X, Y), MyPoint1XY(FlowChart_TableX2(SourceForm, I), FlowChart_TableY2(SourceForm, I))) Then
                        If FlowChart_TableDataType(SourceForm, I) <> "ERRORED" Then ' if errored then search for another stat type, because the default is errored

                            logA(4327, MyUniverse.MyStaticData.LastDataType)
                            Return FlowChart_TableDataType(SourceForm, I)
                        End If
                    End If
                Case "/use"
                    IndexSymbol = CInt(FindInSymbolList(SourceForm, FlowChart_TableSymbol_Name(SourceForm, I)))
                    If IndexSymbol < 1 Or IndexSymbol > Options.ListBoxSymbols.Items.Count - 1 Then
                        logA(2165, IndexSymbol.ToString, MyShowSymbolGraphic(False, IndexSymbol), MyShowFlowChartRecord(SourceForm, False, I))
                    End If

                    While Symbol_TableSymbolName(IndexSymbol) = FlowChart_TableSymbol_Name(SourceForm, I)
                        ' log_X ( 2166, Symbol_TableCoded_String(IndexSymbol),  FlowChart_TableSymbol_Name(SourceForm  ,  I),  MyShowSymbolRecord(SourceForm ,False, IndexSymbol))
                        Select Case Symbol_TableCoded_String(IndexSymbol)
                            Case "/point"
                                'todo must compare the /use + /symbol to XY
                                'log_X(3559, MyDistance(MyPoint1XY( Symbol_TableX1(IndexSymbol) + FlowChart_TableX1(SourceForm ,I), Symbol_TableY1(IndexSymbol) + FlowChart_TableY1(SourceForm    , SourceForm    , I)), MyPoint2XY(X, Y)).ToString, MyShowPoint(X, Y), MyShowFlowChartRecord(SourceForm, False, I), MyShowSymbolGraphic(False, IndexSymbol))
                                If MyDistance(MyPoint1XY(SourceForm,
                                                  Symbol_TableX1(IndexSymbol) + FlowChart_TableX1(SourceForm, I),
                                                  Symbol_TableY1(IndexSymbol) + FlowChart_TableY1(SourceForm, I)),
                                                  MyPoint2XY(X, Y)) = 0 Then
                                    logA(1187, MyShowXY(X, Y), MyShowFlowChartRecord(SourceForm, False, I), MyShowSymbolGraphic(False, IndexSymbol))


                                    Return Symbol_Table_DataType(IndexSymbol)
                                End If


                                If Symbol_TableX1(IndexSymbol) + FlowChart_TableX1(SourceForm, I) = X Then
                                    If Symbol_TableY1(IndexSymbol) + FlowChart_TableY1(SourceForm, I) = Y Then
                                        logA(1189, MyShowXY(X, Y), Symbol_Table_DataType(IndexSymbol))


                                        Return Symbol_Table_DataType(IndexSymbol)
                                    End If
                                End If

                                    'If Symbol_TableX1(IndexSymbol) = X Then
                                    ' If Symbol_TableY1(IndexSymbol) = Y Then
                                    ' Return Symbol_Table_DataType(IndexSymbol)
                                    ' End If
                                    ' End If

                                    'If Symbol_TableX1(IndexSymbol) + FlowChart_TableX1(SourceForm ,I) = X Then
                                    ' If Symbol_TableY1(IndexSymbol) + FlowChart_TableY1(SourceForm    , SourceForm    , I) = Y Then
                                    ' Return Symbol_Table_DataType(IndexSymbol)
                                    ' End If
                                   ' End If
                            Case "/line", "/name", "/unknown" 'do not do anything (unknown is known to be a zero record)
                                'If MyDebug(a_fmb) Then
#If DEBUGMODE Then
                                   LogA(2084, IndexSymbol.ToString, SHL(Symbol_TableCoded_String(IndexSymbol)), MyShowSymbolRecord(SourceForm ,False, IndexSymbol))
#End If
                            Case Else 'todo need to add something here
                                logA(1897, Symbol_TableCoded_String(IndexSymbol), MyShowSymbolRecord(SourceForm, False, IndexSymbol))
                        End Select
                        ' log_X ( 2167, MyShowSymbolRecord(SourceForm ,False, IndexSymbol))
                        IndexSymbol += 1
                    End While

                Case "/Constant" 'todo needs to be written
                    If DoesPointMatch(MyPoint1XY(X, Y), MyPoint1XY(FlowChart_TableX1(SourceForm, I), FlowChart_TableY1(SourceForm, I))) Then
                        Return FlowChart_TableDataType(SourceForm, I)
                    Else
                        '   LogA(2081, MyShowFlowChartRecord(SourceForm, False, I), X.ToString, Y.ToString, FlowChart_TableX1(SourceForm ,I).ToString, FlowChart_TableY1(SourceForm    , SourceForm    , I).ToString)
                    End If
                Case "/raw", "/unknown", "/delete", "/error" 'ignore knows that are not being point information
                Case Else
                    logA(2082, FlowChart_TableCode(SourceForm, I), MyShowFlowChartRecord(SourceForm, False, I))
            End Select
        Next

        If MyTrim(MyUniverse.MyStaticData.LastDataType) = "" Then
            logA(4328, MyUniverse.MyStaticData.LastDataType)
            Return "Errored"
        Else
            'todo need to check that there is only one datatype per line.
            Return MyTrim(MyUniverse.MyStaticData.LastDataType)
        End If
    End Function

    ' This routine returns the name of (any-First) path that it finds closest to this location
    ' should use a binary search on X1 or Y1 iSam to get the first instead of a for loop
    Friend Function FindPathNameAt(ByRef SourceForm As Source, XY As MyPointStructure) As Integer ' index of path
        Dim D1, D2 As Integer
        Dim IndexFound, IndexFound2 As Integer ' First Found One
        Dim Index As Integer
        Dim D3, D4 As Integer 'hack
        If FMBRecurse("FindPathNameAt") > 10 Then Return ConstantMyErrorCode

        If MyDebug(A_INFORMATION) Then logA(3123, MyShowPoint(XY))

        IndexFound = 0
        IndexFound2 = 0

        For Index = 1 To TopOfListBox(SourceForm.ListBoxFlowChart) ' this should use the ISAM to go from a little below to a little above ... 
            Select Case LCase(FlowChart_TableCode(SourceForm, Index))
                Case "/use"
                Case "/error"
                Case "/Constant"
                Case "/path"
                    If IndexFound = 0 Then
                        'MyInfo(691, "setting to find shorter distance to :", MyShowFlowChartRecord(SourceForm, False, Index))
                        XY.Named.PathName = FlowChart_TablePathName(SourceForm, Index)
                        IndexFound = Index ' i IndexFound the first one available (It might even be itself.
                    End If
                    D1 = MyDistance(XY, MyPoint1XY(Index))
                    D2 = MyDistance(XY, MyPoint1XY(IndexFound))
                    If Index <> IndexFound Then
                        If MyOptionTest(34) Then
                            MyDrawPath(SourceForm, Index)
                            MyDrawPath(SourceForm, IndexFound)
                        End If
                        If PathOnTop(SourceForm, Index, IndexFound) Then
                            If MyDebug(A_STATUS) Then logA(1727, Index.ToString, MyShowFlowChartRecord(SourceForm, False, Index), IndexFound.ToString, MyShowFlowChartRecord(SourceForm, False, IndexFound))
                            MyDrawWorldPaths(SourceForm, Index, IndexFound)
                            MyDrawWorldPath(SourceForm, MyLine1(SourceForm, IndexFound), RandomColor(SourceForm))
                            MyDrawWorldPath(SourceForm, MyLine1(SourceForm, Index), RandomColor(SourceForm))
                        End If
                    End If
                    If D1 = 0 And D2 = 0 Then
                        logA(1449, MyShowPoint(XY), D1 & ":" & D2 & ":" & D3 & ":" & D4, Index.ToString & ":" & IndexFound.ToString & ":" & IndexFound2.ToString, MyShowFlowChartRecord(SourceForm, True, Index))

                        Return IndexFound
                    End If

                    If D1 <= D2 Then
                        IndexFound = Index
                        XY.Named.PathName = FlowChart_TablePathName(SourceForm, Index) & "_B"
                    End If
                Case Else
                    If IndexFound2 = 0 Then
                        IndexFound2 = Index
                        XY.Named.SymbolName = FlowChart_TableSymbol_Name(SourceForm, Index) & "_C"
                        If IndexFound <> 0 And IndexFound2 <> 0 Then
                            If MyDebug(A_INFORMATION) Then
                                logA(1443, MyShowPoint(XY), D1 & ":" & D2 & ":" & D3 & ":" & D4, Index.ToString & ":" & IndexFound.ToString & ":" & IndexFound2.ToString, MyShowFlowChartRecord(SourceForm, True, Index) & MyShowFlowChartRecord(SourceForm, True, IndexFound) & MyShowFlowChartRecord(SourceForm, True, IndexFound2))
                            End If
                        End If
                    End If
                    D3 = MyDistance(XY, MyPoint1XY(Index))
                    D4 = MyDistance(XY, MyPoint1XY(IndexFound))

                    If D3 < D4 Then
                        IndexFound2 = Index
                        XY.Named.SymbolName = FlowChart_TableSymbol_Name(SourceForm, Index) & "_D"
                        If MyDebug(A_INFORMATION) Then logA(1444, MyShowPoint(XY), D1 & ":" & D2 & ":" & D3 & ":" & D4, IndexFound.ToString & ":" & IndexFound2.ToString, MyShowFlowChartRecord(SourceForm, True, Index), MyShowFlowChartRecord(SourceForm, True, IndexFound), MyShowFlowChartRecord(SourceForm, True, IndexFound2))
                    End If
            End Select
        Next



        If IndexFound > 0 Then
            If MyDistance(XY, MyPoint1XY(IndexFound)) > 0 Then
                Return -IndexFound
            Else
                Return IndexFound
            End If
        Else
            logA(3560, MyShowPoint(XY), D1.ToString, D2.ToString, D3.ToString, D4.ToString, Index.ToString, IndexFound.ToString, IndexFound2.ToString, MyShowFlowChartRecord(SourceForm, True, Index), MyShowFlowChartRecord(SourceForm, True, IndexFound), MyShowFlowChartRecord(SourceForm, True, IndexFound2))
            logA(1446, MyShowPoint(XY), D1 & ":" & D2 & ":" & D3 & ":" & D4, Index & ":" & IndexFound & ":" & IndexFound2, MyShowFlowChartRecord(SourceForm, True, Index), MyShowFlowChartRecord(SourceForm, True, IndexFound), MyShowFlowChartRecord(SourceForm, True, IndexFound2))
            If IndexFound2 > 0 Then
                If FlowChart_TableCode(SourceForm, IndexFound2) <> My_keyWord(My_KeyConstUse) Then
                    logA(1447, MyShowPoint(XY), MyShowPoint(MyPoint1XY(D3, D4)), MyShowFlowChartRecord(SourceForm, True, IndexFound2))

                End If
            End If
            If MyDebug(A_INFORMATION) Then logA(1448, MyShowPoint(XY), D1 & ":" & D2 & ":" & D3 & ":" & D4, Index.ToString & ":" & IndexFound.ToString & ":" & IndexFound2.ToString, MyShowFlowChartRecord(SourceForm, True, Index))
            Return ConstantMyErrorCode
        End If
        'should never get to this point!!!!
        logA(1449, MyShowPoint(XY), D1 & ":" & D2 & ":" & D3 & ":" & D4, Index & ":" & IndexFound & ":" & IndexFound2, MyShowFlowChartRecord(SourceForm, True, Index))
    End Function

    'RECURSIVE routine to find all of the paths connected together to XY.
    Friend Function FindAllPaths(ByRef SourceForm As Source, IndexFlowChart As Integer, XY As MyPointStructure, Pathname As String) As Boolean
        'Yes I know that it causes recursion Loop that will never Stop, I'll fix it later - Really I will
        ' Find all of the points to this location and return as a string of the index to that path
        Dim I As Integer
        Dim IndexFlowChartX1 As Integer

        Pathname = CheckThisPathName(SourceForm, Pathname, IndexFlowChart)

        'log_X(1451, "FindAllPaths " & MyShowPoint(XY), Pathname, MyShowFlowChartRecord(SourceForm, true,  IndexFlowChart))
        If IndexFlowChart < 1 Then
            logA(1452, IndexFlowChart.ToString, MyShowPoint(XY), Pathname)
            Return False
        End If
        If IndexFlowChart > TopOfListBox(SourceForm.ListBoxFlowChart) Then Return False
        If LCase(FlowChart_TableCode(SourceForm, IndexFlowChart)) <> "/path" Then Return False

        If MyInListOfNumbers(SourceForm, IndexFlowChart) = False Then
            Net_TableLinks(IndexFlowChart, FlowChart_Table(SourceForm, IndexFlowChart) & FD & IndexFlowChart.ToString & FD)
            logA(1453, IndexFlowChart.ToString, MyShowFlowChartRecord(SourceForm, True, IndexFlowChart), FlowChart_Table(SourceForm, IndexFlowChart).ToString, Net_TableLinks(IndexFlowChart))
            Return True
        End If

        IndexFlowChartX1 = FlowChart_TableX1(SourceForm, IndexFlowChart)
        IndexFlowChartX1 = MyMinMax(IndexFlowChartX1, 1, SourceForm.ListBoxFlowChart.Items.Count - 1)

        'Why does the following Line error out? It works the first few times
        '?
        'Lets make sure we are at the beginning of the first Index

        While FlowChart_TableX1(SourceForm, IndexFlowChartX1) < FlowChart_TableX1(SourceForm, IndexFlowChart)
            IndexFlowChartX1 += 1
            If IndexFlowChartX1 >= TopOfListBox(SourceForm.ListBoxFlowChart) Then Exit While
        End While

        While FlowChart_TableX1(SourceForm, IndexFlowChartX1 - 1) = FlowChart_TableX1(SourceForm, IndexFlowChart)
            IndexFlowChartX1 -= 1
        End While


        '    If BinarySearch4Index(Options.ListBoxVariables,IndexFlowChart ) > 0 Then Return False ' already in a net
        ' Already in a net 

        While IndexFlowChartX1 < TopOfListBox(SourceForm.ListBoxFlowChart) And FlowChart_TableX1(SourceForm, IndexFlowChartX1) <= FlowChart_TableX1(SourceForm, IndexFlowChart)
            I = IndexFlowChartX1
            If IndexFlowChart <> IndexFlowChartX1 Then
                Select Case LCase(FlowChart_TableCode(SourceForm, I))
                    Case "/path"
                        If IndexFlowChart <> I Then
                            CleanListOfNet_TableLinks(IndexFlowChart)
                            If MyInListOfNumbers(SourceForm, IndexFlowChart) = True Then
                                'log_X(1454,MyShowFlowChartRecord(SourceForm, true, IndexFlowChart),MyShowNetLinks(SourceForm, BinarySearch4Index(Options.ListBoxVariables,IndexFlowChart)))
                            Else
                                'Check The first point
                                If XY.x = FlowChart_TableX1(SourceForm, I) Then
                                    If XY.y = FlowChart_TableY1(SourceForm, I) Then
                                        CleanListOfNet_TableLinks(IndexFlowChart)
                                        ' Start new tree search
                                        If FindAllPaths(SourceForm, I, MyPoint1XY(FlowChart_TableX1(SourceForm, I), FlowChart_TableY1(SourceForm, I)), Pathname) = True Then
                                            If FindAllPaths(SourceForm, I, MyPoint2XY(FlowChart_TableX2(SourceForm, I), FlowChart_TableY2(SourceForm, I)), Pathname) = True Then

                                                Return True
                                            End If
                                        End If
                                    End If
                                End If
                                'Check The Second point
                                If XY.x = FlowChart_TableX2(SourceForm, I) Then
                                    If XY.y = FlowChart_TableY2(SourceForm, I) Then
                                        CleanListOfNet_TableLinks(IndexFlowChart)
                                        RouterConnectPaths(SourceForm, I, IndexFlowChart, Pathname)
                                        ' Start new tree search
                                        If FindAllPaths(SourceForm, I, MyPoint1XY(FlowChart_TableX1(SourceForm, I), FlowChart_TableY1(SourceForm, I)), Pathname) = True Then
                                            If FindAllPaths(SourceForm, I, MyPoint2XY(FlowChart_TableX2(SourceForm, I), FlowChart_TableY2(SourceForm, I)), Pathname) = True Then

                                                Return True
                                            End If
                                        End If
                                    End If
                                End If
                            End If
                        End If
                    Case My_keyWord(My_KeyConstUse)'ignore
                    Case "/error" 'ignore
                    Case "/Constant" 'ignore
                    Case Else
                        If MyDebug(A_INFORMATION) Then logA(1455, MyShowFlowChartRecord(SourceForm, True, I), MyShowFlowChartRecord(SourceForm, True, IndexFlowChart))
                End Select
            End If
            ''    FlowChart_TableCompiledMacroCodeText(IndexFlowChart, CleanListOfNets(IndexFlowChart ))
            CleanListOfNet_TableLinks(IndexFlowChart)
            IndexFlowChartX1 += 1
            If IndexFlowChartX1 <> MyMinMax(IndexFlowChartX1, 1, TopOfListBox(SourceForm.ListBoxFlowChart)) Then
                Exit While
            End If

            IndexFlowChartX1 = MyMinMax(IndexFlowChartX1, 1, TopOfListBox(SourceForm.ListBoxFlowChart))

            While IndexFlowChartX1 < TopOfListBox(SourceForm.ListBoxFlowChart)
                logA(1456, IndexFlowChartX1.ToString, MyShowFlowChartRecord(SourceForm, True, IndexFlowChartX1))
                IndexFlowChartX1 += 1
                If IndexFlowChartX1 > TopOfListBox(SourceForm.ListBoxFlowChart) Then Exit While
                If IndexFlowChartX1 <> MyMinMax(IndexFlowChartX1, 1, TopOfListBox(SourceForm.ListBoxFlowChart)) Then
                    IndexFlowChartX1 = MyMinMax(IndexFlowChartX1, 1, TopOfListBox(SourceForm.ListBoxFlowChart))
                End If
            End While

            If IndexFlowChartX1 <> MyMinMax(IndexFlowChartX1, 1, TopOfListBox(SourceForm.ListBoxFlowChart)) Then
                IndexFlowChartX1 = MyMinMax(IndexFlowChartX1, 1, TopOfListBox(SourceForm.ListBoxFlowChart))
            End If
        End While

        ' Got here cause this XY is not anywhere else 
        ''    FlowChart_TableCompiledMacroCodeText(IndexFlowChart, CleanListOfNets(IndexFlowChart ))
        CleanListOfNet_TableLinks(IndexFlowChart)
        'log_X(1457, MyShowFlowChartRecord(SourceForm, true, IndexFlowChart), Net_TableLinks(BinarySearch4Index(Options.ListBoxVariables,IndexFlowChart))) 
        Return True
    End Function




    Friend Sub FindAllPaths_2(ByRef SourceForm As Source, IndexFlowChart As Integer) ', PathName As String) ' This does find all paths()  but by name
        '@ Yes I know that it causes recursion loop that will never stop, I'll fix it later - Really I will
        ' Find all of the points to this location and return as a string of the index to that path
        Dim Index As Integer
        Dim JIndex As Integer
        Dim I As Integer

        If IndexFlowChart < 1 Then
            Return
        End If
        If IndexFlowChart > TopOfListBox(SourceForm.ListBoxFlowChart) Then Return
        If LCase(FlowChart_TableCode(SourceForm, IndexFlowChart)) <> "/path" Then Return

        ' I can speed it up later
        JIndex = IndexFlowChart

        While FlowChart_TablePathName(SourceForm, JIndex) <= FlowChart_TablePathName(SourceForm, IndexFlowChart)
            I = JIndex
            Select Case LCase(FlowChart_TableCode(SourceForm, Index))
                Case "/path"
                    If IndexFlowChart <> Index Then
                        CleanListOfNet_TableLinks(IndexFlowChart)
                        If MyInListOfNumbers(SourceForm, IndexFlowChart) = True Then
                            'log_X(1246, MyShowFlowChartRecord(SourceForm, true, IndexFlowChart))
                        Else
                            'Check The first point
                            If FlowChart_TablePathName(SourceForm, IndexFlowChart) = FlowChart_TablePathName(SourceForm, Index) Then
                                CleanListOfNet_TableLinks(IndexFlowChart)
                                '' FlowChart_TableCompiledMacroCodeText(IndexFlowChart, CleanListOfNets(IndexFlowChart ))
                                ' This name is not in the list of path links, so lets connect them together
                                If RouterMakePaths(SourceForm, IndexFlowChart, Index) = True Then
                                    If MyOptionTest(25) Then
                                    Else
                                    End If
                                Else
                                End If

                                'FLOW10' Causes recursion never ending 'MyShowAndUpDateProperties( SourceForm , Index)
                                PaintAll(SourceForm, IndexFlowChart, IndexFlowChart)
                                PaintAll(SourceForm, Index, Index)
                            End If
                        End If
                    End If
                    CleanListOfNet_TableLinks(IndexFlowChart)
                    ''        FlowChart_TableCompiledMacroCodeText(IndexFlowChart, CleanListOfNets(IndexFlowChart ))
                Case Else
                    Log(2087, Err0, MyShowFlowChartRecord(SourceForm, False, Index))
            End Select
            JIndex += 1

        End While

        ' Got here cause this XY is not anywhere else 
        'log_X(1248, "FindAllPaths_2", MyShowFlowChartRecord(SourceForm, true, IndexFlowChart))
    End Sub





    Friend Function NewFlowChartRecord(ByRef SourceForm As Source) As Integer
        NewFlowChartRecord = NewTopOfListBox(SourceForm.ListBoxFlowChart)
        FlowChart_tablePathSymbolName(SourceForm, NewFlowChartRecord, "?") ' just to make no errors 
    End Function



    ' returns true if the IndexFlowChart  is in the list of number in Symbol table data
    ' returns false if not, or issue
    Friend Function MyInListOfNumbers(ByRef SourceForm As Source, IndexFlowChart As Integer) As Boolean
        Dim Temp, Numbers As String
        Dim IndexNetLinks As Integer

        Numbers = ""
        Temp = FD & IndexFlowChart & FD 'create a string to search for - Make sure the comma before and after so that it only find the complete number
        'hack I think that this is not used this way anymore, but that it should be getting the net_links of a pointer from ?????
        'stop here, somehow it is return an index beyond the end of the _fileLinks 
        IndexNetLinks = FlowChart_Table(SourceForm, IndexFlowChart)
        'Check that the index is inside the netLinks bounds (If not then it is to be add as the next one.

        If IndexNetLinks > LBound(Net_FileLinks) Then
            If IndexNetLinks <= SourceForm.ListBoxVariables.count - 1 Then
                Numbers = Net_TableLinks(IndexNetLinks) ' indexNetLinks is a valid pointer to get the net link information
            Else
                logA(1463, IndexNetLinks.ToString, SourceForm.ListBoxVariables.count - 1.ToString)
                MakeNewNetLinks(SourceForm, IndexFlowChart, FlowChart_TablePathName(SourceForm, IndexFlowChart))
            End If
        ElseIf IndexNetLinks < SourceForm.ListBoxVariables.count - 1 Then
            Numbers = Net_TableLinks(IndexNetLinks)
        Else
            logA(1464, IndexNetLinks.ToString, SourceForm.ListBoxVariables.count - 1.ToString)
            Numbers = Net_TableLinks(IndexNetLinks)
        End If

        If MyInStr(Temp, Numbers) > 0 Then Return True

        ' We should never get here 
        'todo al of the above to get to here to  see if the IndexFlowChart  already exist in a net
        Temp = Numbers

        While Len(Temp) > 0
            If PopValue(Temp) = IndexFlowChart Then

                Return True
            End If
        End While

        Return False
    End Function



    ' This will return the index in NetLink() of this index
    Friend Function CleanListOfNet_TableLinks(IndexNetLinks As Integer) As Integer ' always return index to NetLinks
        Dim I, K As Integer
        Dim CleanList As String
        Dim MyList(1) As Integer

        If IndexNetLinks < 1 Then Return ConstantMyErrorCode
        If IndexNetLinks > SourceForm.ListBoxVariables.count - 1 Then
            ReDim Preserve Net_FileLinks()(IndexNetLinks + 1)
            ReDim Preserve Net_FilePathNames()(IndexNetLinks + 1)
        End If

        CleanList = Net_TableLinks(IndexNetLinks)

        MyList(1) = 0

        While Len(CleanList) > 0
            ReDim Preserve MyList(MySizeOf(MyList) + 1)
            K = PopValue(CleanList)
            If K <> 0 Then
                MyList(MySizeOf(MyList) - 1) = K
            End If
        End While


        For I = 1 To MySizeOf(MyList)
            If MyList(I) <> 0 Then ' Do not check not used /deleted numbers
                For K = I + 1 To MySizeOf(MyList)
                    If MyList(I) = MyList(K) Then
                        MyList(I) = 0 ' Delete the duplicate
                    End If
                Next K
            End If
        Next I




        For I = 1 To MySizeOf(MyList) - 1
            If MyList(I) <> 0 Then
                If CleanList = "" Then CleanList = FD 'changes to only have it if there is going to be something.
                CleanList = CleanList & MyList(I) & FD
            End If
        Next I


        If CleanList = "" Then
            If MyDebug(A_INFORMATION) Then logA(1466, Net_TableLinks(IndexNetLinks))
        End If
        Net_TableLinks(IndexNetLinks, CleanList) 'Update this path List
        Return IndexNetLinks
    End Function

    Friend Sub ChangeOptionsWindowSelectedIndex(LB As ListBox) 'T As listbox, WhatToSelect As String)
        Dim I As Integer

        I = BinarySearch4Index(Options.ListBoxColors, MyUniverse.ProgramOptions.SelectedColor)
        If I = ConstantMyErrorCode Then
            logA(1468, I.ToString, MyUniverse.ProgramOptions.SelectedColor)
            Return
        End If
        'MyUnEnum(Color_TableStyle(I), OptionsWindow.ComboBoxLineStyle, 2)

        'Error needs To be fixed
        'Temp=Color_TableStyle(I)

        '''''Options.ListboxPathLineStyle.Text = I.ToString 'Color_TableStyle(I)
        '''''Options.ListboxPathStart.Text = MyUnEnum(Options, Color_TableStartCap(I), Options.ListboxPathStart,)
        '''''Options.ListboxPathEnd.Text = MyUnEnum(LB, Color_TableEndCap(I), Options.ListboxPathEnd, 1)

    End Sub



    'The following is to preview and print pages
    ' DIM   objCallback As System.Drawing.Image.GetThumbnailImageAbort=New System.Drawing.Image.GetThumbnailImageAbort(AddressOf ThumbnailCallback)
    'Private Sub Button1_Click(ByVal sender As System.Object, ByVal e As System.Event Arguments ) Handles Button1.Click
    ' DIM   printer As PrintDocument=New PrintDocument
    ' AddHandler() printer.PrintPage, AddressOf PrintImage
    'printer.Print()
    'End Sub


    'Private Sub PrintImage(ByVal sender As Object, ByVal e As PrintPageEvent Arguments )
    ' DIM   img As Image=PictureBox1.Image
    'img=img.GetThumbnailImage(300, 300, objCallback, IntPtr.Zero)
    'e.Graphics.DrawImage(img, 0, 0)
    'End Sub
    'Function ThumbnailCallback() As Boolean
    'Return false
    'End Function
    ' Another Example to print @



    'Public Sub printImage()
    ' DIM   objPrint As New PrintDocument
    ' AddHandler() objPrint.PrintPage, AddressOf PrintImage_PrintPage
    '    objPrint.Print()
    'End Sub


    'Private Sub PrintImage_PrintPage(ByVal sender As Object, ByVal e As PrintPageEvent A r g s )
    '    e.Graphics.DrawImage(PictureBox1.Image, 0, 0, PictureBox1.Width, PictureBox1.Height)
    'End Sub


    'This will become done on a timer
    Friend Function RouterTicked(ByRef SourceForm As Source) As Boolean
        Dim I As Integer

        logA(2345, "Router Ticked ")
        Debug.Write("a")
        Timer_MoveNextSymbol(SourceForm, TimerIndexFlowChartCounter)
        Debug.Write("b")
        If Timer_MoveNextPath(SourceForm, TimerIndexFlowChartCounter) = True Then
            Debug.Write("c")
            If ROUTER_Timer_Re_NextPath(SourceForm, TimerIndexFlowChartCounter) = True Then
                Debug.Write("d")
                If MyOptionTest(25) Then
                Else
                End If
            Else
            End If
            Debug.Write("e")
        End If
        TimerIndexFlowChartCounter += 1
        If TimerIndexFlowChartCounter > TopOfListBox(SourceForm.ListBoxFlowChart) Then
            TimerIndexFlowChartCounter = 1
            Debug.Write("f")
        End If

        For I = 1 To SourceForm.ListBoxVariables.count - 1
            If FlowChart_TableCode(SourceForm, I) = "/path" Then
                ROUTERNetIndex(SourceForm, I)
            End If
        Next




        Return True
    End Function ' RouterTicked return true always (for now)



    Friend Sub TimerTicked(sender As Object, e As EventArgs)
        '''''DoEvent(69, "TimerTicked") ' required always
        '''''Timer_MoveNextSymbol(FlowChart2025A.Source.FlowChartPictureBox, TimerIndexFlowChartCounter)
        '''''If Timer_MoveNextPath(FlowChart2025A.Source.FlowChartPictureBox, TimerIndexFlowChartCounter) = True Then
        '''''If ROUTER_Timer_Re_NextPath(FlowChart2025A.Source.FlowChartPictureBox, TimerIndexFlowChartCounter) = True Then
        '''''If MyOptionTest(25) Then
        '''''Else
        '''''End If
        '''''Else
        '''''End If
        '''''End If
        '''''TimerIndexFlowChartCounter += 1
        '''''If TimerIndexFlowChartCounter > TopOfListBox(SourceForm.ListBoxFlowChart) Then
        '''''TimerIndexFlowChartCounter = 0
        '''''End If
    End Sub

    Friend Sub Timer_MoveNextSymbol(ByRef SourceForm As Source, LocalIndex As Integer) ' always get the next to work on
        Dim JIndex As Integer


        LocalIndex = MyMinMax(LocalIndex, 1, TopOfListBox(SourceForm.ListBoxFlowChart))
        If FlowChart_TableCode(SourceForm, LocalIndex) <> My_keyWord(My_KeyConstUse) Then Return ' cause we only want to work on Symbol right now.

        For JIndex = LocalIndex + 1 To TopOfListBox(SourceForm.ListBoxFlowChart)
            If FlowChart_TableCode(SourceForm, LocalIndex) = My_keyWord(My_KeyConstUse) Then
                If SymbolOnTopOfSymbol(SourceForm, LocalIndex, JIndex) = True Then
                    'move one of the Symbols
                    MoveSymbolAndAllPaths(SourceForm, LocalIndex, MyPoint1XY(MyUniverse.SysGen.Constants.ConstantSymbolCenter + MyUniverse.SysGen.Constants.ConstantSymbolCenter, 0)) ' move over in the X the distance of this
                    ' Of course it will make it land on another one, but 
                End If
            End If
        Next JIndex

    End Sub
    Friend Function Timer_MoveNextPath(ByRef SourceForm As Source, LocalIndex As Integer) As Boolean
        Dim JIndex As Integer
        Dim Line1, Line2 As MyLineStructure
        'Timer_MoveNextPath = False
        LocalIndex = MyMinMax(LocalIndex, 1, TopOfListBox(SourceForm.ListBoxFlowChart))
        'DoEvent(194)
        If LocalIndex < 1 Then Return False
        If FlowChart_TableCode(SourceForm, LocalIndex) <> "/path" Then
            logA(1190, LocalIndex.ToString, MyShowFlowChartRecord(SourceForm, False, LocalIndex))
            Return False ' cause we only want to work on paths right now
        End If
        'DoEvent(195)

        For JIndex = LocalIndex + 1 To TopOfListBox(SourceForm.ListBoxFlowChart)
            'DoEvent(196)
            If FlowChart_TableCode(SourceForm, LocalIndex) = "/path" Then
                Line1 = MyLine1(SourceForm, LocalIndex)
                Line2 = MyLine1(SourceForm, JIndex)
                'Clear_Window_Only( SourceForm )
                If MyOptionTest(34) Then
                    PanToWorldXY(SourceForm, FlowChart_TableX1(SourceForm, LocalIndex), FlowChart_TableY1(SourceForm, LocalIndex))
                    'Clear_Window( SourceForm )
                    MyReSizeWorld(SourceForm, Line1)
                    MyReSizeWorld(SourceForm, Line2)
                End If

                If PathOnTopHere(SourceForm, Line1, Line2) = True Then
                    'move one of the Symbols
                    'Timer_MoveNextPath = True
                    ' Move it nex if true
                    'MoveSymbolAndAllPaths( SourceForm , LocalIndex, MyPoint1XY( MyUniverse.SysGen.Constants.ConstantSymbolCenter + MyUniverse.SysGen.Constants.ConstantSymbolCenter / 2, 0)) ' move over in the X the distance of this
                    ' Of course it will make it land on another one, but 
                End If
                'DoEvent(197)
            End If
        Next JIndex

        'DoEvent(198)
        Return True
    End Function


    'check to make sure that nothing is on top of each other (causes flowchart to not look like it should act
    Friend Function ROUTER_Timer_Re_NextPath(ByRef SourceForm As Source, LocalIndex As Integer) As Boolean
        Dim RTN As Boolean
        DoEvent(70, "Route Next Path ")

        If FMBRecurse("ROUTER_Timer_Re_NextPath") > 8 Then

            Return False
        End If
        LocalIndex = MyMinMax(LocalIndex, 1, TopOfListBox(SourceForm.ListBoxFlowChart))
        logA(2345, "Router timer re next path  ", MyShowFlowChartRecord(SourceForm, False, LocalIndex))
        If FlowChart_TableCode(SourceForm, LocalIndex) <> "/path" Then Return False ' cause we only want to work on paths right now
        RTN = MoveSymbolAndAllPaths(SourceForm, LocalIndex, MyPoint1XY(MyUniverse.SysGen.Constants.ConstantSymbolCenter, 0)) ' move over in the X the distance of this

        Return RTN
    End Function 'returns false if it can not move symbol or paths that are on top of each other 



    Friend Function Net_TablePathNames(IndexNet As Integer) As String
        If IndexNet < LBound(Net_FilePathNames) Or IndexNet > MySizeOf(Net_FilePathNames) Then Return Nothing 'Need to show an error 
        Return Net_FilePathNames(IndexNet)
    End Function
    Friend Sub Net_TablePathNames(IndexNet As Integer, Value As String)
        If IndexNet < 0 Or IndexNet > MySizeOf(Net_FilePathNames) Then Return 'Need to show an error 
        Net_FilePathNames(IndexNet) = Value
    End Sub


    Friend Function Net_TableLinks(Index As Integer) As String
        If Index < 1 Or Index > SourceForm.ListBoxVariables.count - 1 Then Return Nothing 'Need to show an error 
        Return Net_FileLinks(Index)
    End Function
    Friend Sub Net_TableLinks(Index As Integer, Value As String)
        If Index < 1 Or Index > SourceForm.ListBoxVariables.count - 1 Then Return 'Need to show an error 
        Net_FileLinks(Index) = Value
    End Sub






    ' This is to isolate the actual data from the program (So that it can be converted later versions)
    Friend Function Named_TableSymbolName(Index As Integer) As String
        Named_TableSymbolName = Named_FileSymbolName(Index)
    End Function

    Friend Sub Named_TableSymbolName(Index As Integer, Value As String)
        Named_FileSymbolName(Index) = Value
    End Sub


    ' This is to isolate the actual data from the program (So that it can be converted later versions)
    Friend Function Named_TableMicroCodeText(Index As Integer) As String
        Named_TableMicroCodeText = Named_FileMicroCodeText(Index)
    End Function

    Friend Sub Named_TableMicroCodeText(Index As Integer, Value As String)
        If Len(Value) = 0 Then
            logA(1320, Value)
        End If
        Named_FileMicroCodeText(Index) = Value
    End Sub


    ' This is to isolate the actual data from the program (So that it can be converted later versions)
    Friend Function Named_TableOpCode(Index As Integer) As String
        Named_TableOpCode = Named_FileOpCode(Index)
    End Function

    Friend Sub Named_TableOpCode(Index As Integer, Value As String)
        Named_FileOpCode(Index) = Value
    End Sub


    ' This is to isolate the actual data from the program (So that it can be converted later versions)
    Friend Function Named_TableSymbolIndexes(Index As Integer) As Integer 'Show the index of the first graphics record
        Named_TableSymbolIndexes = Named_FileSymbolIndexes(Index)
    End Function



    Friend Sub Named_TableSymbolIndexes(Index As Integer, value As Integer)
        'todo, if the point has change that means that more 'might' have also change, so all needs to be fixed
        If Named_FileSymbolIndexes(Index) <> value And Named_FileSymbolIndexes(Index) <> 0 Then
            logA(2763, Named_FileSymbolIndexes(Index).ToString, value.ToString)
        End If
        Named_FileSymbolIndexes(Index) = value
    End Sub


    ' This is to isolate the actual data from the program (So that it can be converted later versions)
    Friend Function Named_TableStroke(Index As Integer) As String
        Named_TableStroke = Named_FileStroke(Index)
    End Function



    Friend Sub Named_TableStroke(Index As Integer, Value As String)
        Named_FileStroke(Index) = Value
    End Sub


    ' This is to isolate the actual data from the program (So that it can be converted later versions)
    Friend Function Named_TableNameOfFile(Index As Integer) As String
        Named_TableNameOfFile = Named_FileNameOfFile(Index)
    End Function


    Friend Sub Named_TableNameOfFile(Index As Integer, Value As String)
        Named_FileNameOfFile(Index) = Value
    End Sub


    ' This is to isolate the actual data from the program (So that it can be converted later versions)
    Friend Function Named_TableNotes(Index As Integer) As String
        Named_TableNotes = Named_FileNotes(Index)
    End Function

    Friend Sub Named_TableNotes(Index As Integer, Value As String)
        Named_FileNotes(Index) = Value
    End Sub

    Friend Function Named_TableDescription(Index As Integer) As String
        Named_TableDescription = Named_FileDescription(Index)
    End Function

    Friend Sub Named_TableDescription(Index As Integer, Value As String)
        Named_FileDescription(Index) = Value
    End Sub


    ' This is to isolate the actual data from the program (So that it can be converted later versions)
    Friend Function Named_TableAuthor(Index As Integer) As String
        Named_TableAuthor = Named_FileAuthor(Index)
    End Function


    Friend Sub Named_TableAuthor(Index As Integer, Value As String)
        Named_FileAuthor(Index) = Value
    End Sub


    ' This is to isolate the actual data from the program (So that it can be converted later versions)
    Friend Function Named_TableVersion(Index As Integer) As String
        Named_TableVersion = Named_FileVersion(Index)
    End Function


    Friend Sub Named_TableVersion(Index As Integer, Value As String)
        Named_FileVersion(Index) = Value
    End Sub


    ' This is to isolate the actual data from the program (So that it can be converted later versions)
    Friend Function Named_TableSyntax(Index As Integer) As String
        Named_TableSyntax = Named_FileSyntax(Index)
    End Function


    Friend Sub Named_TableSyntax(Index As Integer, Value As String)
        If Len(Value) = 0 Then
            logA(1384, Value)
        End If
        Named_FileSyntax(Index) = Value
    End Sub

    Friend Function FindInputOutputIndex(InputOutputName As String) As Integer
        Dim I As Integer
        Dim Temp As String

        For I = 0 To Options.ListBoxInputOutput.Items.Count - 1
            Temp = Options.ListBoxInputOutput.Items.Item(I).ToString
            If MyStrComp(InputOutputName, Pop(Temp, MyUniverse.SysGen.Constants.ConstantDelimiters)) = 0 Then

                Return I
            End If
        Next

        Return ConstantMyErrorCode
    End Function

    Friend Function FindDataTypeIndex(DataTypeName As String) As Integer
        Return BinarySearch4Index(Options.ListBoxDataTypes, DataTypeName)
    End Function

    Friend Function FindColorIndexFromName(ColorName As String) As Integer
        Return BinarySearch4Index(Options.ListBoxColors, ColorName)
    End Function

    Friend Function FindColorFromDataType(DataTypeName As String) As String
        If Len(DataTypeName) = 0 Then
            Return Nothing
        End If
        Return Color_TableName(DataType_TableColorIndex(FindDataTypeIndex(DataTypeName)))
    End Function


    Friend Function FindWidthFromDataType(ByRef SourceForm As Source, DataTypeName As String) As Integer
        Dim I2 As Integer
        Dim LocalIndex, KIndex, JIndex As Integer
        Dim ErrorCount As Integer

        If Len(DataTypeName) < 1 Then
            RandomColor(SourceForm) 'update the last random color
            Return 2 'todo this is an error and should ... 
        End If

        KIndex = TopOfFile(SourceForm, "DataType")
        LocalIndex = CInt(KIndex / 2)
        JIndex = CInt((LocalIndex - 4) / 2)
        ErrorCount = 2048
        FindWidthFromDataType = 0

        While ErrorCount > 0
            ErrorCount -= 1
            Select Case MyCompared3("DataType", DataType_TableName((LocalIndex)), DataTypeName, DataType_TableName((LocalIndex + 1)))
                Case -5 ' Test 9 A > C unsorted list error
                    logA(1503, DataType_TableName((LocalIndex)), DataTypeName, DataType_TableName((LocalIndex + 1)))
                    FindWidthFromDataType = 1 'default min DataType/Line width
                    LocalIndex -= JIndex
                Case -4 'Test 5 & 7  both A=nothing and b=c then only A=nothing
                    FindWidthFromDataType = 0
                    'todo should this one be + or -?
                    LocalIndex += 1
                Case -3 'test 11 A is higher than B  and C=nothing
                    FindWidthFromDataType = 1 'default min DataType/Line width
                    LocalIndex -= JIndex
                Case -2 'test 12  b>C
                    FindWidthFromDataType = 1 'default min DataType/Line width
                    LocalIndex += JIndex
                Case -1 'Test 3 -> A=b

                    Return DataType_TableWidth(LocalIndex)
                Case 0 'Test 2 & 10 A and C are both null or nothing then A<b<C not in list
                    FindWidthFromDataType = 0
                    Exit While
                Case 1 'Test 4 -> b=C so move forward just one.
                    FindWidthFromDataType = DataType_TableWidth(LocalIndex)
                    LocalIndex += 1
                Case 2 'test 14 A<b
                    FindWidthFromDataType = DataType_TableWidth(LocalIndex)
                    LocalIndex += JIndex
                Case 3 'test 13 b < C
                    FindWidthFromDataType = DataType_TableWidth(LocalIndex)
                    LocalIndex += JIndex
                Case 4 'test 6 & 8 ->>> C is nothing and b > A then C=nothing
                    FindWidthFromDataType = 0
                    Exit While
                Case 5 'Test 1 & 15 -> b=nothing then no other test works (Error)
                    logA(1504, DataType_TableName((LocalIndex)), DataTypeName, DataType_TableName((LocalIndex + 1)))

                    Return 1
            End Select
            If LocalIndex = 0 And JIndex = 1 Then Exit While
            LocalIndex = MyMinMax(LocalIndex, 1, KIndex)
            JIndex = MyMinMax(CInt(JIndex / 2), 1, KIndex)
        End While


        For I2 = 1 To TopOfFile(SourceForm, "DataType")
            If MyStrComp(DataTypeName, DataType_TableName(I2)) = 0 Then
                logA(1505, DataTypeName)
                Return DataType_TableWidth(I2)
            End If
        Next

    End Function


    'returns if the colors have changed.

    'todo this routine needs to NOT use get pen() but instead just the ARGB value to compare
    Friend Function TestIfColorStandardMicroSoftColorName_Unused(ByRef SourceForm As Source, IndexColor As Integer) As Integer
        Dim I As Integer
        Dim R1, R2, G1, G2, B1, B2, A1, A2, LastIndex As Integer
        Dim LastDistance, Distance As Int64
        Dim ThisPen, ThatPen As Pen


        If Len(Color_TableName(IndexColor)) = 0 Then Return ConstantMyErrorCode
        '?LastIndex=LBound(Color_FileName)
        ThisPen = MyGetPen(SourceForm, Color_TableName(IndexColor), "")

        If ThisPen.Color.Name = Color_TableName(IndexColor) Then Return IndexColor
        ThatPen = MyGetPen(SourceForm, Color_TableName(IndexColor), "")
        'todo if this color matches then we do not need to find the closest

        R1 = ThisPen.Color.R
        G1 = ThisPen.Color.G
        B1 = ThisPen.Color.B
        A1 = ThisPen.Color.A
        ' go through all of the pens to see if this one is there.

        LastDistance = 32000
        LastIndex = 1


        For I = 1 To Options.ListBoxColors.Items.Count
            If Len(Options.ListBoxColors.Items(I).ToString) <> 0 Then
                ThatPen = MyGetPen(SourceForm, Color_TableName(I), "")
                'Th color is unknown so find the closest
                ' go through all of the pens to see if this one is there.
                R2 = ThatPen.Color.R
                G2 = ThatPen.Color.G
                B2 = ThatPen.Color.B
                A2 = ThatPen.Color.A
                Distance = MyABS64(R1 - R2)
                Distance += MyABS64(G1 - G2)
                Distance += MyABS64(B1 - B2)
                Distance += MyABS64(A1 - A2)
                If Distance < LastDistance Then
                    LastIndex = I
                    LastDistance = Distance
                End If
                If ThatPen.Color.Name = ThisPen.Color.Name Then
                    ThatPen.Dispose()
                    ThisPen.Dispose()

                    Return I ' names match
                End If
                ThatPen.Dispose()
            End If
        Next

        'This is the closest they come
        ThatPen.Dispose()
        ThisPen.Dispose()
        Return LastIndex
    End Function






    'Find the closest color to match to this color RGB
    Friend Function FindAColorName(ByRef SourceForm As Source, Red As Integer, Green As Integer, Blue As Integer) As String
        Dim I As Integer
        Dim R, G, B As Integer
        Dim Distance As Integer
        Dim LastDistance, LastIndex As Integer
        Dim debug1 As String
        LastDistance = 255 * 4
        LastIndex = 0

        For I = 1 To TopOfFile(SourceForm, "color")
            '''''ShowProgressBar(1, I, TopOfFile(SourceForm, "Color"))
            R = Color_TableRed(I)
            G = Color_TableGreen(I)
            B = Color_TableBlue(I)
            Distance = MyABS(Red - R) + MyABS(Green - G) + MyABS(Blue - B)
            If LastDistance > Distance Then
                LastIndex = I
                debug1 = Color_TableName(LastIndex)
                LastDistance = Distance
            End If
        Next

        Return Color_TableName(LastIndex)
    End Function


    ' This is to isolate the actual data from the program (So that it can be converted later versions)
    Friend Function Color_TableName(Index As Integer) As String
        Return GetMyField(Options.ListBoxColors, "color:Name", Index)
    End Function
    Friend Sub Color_TableName(Index As Integer, Value As String)
        SetMyField(Options.ListBoxColors, "color:Name", Index, Value)
    End Sub
    Friend Function Color_TableStartCap(Index As Integer) As Integer
        Return My_INT(GetMyField(Options.ListBoxColors, "color:Start", Index))
    End Function
    Friend Function Color_TableStyle(Index As Integer) As Drawing2D.DashStyle
        Select Case My_INT(MyUnEnum(Options.ListboxPathLineStyle, Options.ListboxPathLineStyle.Items(Index).ToString, 1))
            Case 0
                Return Drawing2D.DashStyle.Solid
            Case 1
                Return Drawing2D.DashStyle.Dash
            Case 2
                Return Drawing2D.DashStyle.DashDot
            Case 3
                Return Drawing2D.DashStyle.DashDotDot
            Case 4
                Return Drawing2D.DashStyle.Dot
            Case Else
                Return Drawing2D.DashStyle.Solid
        End Select
    End Function

    Friend Function Color_TableAlpha(Index As Integer) As Integer
        Return My_INT(GetMyField(Options.ListBoxColors, "color:Alpha", Index))
    End Function
    Friend Function Color_TableRed(Index As Integer) As Integer
        Return My_INT(GetMyField(Options.ListBoxColors, "color:red", Index))
    End Function
    Friend Function Color_TableGreen(Index As Integer) As Integer
        Return My_INT(GetMyField(Options.ListBoxColors, "color:Green", Index))
    End Function
    Friend Function Color_TableBlue(Index As Integer) As Integer
        Return My_INT(GetMyField(Options.ListBoxColors, "color:blue", Index))
    End Function
    Friend Sub Color_TableStartCap(Index As Integer, value As Integer)
        SetMyField(Options.ListBoxColors, "color:Start", Index, MyMinMax(value, 0, 255).ToString)
    End Sub


    ' This is to isolate the actual data from the program (So that it can be converted later versions)
    Friend Sub Color_TableEndCap(Index As Integer, value As Integer)
        SetMyField(Options.ListBoxColors, "color:end", Index, MyMinMax(value, 0, 255).ToString)
    End Sub
    Friend Sub Color_TableStyle(Index As Integer, value As Integer)
        SetMyField(Options.ListBoxColors, "color:Style", Index, MyMinMax(value, 0, 255).ToString)
    End Sub
    Friend Sub Color_TableAlpha(Index As Integer, Value As Integer)
        SetMyField(Options.ListBoxColors, "color:alpha", Index, MyMinMax(Value, 0, 255).ToString)
    End Sub
    Friend Sub Color_TableRed(Index As Integer, Value As Integer)
        SetMyField(Options.ListBoxColors, "color:Red", Index, MyMinMax(Value, 0, 255).ToString)
    End Sub
    Friend Sub Color_TableGreen(Index As Integer, Value As Integer)
        SetMyField(Options.ListBoxColors, "color:Green", Index, MyMinMax(Value, 0, 255).ToString)
    End Sub
    Friend Sub Color_TableBlue(Index As Integer, Value As Integer)
        SetMyField(Options.ListBoxColors, "color:Blue", Index, MyMinMax(Value, 0, 255).ToString)
    End Sub





    Friend Sub Symbol_TableCode(ByRef SourceForm As Source, IndexSymbol As Integer, value As Integer)
        Symbol_FileCoded(IndexSymbol) = value
    End Sub



    ' This is to isolate the actual data from the program (So that it can be converted later versions)
    Friend Sub Symbol_TableCode(ByRef SourceForm As Source, Index As Integer, value As String)
        Symbol_FileCoded(Index) = MyKeyword2Number(value)
    End Sub



    ' This is to isolate the actual data from the program (So that it can be converted later versions)
    Friend Function Symbol_TableSymbolName(Index As Integer) As String
        Symbol_TableSymbolName = Symbol_FileSymbolName(Index)
    End Function




    ' This is to isolate the actual data from the program (So that it can be converted later versions)
    Friend Sub Symbol_TableSymbolName(Index As Integer, value As String)
        Symbol_FileSymbolName(Index) = value
    End Sub


    ' This is to isolate the actual data from the program (So that it can be converted later versions)
    Friend Function Symbol_TableCoded_String(Index As Integer) As String
        Symbol_TableCoded_String = MyKeyword2String(Symbol_FileCoded(Index))
    End Function



    ' This is to isolate the actual data from the program (So that it can be converted later versions)
    Friend Function Symbol_TableCoded_Byte(Index As Integer) As Integer
        Symbol_TableCoded_Byte = Symbol_FileCoded(Index)
    End Function



    ' This is to isolate the actual data from the program (So that it can be converted later versions)
    Friend Function Symbol_TableX1(Index As Integer) As Integer
        Symbol_TableX1 = Symbol_FileX1(Index)
    End Function



    ' This is to isolate the actual data from the program (So that it can be converted later versions)
    Friend Sub Symbol_TableX1(Index As Integer, value As Integer)
        Symbol_FileX1(Index) = value
    End Sub



    ' This is to isolate the actual data from the program (So that it can be converted later versions)
    Friend Function Symbol_TableY1(Index As Integer) As Integer
        Symbol_TableY1 = Symbol_FileY1(Index)
    End Function



    ' This is to isolate the actual data from the program (So that it can be converted later versions)
    Friend Sub Symbol_TableY1(Index As Integer, value As Integer)
        Symbol_FileY1(Index) = value
    End Sub



    ' This is to isolate the actual data from the program (So that it can be converted later versions)
    Friend Function Symbol_Table_X2(Index As Integer) As Integer
        If Symbol_FileX2_io(Index).MyNumber = -1 And Symbol_FileX2_io(Index).MyString = "" Then
            Return -1 'todo debug this is to catch the problem
        End If
        Symbol_Table_X2 = Symbol_FileX2_io(Index).MyNumber
    End Function


    Friend Function Symbol_Table_InputOutput(Index As Integer) As String
        If MyIsNothing(Symbol_FileX2_io(Index).MyString) = True Then
            If Symbol_FileX2_io(Index).MyNumber >= 0 Then
                If Symbol_FileX2_io(Index).MyNumber < Options.ListBoxInputOutput.Items.Count Then
                    Return Pop(Trim(Options.ListBoxInputOutput.Items.Item(Symbol_FileX2_io(Index).MyNumber).ToString), FD)
                Else
                    Return "Both" 'todo there are errors all over the place with this routine.  
                End If
            Else
                Return "Both" 'default
            End If
        Else
            Return Symbol_FileX2_io(Index).MyString
        End If
    End Function



    ' This is to isolate the actually data from the program (So that it can be converted later versions)
    Friend Sub Symbol_Table_X2(Index As Integer, value As Integer)
        Symbol_FileX2_io(Index).MyNumber = value
    End Sub



    ' This is to isolate the actual data from the program (So that it can be converted later versions)
    Friend Sub Symbol_Table_InputOutput(Index As Integer, value As String)
        Symbol_FileX2_io(Index).MyString = value
    End Sub



    ' This is to isolate the actual data from the program (So that it can be converted later versions)
    Friend Function Symbol_Table_Y2(Index As Integer) As Integer
        Return Symbol_FileY2_dt(Index).MyNumber
    End Function

    Friend Function Symbol_Table_DataType(Index As Integer) As String
        If Symbol_TableCoded_String(Index) = "/Line" Then 'Lines do not have DataTypes
            Return ""
        End If
        If MyIsNothing(Symbol_FileY2_dt(Index).MyString) = True Then
            If Symbol_FileY2_dt(Index).MyNumber >= 0 Then
                If Symbol_FileY2_dt(Index).MyNumber = 0 Then
                    Return "" 'todo check this no string, and zero index (which is invalid?)
                ElseIf Symbol_FileY2_dt(Index).MyNumber < 0 Then
                    Return Symbol_FileY2_dt(Index).MyNumber.ToString
                ElseIf Symbol_FileY2_dt(Index).MyNumber <= Options.ListBoxDataTypes.Items.Count Then
                    Symbol_Table_DataType(Symbol_FileY2_dt(Index).MyNumber, DataType_TableName(Symbol_FileY2_dt(Index).MyNumber)) 'todo fix the data type to 
                    Return DataType_TableName(Symbol_FileY2_dt(Index).MyNumber)
                ElseIf Symbol_FileY2_dt(Index).MyNumber < Options.ListBoxDataTypes.Items.Count Then
                    If MyDebug(A_INFORMATION) Then
                        logA(2175, Options.ListBoxDataTypes.Items.Item(Symbol_FileY2_dt(Index).MyNumber).ToString, Trim(Pop(Options.ListBoxDataTypes.Items.Item(Symbol_FileY2_dt(Index).MyNumber).ToString, FD)))
                    End If
                    Return Trim(Pop(Options.ListBoxDataTypes.Items.Item(Symbol_FileY2_dt(Index).MyNumber).ToString, FD))
                Else
                    'log_X(2177, MyShowSymbolGraphic(False, Index))
                    Return CStr(Symbol_FileY2_dt(Index).MyNumber)
                End If
            Else
                Return "Logic" 'default
            End If
        Else
            Return Symbol_FileY2_dt(Index).MyString
        End If
    End Function





    ' This is to isolate the actual data from the program (So that it can be converted later versions)
    Friend Sub Symbol_Table_Y2(Index As Integer, value As Integer)
        Symbol_FileY2_dt(Index).MyNumber = value
    End Sub



    Friend Function Symbol_Table_LineColor(Index As Integer) As String
        Return Symbol_File_NameOfPoint(Index)
    End Function


    Friend Sub Symbol_Table_LineColor(IndexSymbol As Integer, Value As String)
        If Symbol_TableCoded_String(IndexSymbol) <> "/Line" Then
            logA(2723, IndexSymbol.ToString, Symbol_TableCoded_String(IndexSymbol))
            Return
        End If

        If BinarySearch4Index(Options.ListBoxColors, Value) < 0 Then
            If Len(Value) <> 0 Then
                logA(1551, Value)
                If MyOptionTest(25) = True Then
                    AddInTable(Options.ListBoxColors, Value)
                Else
                    AddInTable(Options.ListBoxColors, "black")
                End If
            End If
        End If
        Symbol_Table_NameOfPoint(IndexSymbol, Value) 'Save the number of the index into the Y of this Symbol record (/point)
    End Sub





    ' This is to isolate the actual data from the program (So that it can be converted later versions)
    Friend Sub Symbol_Table_DataType(IndexSymbol As Integer, Value As String) ' Assumed DataType if passing a string
        Dim LocalIndex As Integer
        If Symbol_TableCoded_String(IndexSymbol) = "/Line" Then
            logA(2720, Symbol_Table_Y2(IndexSymbol).ToString, Value)
            Return
        End If
        LocalIndex = BinarySearch4Index(Options.ListBoxDataTypes, Value)
        If LocalIndex < 0 Then
            If Len(Value) = 0 Then
                LocalIndex = 0
            Else
                logA(4329, MyUniverse.MyStaticData.LastDataType)
                BinarySearch4Index(Options.ListBoxDataTypes, "Errored")
                logA(1551, Value)
                If MyOptionTest(25) = True Then
                    LocalIndex = AddInTable(Options.ListBoxDataTypes, Value)
                Else
                    logA(4330, MyUniverse.MyStaticData.LastDataType)
                    LocalIndex = BinarySearch4Index(Options.ListBoxColors, "Errored")
                End If
            End If
        End If
        Symbol_Table_Y2(IndexSymbol, LocalIndex) 'Save the number of the index into the Y of this Symbol record (/point)
    End Sub


    ' This is to isolate the actual data from the program (So that it can be converted later versions)
    Friend Function Symbol_Table_NameOfPoint(Index As Integer) As String
        Symbol_Table_NameOfPoint = Symbol_File_NameOfPoint(Index)
        If Symbol_Table_NameOfPoint = FD Then 'Symbol_Table_NameOfPoint="" Or Symbol_Table_NameOfPoint=FD Then
            Symbol_File_NameOfPoint(Index) = "Comma_Point_Name_Replaced_" & MyRnd(4)
            Return Symbol_File_NameOfPoint(Index) 'A COMMA IS INVALID AS A POINT NAME Symbol_File_NameOfPoint(Index)
        End If
    End Function


    ' This is to isolate the actual data from the program (So that it can be converted later versions)
    Friend Sub Symbol_Table_NameOfPoint(IndexSymbol As Integer, value As String)
        Symbol_File_NameOfPoint(IndexSymbol) = value
    End Sub



    ' This is to isolate the actual data from the program (So that it can be converted later versions)
    Friend Function FlowChart_TableCode(ByRef SourceForm As Source, IndexFlowChart As Integer) As String
        FlowChart_TableCode = MyKeyword2String(FlowChart_tableCoded(SourceForm, IndexFlowChart))
    End Function 'FlowChart_TableCode


    ' This is to isolate the actual data from the program (So that it can be converted later versions)
    'converts it from a string (name or number passed as a string) to save.
    Friend Sub FlowChart_TableCode(ByRef SourceForm As Source, IndexFlowChart As Integer, Value As String)
        Select Case LCase(Value)
            Case "/use", "5"
                FlowChart_tableCoded(SourceForm, IndexFlowChart, 5)
            Case "/path", "6"
                FlowChart_tableCoded(SourceForm, IndexFlowChart, 6)
            Case "/delete", "14"
                FlowChart_tableCoded(SourceForm, IndexFlowChart, 14)
            Case "/Constant", "15"
                FlowChart_tableCoded(SourceForm, IndexFlowChart, 15)
            Case "/error", "13"
                FlowChart_tableCoded(SourceForm, IndexFlowChart, 13)
            Case "/raw", "28"
                FlowChart_tableCoded(SourceForm, IndexFlowChart, 28)
            Case Else
                FlowChart_tableCoded(SourceForm, IndexFlowChart, 0) 'unknown
                logA(1556, Value)
        End Select
    End Sub


    ' This is to isolate the actual data from the program (So that it can be converted later versions)
    Friend Function FlowChart_TableSymbol_Name(ByRef SourceForm As Source, IndexFlowChart As Integer) As String
        Return FlowChart_Table_Path_SymbolName(SourceForm, IndexFlowChart)
    End Function 'FlowChart_TableSymbol_Name



    Friend Sub FlowChart_TableOther_Name(ByRef SourceForm As Source, IndexFlowChart As Integer, value As String)
        FlowChart_tablePathSymbolName(SourceForm, IndexFlowChart, value)
    End Sub


    Friend Function FlowChart_TableOther_Name(ByRef SourceForm As Source, IndexFlowChart As Integer) As String
        Return FlowChart_tablePathSymbolName(SourceForm, IndexFlowChart)
    End Function

    Friend Function FlowChart_Table_Path_SymbolName(ByRef SourceForm As Source, IndexFlowChart As Integer) As String
        FlowChart_Table_Path_SymbolName = FlowChart_tablePathSymbolName(SourceForm, IndexFlowChart)
        'todo need to check that a FD is not inside a quote, or BLOCK
        If MyInStr(FD, FlowChart_Table_Path_SymbolName) <> 0 Then
            If MyDebug(A_DISPLAY) Then logA(1417, IndexFlowChart.ToString, FlowChart_Table_Path_SymbolName)
            If MyOptionTest(25) Then
                FlowChart_Table_Path_SymbolName = FlowChart_Table_Path_SymbolName.Replace(FD, VBSpace)
            Else
                FlowChart_Table_Path_SymbolName = FlowChart_Table_Path_SymbolName.Replace(FD, VBSpace)
            End If
        End If
    End Function 'FlowChart_Table_Path_SymbolName



    ' This is to isolate the actual data from the program (So that it can be converted later versions)




    ' This is to isolate the actual data from the program (So that it can be converted later versions)
    Friend Function FlowChart_TablePathNumber(ByRef SourceForm As Source, IndexFlowChart As Integer) As Integer
        Return UseNetLinksNumber(SourceForm, IndexFlowChart)
    End Function





    'cross between _pathNumber and net_names)
    Friend Function FlowChart_TablePathName(ByRef SourceForm As Source, IndexFlowChart As Integer) As String
        Dim IndexNet As Integer
        If FlowChart_TableCode(SourceForm, IndexFlowChart) = "/path" Then
            IndexNet = FlowChart_Table(SourceForm, IndexFlowChart)
            If IndexNet <> 0 Then
                If FlowChart_tablePathSymbolName(SourceForm, IndexFlowChart) <> Net_TablePathNames(IndexNet) Then
                    logA(1568, MyShowFlowChartRecord(SourceForm, False, IndexFlowChart), MyShowNetLinks(SourceForm, FlowChart_Table(SourceForm, IndexFlowChart)))
                    Return "NOT_" & IndexNet.ToString & FlowChart_tablePathSymbolName(SourceForm, IndexFlowChart)
                Else
                    FlowChart_TablePathName = FlowChart_tablePathSymbolName(SourceForm, IndexFlowChart)
                    Exit Function
                End If
            Else
                logA(2182, MyShowFlowChartRecord(SourceForm, False, IndexFlowChart))
                Return Nothing
            End If
        Else
            logA(2914, MyShowFlowChartRecord(SourceForm, False, IndexFlowChart))
            Return ""
        End If
        IndexNet = FlowChart_Table(SourceForm, IndexFlowChart)
        If IndexNet = 0 Then ' add this to the net links
            logA(1325, IndexFlowChart.ToString)
            MakeNewNetLinks(SourceForm, IndexFlowChart, FlowChart_tablePathSymbolName(SourceForm, IndexFlowChart))
        End If
        FlowChart_TablePathName = FlowChart_tablePathSymbolName(SourceForm, IndexFlowChart)
        '''''MyUniverse.MyStaticData.FlowChart_FilePathName.LastFlowChart_FilePathName = FlowChart_tablePathSymbolName(SourceForm, IndexFlowChart)
        '''''MyUniverse.MyStaticData.FlowChart_FilePathName.LastIndexFlowChart = IndexFlowChart
    End Function 'FlowChart_TablePathName



    Friend Function FlowChart_Table(SourceForm As Source, IndexFlowChart As Integer) As String
        Return SourceForm.ListBoxFlowChart.Items(IndexFlowChart).ToString
    End Function
    Friend Function FlowChart_TableNet(SourceForm As Source, IndexFlowChart As Integer) As Integer ' Get the pointer to the name of this path
        Dim X As String
        X = GetMyField(Source.ListBoxVariables, "FlowChart:PathName", IndexFlowChart)
        Return SourceForm.ListBoxVariables.Items(My_INT(X)).ToString
    End Function

    ' This is to isolate the actual data from the program (So that it can be converted later versions)
    Friend Function FlowChart_TableX1(ByRef SourceForm As Source, IndexFlowChart As Integer) As Integer
        FlowChart_TableX1 = FlowChart_FileX1(SourceForm, IndexFlowChart)
    End Function



    ' This is to isolate the actual data from the program (So that it can be converted later versions)
    Friend Sub FlowChart_TableX1(ByRef SourceForm As Source, IndexFlowChart As Integer, Value As Integer)
        FlowChart_FileX1(IndexFlowChart) = Value
    End Sub



    ' This is to isolate the actual data from the program (So that it can be converted later versions)
    Friend Function FlowChart_TableY1(ByRef SourceForm As Source, IndexFlowChart As Integer) As Integer
        FlowChart_TableY1 = FlowChart_FileY1(SourceForm, IndexFlowChart)
    End Function

    Friend Sub FlowChart_TableY1(ByRef SourceForm As Source, IndexFlowChart As Integer, Value As Integer)
        FlowChart_FileY1(SourceForm, IndexFlowChart, Value)
    End Sub




    ' This is to isolate the actual data from the program (So that it can be converted later versions)
    Friend Function FlowChart_Table_Rotation(ByRef SourceForm As Source, IndexFlowChart As Integer) As String
        FlowChart_Table_Rotation = MyUnEnum(FlowChart_TableX2(SourceForm, IndexFlowChart), Options.ListBoxRotation, 0)
    End Function



    ' This is to isolate the actual data from the program (So that it can be converted later versions)
    Friend Function FlowChart_TableX2(ByRef SourceForm As Source, IndexFlowChart As Integer) As Integer
        FlowChart_TableX2 = FlowChart_FileX2(SourceForm, IndexFlowChart)
    End Function
    Friend Sub FlowChart_TableX2(ByRef SourceForm As Source, IndexFlowChart As Integer, Value As Integer)
        FlowChart_FileX2(SourceForm, IndexFlowChart, Value)
    End Sub


    ' This is to isolate the actual data from the program (So that it can be converted later versions)
    Friend Sub FlowChart_Table_Rotation(ByRef SourceForm As Source, IndexFlowChart As Integer, Value As String)
        FlowChart_FileX2(SourceForm, IndexFlowChart, FindInDropDownButton(Value, Options.ListBoxRotation))
    End Sub



    ' This is to isolate the actual data from the program (So that it can be converted later versions)
    Friend Function FlowChart_TableY2(ByRef SourceForm As Source, IndexFlowChart As Integer) As Integer
        Return FlowChart_FileY2(SourceForm, IndexFlowChart)
    End Function

    Friend Function FlowChart_TableOption(ByRef SourceForm As Source, IndexFlowChart As Integer) As String
        If FlowChart_TableY2(SourceForm, IndexFlowChart) > MyUniverse.MySystem.FlowChartOptions.Length Then Return Nothing
        If FlowChart_TableY2(SourceForm, IndexFlowChart) < 0 Then Return Nothing
        FlowChart_TableOption = MyUniverse.MySystem.FlowChartOptions(FlowChart_TableY2(SourceForm, IndexFlowChart)).OptionNames
    End Function



    ' This is to isolate the actual data from the program (So that it can be converted later versions)
    Friend Sub FlowChart_TableY2(ByRef SourceForm As Source, IndexFlowChart As Integer, Value As Integer)
        FlowChart_FileY2(SourceForm, IndexFlowChart, Value)
    End Sub
    Friend Sub FlowChart_TableOption(ByRef SourceForm As Source, IndexFlowChart As Integer, Value As String)
        FlowChart_FileY2(SourceForm, IndexFlowChart, FindInDropDownButton(Value, Options.ListBoxSymbols))
    End Sub

    Friend Function FlowChart_TableDataType(ByRef SourceForm As Source, IndexFlowChart As Integer) As String
        FlowChart_TableDataType = FlowChart_File_DataType(SourceForm, IndexFlowChart)
    End Function

    ' This is to isolate the actual data from the program (So that it can be converted later versions)
    Friend Sub FlowChart_TableDataType(ByRef SourceForm As Source, IndexFlowChart As Integer, Value As String)
        FlowChart_File_DataType(SourceForm, IndexFlowChart, Value)
    End Sub


    ' This is to isolate the actual data from the program (So that it can be converted later versions)
    Friend Function DataType_TableName(Index As Integer) As String
        Return DataType_FileName(Index)
    End Function


    ' This is to isolate the actual data from the program (So that it can be converted later versions)
    Friend Sub DataType_TableName(Index As Integer, Value As String)
        DataType_FileName(Index) = Value
    End Sub

    ' This is to isolate the actual data from the program (So that it can be converted later versions)
    Friend Function DataType_Color(Index As Integer) As String ' returns the name of this color number in the color table
        DataType_Color = Options.ListBoxColors.Items(Index).ToString
    End Function



    ' This is to isolate the actual data from the program (So that it can be converted later versions)
    Friend Function DataType_TableColorIndex(Index As Integer) As Integer
        DataType_TableColorIndex = DataType_FileColorIndex(Index)
    End Function



    ' This is to isolate the actual data from the program (So that it can be converted later versions)
    Friend Sub DataType_TableColorIndex(Index As Integer, Value As Integer)
        If Value < 1 Then
            logA(1590, Value.ToString, Index.ToString)
            Return
        End If
        DataType_FileColorIndex(Index) = Value
    End Sub



    ' This is to isolate the actual data from the program (So that it can be converted later versions)
    Friend Function DataType_TableDescription(Index As Integer) As String
        DataType_TableDescription = DataType_FileDescription(Index)
    End Function



    ' This is to isolate the actual data from the program (So that it can be converted later versions)
    Friend Sub DataType_TableDescription(Index As Integer, Value As String)
        DataType_FileDescription(Index, Value)
    End Sub


    ' This is to isolate the actual data from the program (So that it can be converted later versions)
    Friend Function DataType_TableWidth(Index As Integer) As Integer
        DataType_TableWidth = DataType_FileWidth(Index)
    End Function



    ' This is to isolate the actual data from the program (So that it can be converted later versions)
    Friend Sub DataType_TableWidth(Index As Integer, Value As Integer)
        DataType_FileWidth(Index) = Value
    End Sub



    ' This is to isolate the actual data from the program (So that it can be converted later versions)
    Friend Function DataType_TableNumberOfBytes(Index As Integer) As String
        DataType_TableNumberOfBytes = CStr(DataType_FileNumberOfBytes(Index))
    End Function


    ' This is to isolate the actual data from the program (So that it can be converted later versions)
    Friend Sub DataType_TableNumberOfBytes(Index As Integer, Value As Integer)
        DataType_FileNumberOfBytes(Index) = Value
    End Sub





    Friend Function TrueOrFalse(What As String) As Boolean
        Select Case MyTrim(What)
            Case "yes", "true", "on", "1"
                Return True
            Case "no", "false", "off", "0", Nothing, ""
                Return False
            Case Else
                logA(1100, What)
        End Select
        Return False
    End Function

    'This sets, or unsets a bit option
    ' Level is the number 1-1000, and passed on/off, yes/no, true/false
    Friend Sub BitSet(Level As Integer, SetBitTo As Boolean)
        Dim MyByte As Integer
        Dim MyBit As Integer

        MyByte = CInt(Fix(Level / 8))
        MyByte = MyMinMax(MyByte, 1, MySizeOf(MyMessageBits) - 1)
        MyBit = MyMinMax(Level - (MyByte * 8), 0, 7)
        If SetBitTo = True Then
            MyMessageBits(MyByte) = CByte(MyMessageBits(MyByte) Or MyBits(MyBit))
        Else
            MyMessageBits(MyByte) = CByte(MyMessageBits(MyByte) And (Not MyBits(MyBit)))
        End If
    End Sub


    'returns if the bit is set or not
    Friend Function IsBitSet(Level As Integer) As Boolean
        Dim MyByte As Integer
        Dim MyBit As Integer
        Dim Temp As Integer
        MyByte = CInt(Fix(Level / 8))
        MyByte = MyMinMax(MyByte, 1, MySizeOf(MyMessageBits) - 1)
        MyBit = MyMinMax(Level - (MyByte * 8), 0, 7)
        If MyByte < 0 Or MyByte > MySizeOf(MyMessageBits) - 1 Then
            logA(1611, Level.ToString, CStr(MyByte), MySizeOf(MyMessageBits).ToString, CStr(MyBit))
        End If

        Temp = MyMessageBits(MyByte) And MyBits(MyBit)
        If (MyMessageBits(MyByte) And MyBits(MyBit)) > 0 Then
            IsBitSet = True
        Else
            IsBitSet = False
        End If
    End Function




    'NOT USED
    'This returns if the point is closest enough to move (snap grid)

    Friend Function FlowChart_XY_IsClose(ByRef SourceForm As Source, Index As Integer, X1 As Integer, Y1 As Integer, X2 As Integer, Y2 As Integer) As Boolean
        Dim Distance As Integer
        FlowChart_XY_IsClose = False
        If Index < 1 Then Exit Function
        Distance = MyDistance(MyPoint1XY(X1, Y1), MyPoint2XY(X2, Y2))
        If Distance <= MyUniverse.SysGen.Constants.ConstantDistanceToMovePaths Then
            FlowChart_XY_IsClose = True
        End If

        If MyABS(X1 - X2) < MyUniverse.SysGen.Constants.ConstantDistanceToMovePaths Then
            FlowChart_XY_IsClose = True
        End If

        If MyABS(Y1 - Y2) < MyUniverse.SysGen.Constants.ConstantDistanceToMovePaths Then
            FlowChart_XY_IsClose = True
        End If

    End Function


    Friend Sub CheckAndFixSyntax(ByRef SourceForm As Source)
        Dim IndexNamed As Integer


        For IndexNamed = 1 To TopOfFile(SourceForm, "named")
            If MyTrim(Named_TableMicroCodeText(IndexNamed)) = "" Or MyTrim(Named_TableSyntax(IndexNamed)) = "" Then 'check if any micro code was used.
                logA(3561, Named_TableMicroCodeText(IndexNamed), MyShowNamedRecord(True, IndexNamed), MyShowNamedAndSymbolRecords(SourceForm, False, IndexNamed))
                logA(1615, Named_TableSymbolName(IndexNamed), MyShowNamedAndSymbolRecords(SourceForm, False, Named_FileSymbolIndexes(IndexNamed)))
                'todo need to check options(25) to fix it.
                If Named_TableMicroCodeText(IndexNamed) = "" Then Named_TableMicroCodeText(IndexNamed, Options.ListBoxSymbolData.Items.Item(21).ToString)
                'todo this should be the syntax of the microcodetext not a comment character
                If Named_TableSyntax(IndexNamed) = "" Then Named_TableSyntax(IndexNamed, Options.ListBoxSymbolData.Items.Item(21).ToString)
            End If
            '''''MyReSort("Named", IndexNamed)
            '''''MyReSort("Named", TopOfFile(SourceForm, "named"))
        Next IndexNamed


    End Sub

    'Checking that everything is OK

    Friend Function MyCheckIndex_String(ByRef LB As ListBox, Index As Integer, ByRef ISAM() As Integer) As Boolean
        MyCheckIndex_String = False
        If Index < 1 Then
            Exit Function
        End If
        If Index >= TopOfListBox(LB) Then Exit Function
        If Index > TopOfListBox(LB) Then
            Exit Function
        End If
        If Index <> 0 And ISAM(Index - 1) = Index Then
            DisplayStatus(3241, Index.ToString, ISAM(Index - 1).ToString, Index.ToString)
            Exit Function
        End If
        If ISAM(1) <> 0 And ISAM(1) = ISAM(2) Then
            logA(1169, LB.Name, ISAM(1).ToString, ISAM(2).ToString)
            Exit Function
        End If
        If Index = 0 Then
            logA(1170, LB.Name, Index.ToString, Index.ToString)
            Exit Function
        End If
        If Index = 0 Then
            logA(1170, LB.Name, Index.ToString, Index.ToString)
            Exit Function
        End If
        MyCheckIndex_String = True
    End Function


    '
    'replacement string

    Friend Function MyFirstOne(StringToSearch As String, CharactersToFind As String) As Integer
        Dim t1 As Integer
        Dim t2 As Integer
        Dim t3 As Integer = Len(StringToSearch) + 1 ' one added in case there is no delimiter
        Dim B As String
        ' DIM   debugLevel As Integer=a_status
        'get rid of the first character because it is one that you are looking for the next
        If IsNothing(StringToSearch) Then
            Return 0
        End If
        B = StringToSearch

        For t1 = 1 To Len(CharactersToFind)
            t2 = MyInStr(Mid(CharactersToFind, t1, 1), B)
            If t2 >= 1 Then
                If t2 < t3 Then
                    t3 = t2
                Else
                    'ignore this because it's longer
                End If
            End If
        Next

        ' log_X (1570, t3.ToString, StringToSearch, Mid(StringToSearch, 1, t3 - 1), t1.ToString, t2.ToString, Len(StringToSearch).ToString)
        Return t3
    End Function

    Friend Function MyRemove(InputString As String, FindingString As String) As String
        Return Strings.Replace(InputString, FindingString, "", 1, 1, CompareMethod.Text)
    End Function


    Friend Function MyRePlacements(X As String, CodeNumber As Integer, Optional S1 As String = "", Optional S2 As String = "", Optional S3 As String = "", Optional S4 As String = "", Optional S5 As String = "", Optional S6 As String = "", Optional S7 As String = "", Optional S8 As String = "", Optional S9 As String = "", Optional S10 As String = "", Optional S11 As String = "") As String
        X = MyReplace(X, AddRM("codeNumber"), CodeNumber.ToString)
        X = MyReplace(X, AddRM("ErrStr01"), PrintAbleNull(S1))
        X = MyReplace(X, AddRM("ErrStr02"), PrintAbleNull(S2))
        X = MyReplace(X, AddRM("ErrStr03"), PrintAbleNull(S3))
        X = MyReplace(X, AddRM("ErrStr04"), PrintAbleNull(S4))
        X = MyReplace(X, AddRM("ErrStr05"), PrintAbleNull(S5))
        X = MyReplace(X, AddRM("ErrStr06"), PrintAbleNull(S6))
        X = MyReplace(X, AddRM("ErrStr07"), PrintAbleNull(S7))
        X = MyReplace(X, AddRM("ErrStr08"), PrintAbleNull(S8))
        X = MyReplace(X, AddRM("ErrStr09"), PrintAbleNull(S9))
        X = MyReplace(X, AddRM("ErrStr10"), PrintAbleNull(S10))
        X = MyReplace(X, AddRM("ErrStr11"), PrintAbleNull(S11))
        Return X
    End Function

    'my replace is used to only replace the first one.
    Friend Function MyReplace(InputString As String, FindingString As String, ReplacementString As String) As String
        If ReplacementString = "" Then Return MyRemove(InputString, FindingString)
        If InputString = "" Then Return ""
        If FindingString = "" Then Return InputString
        If MyInStr(FindingString, InputString) = 0 Then Return InputString
        'start at col 1, and replace only 1 time
        MyReplace = Strings.Replace(InputString, FindingString, ReplacementString, 1, 1, CompareMethod.Text)
    End Function

    Friend Function HighLight(ShowString As String) As String
        If MyIsNothing(ShowString) Then Return "><" Else Return " --->" & ShowString & "<--- "
    End Function
    'Short High Light (SHL)
    Friend Function SHL(ShowString As String) As String
        If MyIsNothing(ShowString) Then
            Return "{Nothing}"
        Else
            Return ">" & ShowString & "<"
        End If
    End Function


    Friend Function MyShowWindowTitle() As String
        Dim RTN As String = ""
        'todo need options to turn on or off. 
        'RTN &= COMMA & MyUniverse.ProgramOptions.FCCL_Dimension
        RTN &= COMMA & "Case=" & Options.ListBoxSymbolData.Items.Item(20).ToString
        'RTN &= COMMA & MyUniverse.ProgramOptions.FCCL_Comment
        'RTN &= COMMA & MyUniverse.ProgramOptions.FCCL_Extension
        'RTN &= COMMA & MyUniverse.ProgramOptions.FCCL_Extensions
        'RTN &= COMMA & MyUniverse.ProgramOptions.FCCL_MultiLine
        RTN &= COMMA & "Class=" & MyUniverse.ProgramOptions.FCCL_LanguageClassName
        RTN &= COMMA & "Dialect=" & Options.ListBoxSymbolData.Items.Item(23).ToString
        RTN &= COMMA & "Also=" & MyUniverse.ProgramOptions.FCCL_VarChars
        'RTN &= COMMA & MyUniverse.ProgramOptions.FCCL_Order
        'RTN &= COMMA & MyUniverse.ProgramOptions.FCCL_WhiteSpace
        RTN &= COMMA & "Input=" & MyUniverse.ProgramOptions.FlowChartTextBox
        RTN &= COMMA & "Symbol=" & MyUniverse.ProgramOptions.SelectedSymbolName
        RTN &= COMMA & "DataType=" & MyUniverse.ProgramOptions.SelectedDataType
        RTN &= COMMA & "Color=" & MyUniverse.ProgramOptions.SelectedColor
        'RTN &= COMMA & MyUniverse.ProgramOptions.SelectedInputOutput
        'RTN &= COMMA & MyUniverse.ProgramOptions.SelectedRotation
        'RTN &= COMMA & MyUniverse.ProgramOptions.SelectedPathStart
        'RTN &= COMMA & MyUniverse.ProgramOptions.SelectedPathEnd
        'RTN &= COMMA & MyUniverse.ProgramOptions.SelectedPathLineStyle
        'RTN &= COMMA & MyUniverse.ProgramOptions.SelectedNumberOfBytes
        RTN &= COMMA & "Object=" & MyUniverse.ProgramOptions.SelectedObject.ToString
        'RTN &= COMMA & MyUniverse.ProgramOptions.HelpURL
        'RTN &= COMMA & MyUniverse.ProgramOptions.SymbolChanged.ToString
        Return RTN
    End Function


    Friend Function MyShowSymbolWindowData() As String
        Dim RTN As String
        Dim I As Integer
        '    If ProgramBuzzy("Begin" Then
        '    Return ""
        '    End If
        RTN = ""
        RTN &= "/Name =" & PrintAbleNull(Library.TextBoxNamedSymbolName.Text)
        RTN &= "/Description=" & PrintAbleNull(Library.TextBoxNamedDescription.Text)
        '''''RTN &= "/FileName=" & PrintAbleNull(Library.TextBoxNamedNameOfFile.Text)
        RTN &= "/Notes =" & PrintAbleNull(Library.TextBoxNamedNotes.Text)
        RTN &= "/Opcode =" & PrintAbleNull(Library.TextBoxNamedOpCode.Text)
        RTN &= "/MicroCodeText=" & PrintAbleNull(Library.TextBoxSymbolName.Text)
        RTN &= "/Stroke =" & PrintAbleNull(Library.TextBoxNamedStroke.Text)
        RTN &= "/Syntax =" & PrintAbleNull(Library.TextBoxNamedSyntax.Text)
        RTN &= "/Version =" & PrintAbleNull(Library.TextBoxSymbolVersionAuthor.Text)

        For I = 0 To Library.ListBoxPointNameList.Items.Count - 1
            RTN &= "/Point name=" & PrintAbleNull(Library.ListBoxPointNameList.Items(I).ToString)
        Next I
        For I = 0 To Library.ListBoxLineColor.Items.Count - 1
            RTN &= "/Line name=" & PrintAbleNull(Library.ListBoxLineColor.Items(I).ToString)
        Next I


        RTN &= "/Name selected=" + PrintAbleNull(Library.TextBoxNamedSyntax.Text)
#If DEBUGMODE Then
           LogA(2860, RTN)
#End If
        Return RTN
    End Function


    'input the "text" string (what ever) and return the string with each Line starting with that switch (used for all multi Line import/export
    Friend Function MyShowMultiLineText(MySwitch As String, OutputText As String) As String
        Dim Temp As String
        Temp = OutputText
        MyShowMultiLineText = ""

        While Len(Temp) > 0
            MyShowMultiLineText = vbCrLf & MySwitch & "=" & PopLine(Temp)
        End While

        If Len(MyShowMultiLineText) > 0 Then MyShowMultiLineText &= vbCrLf
    End Function


    Friend Function MyShowUsePoints(ByRef SourceForm As Source, expanded As Boolean, IndexFlowChart As Integer) As String
        Dim IndexNamed, IndexSymbol As Integer
        Dim XY1, XY2 As MyPointStructure

        'todo is this necessary '''MyShowUsePoints=""
        XY1 = Nothing
        XY1.x = FlowChart_TableX1(SourceForm, IndexFlowChart)
        XY1.y = FlowChart_TableY1(SourceForm, IndexFlowChart)
        IndexNamed = FindInNamedList(FlowChart_TableSymbol_Name(SourceForm, IndexFlowChart))
        If IndexNamed < 1 Then
            Return "No Symbol " & HighLight(FlowChart_TableSymbol_Name(SourceForm, IndexFlowChart))
        End If
        IndexSymbol = CorrectingIndexes(SourceForm, Named_TableSymbolName(IndexNamed))
        If IndexSymbol < 1 Then
            Return "No Points " & Named_TableSymbolName(IndexNamed)
        End If
        MyShowUsePoints = MyShowSymbolPoint(False, IndexSymbol)
        IndexSymbol += 1 ' jump over the name 

        While IndexSymbol <= TopOfFile(SourceForm, "Symbol")
            Select Case LCase(Symbol_TableCoded_String(IndexSymbol))
                Case "/name"

                    Exit Function
                Case "/point"
                    XY2 = MyRotated_1(IndexSymbol, XY1, FlowChart_Table_Rotation(SourceForm, IndexFlowChart))
                    MyShowUsePoints &= FD & MyShowPoint(XY2)
                Case "/Line" 'ignore
                Case Else
                    MyShowUsePoints &= FD & MyShowSymbolPoint(expanded, IndexSymbol)
            End Select
            IndexSymbol += 1
        End While

    End Function






    Friend Function MyShowPath(ByRef SourceForm As Source, expanded As Boolean, LocalIndex As Integer) As String

        MyShowPath = FlowChart_TableCode(SourceForm, LocalIndex) & "=" & FlowChart_TablePathName(SourceForm, LocalIndex)
        MyShowPath &= FD & FlowChart_TableX1(SourceForm, LocalIndex)
        MyShowPath &= FD & FlowChart_TableY1(SourceForm, LocalIndex)
        MyShowPath &= FD & FlowChart_TableX2(SourceForm, LocalIndex)
        MyShowPath &= FD & FlowChart_TableY2(SourceForm, LocalIndex)
        MyShowPath &= FD & FlowChart_TableDataType(SourceForm, LocalIndex)
        If expanded = True Then
            MyShowPath &= vbCrLf & "\Index=" & LocalIndex
            MyShowPath &= vbCrLf & "\NetLinks=" & MyShowNetLinks(SourceForm, FlowChart_TablePathName(SourceForm, LocalIndex))
        End If
    End Function


    Friend Function MyShowFlowChartPoint(ByRef SourceForm As Source, PointNumber As Integer, IndexFlowChart As Integer) As FCCL_FlowChart
        Dim IndexNamed, indexSymbol As Integer
        'First get the name & xy of the /use
        Dim n As String
        Dim xy As MyPointStructure
        MyShowFlowChartPoint = Nothing
        n = FlowChart_TableSymbol_Name(SourceForm, IndexFlowChart)
        xy.x = FlowChart_TableX1(SourceForm, IndexFlowChart)
        xy.y = FlowChart_TableY1(SourceForm, IndexFlowChart)
        'find this named symbol
        IndexNamed = FindInNamedList(n)
        indexSymbol = Named_TableSymbolIndexes(IndexNamed)
        'get the 'which' point

        While PointNumber > 0 And indexSymbol <= TopOfFile(SourceForm, "Symbol")
            indexSymbol += 1
            If Symbol_TableCoded_String(indexSymbol) = "/point" Then
                PointNumber -= 1
            End If
        End While

        If PointNumber = 0 Then
            MyShowFlowChartPoint.Coded = Symbol_TableCoded_Byte(indexSymbol)
            MyShowFlowChartPoint.PathSymbolName = Symbol_Table_NameOfPoint(indexSymbol)
            MyShowFlowChartPoint.X1 = xy.x + Symbol_TableX1(indexSymbol)
            MyShowFlowChartPoint.Y1 = xy.y + Symbol_TableY1(indexSymbol)
        Else
            MyShowFlowChartPoint.Coded = 0
            MyShowFlowChartPoint.PathSymbolName = ""
            MyShowFlowChartPoint.X1 = -1
            MyShowFlowChartPoint.Y1 = -1
        End If
    End Function

    Friend Function MyShowFlowChartOnce(FC As FCCL_FlowChart) As String
        Dim RTN As String = "Name="
        RTN &= FC.PathSymbolName & COMMA & " Code="
        RTN &= MyKeyword2String(FC.Coded) & COMMA & FC.Coded & COMMA & " X1="
        RTN &= FC.X1 & COMMA & " Y1="
        RTN &= FC.Y1 & COMMA & " X2_="
        RTN &= FC._X2_Rotation & COMMA & " Y2_="
        RTN &= FC._Y2_Option & COMMA & " DataType="
        RTN &= FC._DataType
        Return RTN
    End Function




    Friend Function MyShowNamedRecord(Expanded As Boolean, IndexNamed As Integer) As String
        Dim X1, X2 As String
        Dim RTN As String
        If IndexNamed = ConstantMyErrorCode Then
            Return "Error: Symbol Name Not Found "
        End If
        If Len(Named_TableSymbolName(IndexNamed)) = 0 Then
            Return "####  Error: No Symbol Name  #### " & IndexNamed.ToString
        End If
        'todo this is the wrong format for Output fixed ?? needs checking
        RTN = My_keyWord(My_KeyConstName) & "=" & Named_TableSymbolName(IndexNamed) & vbCrLf
        If Named_TableAuthor(IndexNamed) <> "" Then RTN &= My_keyWord(My_KeyConstAuthor) & "=" & Named_TableAuthor(IndexNamed) & vbCrLf
        If Named_TableVersion(IndexNamed) <> "" Then RTN &= My_keyWord(My_KeyConstVersion) & "=" & Named_TableVersion(IndexNamed) & vbCrLf
        If Named_TableNameOfFile(IndexNamed) <> "" Then RTN &= My_keyWord(My_KeyConstFileName) & "=" & Named_TableNameOfFile(IndexNamed) & vbCrLf
        If Named_TableStroke(IndexNamed) <> "" Then RTN &= My_keyWord(My_KeyConstStroke) & "=" & Named_TableStroke(IndexNamed) & vbCrLf

        X2 = MyTrim(Named_TableMicroCodeText(IndexNamed))

        While X2 <> ""
            X1 = MyTrim(PopLine(X2))
            If Len(X1) > 0 Then
                RTN &= My_keyWord(My_KeyConstMicroCodeText) & "=" & X1 & vbCrLf
            End If
        End While


        X2 = MyTrim(Named_TableSyntax(IndexNamed))

        While X2 <> ""
            X1 = MyTrim(PopLine(X2))
            If Len(X1) > 0 Then
                RTN &= My_keyWord(My_KeyConstSyntax) & "=" & X1 & vbCrLf
            End If
        End While


        X2 = MyTrim(Named_TableNotes(IndexNamed))

        While X2 <> ""
            X1 = MyTrim(PopLine(X2))
            If Len(X1) > 0 Then
                RTN &= My_keyWord(My_KeyConstNotes) & "=" & X1 & vbCrLf
            End If
        End While


        X2 = MyTrim(Named_TableOpCode(IndexNamed))

        While X2 <> ""
            X1 = PopLine(X2)
            If Len(X1) > 0 Then
                RTN &= My_keyWord(My_KeyConstOpcode) & "=" & X1 & vbCrLf
            End If
        End While


        If Expanded Then
            If Named_TableSymbolIndexes(IndexNamed) > 0 Then
                RTN &= "\Pointer to Symbol Graphics " & Named_TableSymbolIndexes(IndexNamed).ToString & vbCrLf
                '                    RTN &= MyShowSymbolGraphic(Expanded, Named_TableSymbolIndexes(IndexNamed))
            End If
        End If


        Return RTN 'already has cr
    End Function


    Friend Function MyShowSymbolRecord(ByRef SourceForm As Source, expanded As Boolean, IndexSymbol As Integer) As String
        If IndexSymbol < 1 Or IndexSymbol > TopOfFile(SourceForm, "Symbol") Then
            Return "Index Error Index=" & SHL(IndexSymbol.ToString) & COMMA & TopOfFile(SourceForm, "Symbol").ToString
        End If
        Select Case LCase(Symbol_TableCoded_String(IndexSymbol))
            Case "/unknown"
                Return "/Error=Index=" & IndexSymbol.ToString & "/" & Symbol_TableCoded_String(IndexSymbol) & "=" & Symbol_TableX1(IndexSymbol) & COMMA & Symbol_TableY1(IndexSymbol) & "=" & Symbol_Table_InputOutput(IndexSymbol) & COMMA & Symbol_Table_DataType(IndexSymbol) & COMMA & Symbol_TableY1(IndexSymbol) & COMMA & Symbol_TableSymbolName(IndexSymbol) & COMMA & Symbol_Table_NameOfPoint(IndexSymbol)
                    'Return "/unknown ERROR " & IndexSymbol.ToString  ' end of the Symbol list
            Case "/name"
                Return MyShowSymbolName(expanded, IndexSymbol)
            Case "/point"
                Return MyShowSymbolGraphic(expanded, IndexSymbol)
            Case "/Line"
                Return MyShowLineRecord(expanded, IndexSymbol)
            Case "/delete"
                Return "/delete=" & Symbol_TableX1(IndexSymbol) & COMMA & Symbol_TableY1(IndexSymbol) & COMMA & Symbol_TableSymbolName(IndexSymbol) & COMMA & Symbol_Table_NameOfPoint(IndexSymbol)
            Case "/Error"
                Return "/Error=" & Symbol_TableX1(IndexSymbol) & COMMA & Symbol_TableY1(IndexSymbol) & "=" & Symbol_Table_InputOutput(IndexSymbol) & COMMA & Symbol_Table_DataType(IndexSymbol) & COMMA & Symbol_TableY1(IndexSymbol) & COMMA & Symbol_TableSymbolName(IndexSymbol) & COMMA & Symbol_Table_NameOfPoint(IndexSymbol)
            Case Else
                Return "/Error In program Symbol Data Unknown Code " & Symbol_TableCoded_Byte(IndexSymbol).ToString & "/Error=" & IndexSymbol & COMMA & Symbol_TableCoded_String(IndexSymbol) & COMMA & Symbol_TableX1(IndexSymbol) & COMMA & Symbol_TableY1(IndexSymbol) & COMMA & Symbol_Table_X2(IndexSymbol) & COMMA & Symbol_Table_Y2(IndexSymbol) & COMMA & Symbol_Table_NameOfPoint(IndexSymbol) & COMMA & Symbol_TableSymbolName(IndexSymbol)
        End Select
    End Function

    Friend Function MyShowNamedAndSymbolRecords(ByRef SourceForm As Source, expanded As Boolean, IndexSymbol As Integer) As String
        Dim LocalIndexSymbol, IndexNamed As Integer
        Dim X2, X3 As String
        Dim SymbolName As String
        MyShowNamedAndSymbolRecords = ""
        LocalIndexSymbol = IndexSymbol

        IndexNamed = BinarySearch4Index(Options.ListBoxSymbols, Symbol_TableSymbolName(LocalIndexSymbol))
        If IndexNamed = ConstantMyErrorCode Then
            ' removed not needed ?IndexNamed=CheckNotInList("Named",'Symbol_TableSymbolName(LocalIndexSymbol))
            Return "/ERROR Unable to find the named symbol "
        Else
            SymbolName = Named_TableSymbolName(IndexNamed)
            'MyShowNamedAndSymbolRecords = MyShowNamedRecord(expanded, IndexNamed) & vbCrLf
        End If
        '== Symbol graphics now for the above Symbol Named data.
        'MyShowNamedAndSymbolRecords &= MyShowSymbolName(expanded, LocalIndexSymbol) & vbCrLf

        '            LocalIndexSymbol += 1 'after the name

        Do
            Select Case LCase(Symbol_TableCoded_String(LocalIndexSymbol))
                Case "/unknown"

                    Return MyShowNamedAndSymbolRecords ' end of the Symbol list
                Case "/name"
                    MyShowNamedAndSymbolRecords &= MyShowSymbolName(expanded, LocalIndexSymbol)
                Case "/point"
                    X3 = Symbol_Table_InputOutput(LocalIndexSymbol)
                    X2 = MyUniverse.ProgramOptions.SelectedDataType
                    X2 = CStr(BinarySearch4Index(Options.ListBoxDataTypes, MyUniverse.ProgramOptions.SelectedDataType))
                    '/Point=X, Y, Input-Output, Data Type, Name
                    MyShowNamedAndSymbolRecords &= MyShowSymbolGraphic(expanded, LocalIndexSymbol) & vbCrLf
                Case "/Line"
                    MyShowNamedAndSymbolRecords &= MyShowLineRecord(expanded, LocalIndexSymbol) & vbCrLf
        'MyShowNamedAndSymbolRecords &= vbCrLf
                Case "/delete"
                    MyShowNamedAndSymbolRecords &= "/delete"
                    MyShowNamedAndSymbolRecords &= "=" & Symbol_TableX1(LocalIndexSymbol)
                    MyShowNamedAndSymbolRecords &= FD & Symbol_TableY1(LocalIndexSymbol)
                    MyShowNamedAndSymbolRecords &= FD & Symbol_TableSymbolName(LocalIndexSymbol)
                    MyShowNamedAndSymbolRecords &= FD & Symbol_Table_NameOfPoint(LocalIndexSymbol)
                    MyShowNamedAndSymbolRecords &= vbCrLf
                Case "/Error"
                    MyShowNamedAndSymbolRecords &= vbCrLf & "/Error"
                    MyShowNamedAndSymbolRecords &= "=" & Symbol_TableX1(LocalIndexSymbol)
                    MyShowNamedAndSymbolRecords &= FD & Symbol_TableY1(LocalIndexSymbol)
                    MyShowNamedAndSymbolRecords &= "=" & Symbol_Table_InputOutput(LocalIndexSymbol)
                    MyShowNamedAndSymbolRecords &= FD & Symbol_Table_DataType(LocalIndexSymbol)
                    MyShowNamedAndSymbolRecords &= FD & Symbol_TableY1(LocalIndexSymbol)
                    MyShowNamedAndSymbolRecords &= FD & Symbol_TableSymbolName(LocalIndexSymbol)
                    MyShowNamedAndSymbolRecords &= FD & Symbol_Table_NameOfPoint(LocalIndexSymbol)
                Case Else
                    MyShowNamedAndSymbolRecords &= vbCrLf & "/Error In program Symbol Data Unknown Code " &
        Symbol_TableCoded_Byte(LocalIndexSymbol).ToString & "/Error=" & LocalIndexSymbol & FD
                    MyShowNamedAndSymbolRecords &= Symbol_TableCoded_String(LocalIndexSymbol)
                    MyShowNamedAndSymbolRecords &= FD & Symbol_TableX1(LocalIndexSymbol)
                    MyShowNamedAndSymbolRecords &= FD & Symbol_TableY1(LocalIndexSymbol)
                    MyShowNamedAndSymbolRecords &= FD & Symbol_Table_X2(LocalIndexSymbol)
                    MyShowNamedAndSymbolRecords &= FD & Symbol_Table_Y2(LocalIndexSymbol)
                    MyShowNamedAndSymbolRecords &= FD & Symbol_Table_NameOfPoint(LocalIndexSymbol)
                    MyShowNamedAndSymbolRecords &= FD & Symbol_TableSymbolName(LocalIndexSymbol)
            End Select
            LocalIndexSymbol += 1
        Loop While LocalIndexSymbol <= TopOfFile(SourceForm, "Symbol") And SymbolName = Symbol_TableSymbolName(LocalIndexSymbol)

        If MyRight(MyShowNamedAndSymbolRecords, 2) <> vbCrLf Then MyShowNamedAndSymbolRecords &= vbCrLf
        Return MyShowNamedAndSymbolRecords
    End Function


    Friend Function MyShowPointCounts(expanded As Boolean) As String ', A As MySymbolCountsStructure
        Dim RTN As String
        'todo This needs to be change to use 
        'todo this needs to be change to only list things that are not zero
        'todo this needs to not use shorthand, but the long names of the points listed
        If expanded = True Then
            RTN = "Symbol name=" & MyUniverse.SymbolAndPath.Name
            RTN &= vbTab & " Total=" & MyUniverse.SymbolAndPath.Total.ToString
            'If MyUniverse.SymbolAndPath.Total <> 0 Then RTN &= vbTab & " Total=" & MyUniverse.SymbolAndPath.Total.ToString
            If MyUniverse.SymbolAndPath.Path.Total <> 0 Then RTN &= vbTab & " Total=" & MyUniverse.SymbolAndPath.Path.Total.ToString
            If MyUniverse.SymbolAndPath.Path.NumberOfConnectionsToOtherPaths.Total <> 0 Then RTN &= vbTab & " Total=" & MyUniverse.SymbolAndPath.Path.NumberOfConnectionsToOtherPaths.Total.ToString
            If MyUniverse.SymbolAndPath.Path.NumberOfConnectionsToOtherPaths.Data.Both <> 0 Then RTN &= vbTab & " Data.Both=" & MyUniverse.SymbolAndPath.Path.NumberOfConnectionsToOtherPaths.Data.Both.ToString
            If MyUniverse.SymbolAndPath.Path.NumberOfConnectionsToOtherPaths.Data.Input <> 0 Then RTN &= vbTab & " Data.Input=" & MyUniverse.SymbolAndPath.Path.NumberOfConnectionsToOtherPaths.Data.Input.ToString
            If MyUniverse.SymbolAndPath.Path.NumberOfConnectionsToOtherPaths.Data.Output <> 0 Then RTN &= vbTab & " Data.Output=" & MyUniverse.SymbolAndPath.Path.NumberOfConnectionsToOtherPaths.Data.Output.ToString
            If MyUniverse.SymbolAndPath.Path.NumberOfConnectionsToOtherPaths.Data.Other <> 0 Then RTN &= vbTab & " Data.Other=" & MyUniverse.SymbolAndPath.Path.NumberOfConnectionsToOtherPaths.Data.Other.ToString
            If MyUniverse.SymbolAndPath.Path.NumberOfConnectionsToOtherPaths.Logic.Total <> 0 Then RTN &= vbTab & " Logic.Total=" & MyUniverse.SymbolAndPath.Path.NumberOfConnectionsToOtherPaths.Logic.Total.ToString
            If MyUniverse.SymbolAndPath.Path.NumberOfConnectionsToOtherPaths.Logic.Both <> 0 Then RTN &= vbTab & " Logic.Both=" & MyUniverse.SymbolAndPath.Path.NumberOfConnectionsToOtherPaths.Logic.Both.ToString
            If MyUniverse.SymbolAndPath.Path.NumberOfConnectionsToOtherPaths.Logic.Input <> 0 Then RTN &= vbTab & " Logic.Input=" & MyUniverse.SymbolAndPath.Path.NumberOfConnectionsToOtherPaths.Logic.Input.ToString
            If MyUniverse.SymbolAndPath.Path.NumberOfConnectionsToOtherPaths.Logic.Output <> 0 Then RTN &= vbTab & " Logic.Output=" & MyUniverse.SymbolAndPath.Path.NumberOfConnectionsToOtherPaths.Logic.Output.ToString
            If MyUniverse.SymbolAndPath.Path.NumberOfConnectionsToOtherPaths.Logic.Other <> 0 Then RTN &= vbTab & " Logic.Other=" & MyUniverse.SymbolAndPath.Path.NumberOfConnectionsToOtherPaths.Logic.Other.ToString
            If MyUniverse.SymbolAndPath.Path.NumberOfConnectionsToSymbols.Total <> 0 Then RTN &= vbTab & " Total=" & MyUniverse.SymbolAndPath.Path.NumberOfConnectionsToSymbols.Total.ToString
            If MyUniverse.SymbolAndPath.Path.NumberOfConnectionsToSymbols.Data.Both <> 0 Then RTN &= vbTab & " Data.Both=" & MyUniverse.SymbolAndPath.Path.NumberOfConnectionsToSymbols.Data.Both.ToString
            If MyUniverse.SymbolAndPath.Path.NumberOfConnectionsToSymbols.Data.Input <> 0 Then RTN &= vbTab & " Data.Input=" & MyUniverse.SymbolAndPath.Path.NumberOfConnectionsToSymbols.Data.Input.ToString
            If MyUniverse.SymbolAndPath.Path.NumberOfConnectionsToSymbols.Data.Output <> 0 Then RTN &= vbTab & " Data.Output=" & MyUniverse.SymbolAndPath.Path.NumberOfConnectionsToSymbols.Data.Output.ToString
            If MyUniverse.SymbolAndPath.Path.NumberOfConnectionsToSymbols.Data.Other <> 0 Then RTN &= vbTab & " Data.Other=" & MyUniverse.SymbolAndPath.Path.NumberOfConnectionsToSymbols.Data.Other.ToString
            If MyUniverse.SymbolAndPath.Path.NumberOfConnectionsToSymbols.Logic.Total <> 0 Then RTN &= vbTab & " Logic.Total=" & MyUniverse.SymbolAndPath.Path.NumberOfConnectionsToSymbols.Logic.Total.ToString
            If MyUniverse.SymbolAndPath.Path.NumberOfConnectionsToSymbols.Logic.Both <> 0 Then RTN &= vbTab & " Logic.Both=" & MyUniverse.SymbolAndPath.Path.NumberOfConnectionsToSymbols.Logic.Both.ToString
            If MyUniverse.SymbolAndPath.Path.NumberOfConnectionsToSymbols.Logic.Input <> 0 Then RTN &= vbTab & " Logic.Input=" & MyUniverse.SymbolAndPath.Path.NumberOfConnectionsToSymbols.Logic.Input.ToString
            If MyUniverse.SymbolAndPath.Path.NumberOfConnectionsToSymbols.Logic.Output <> 0 Then RTN &= vbTab & " Logic.Output=" & MyUniverse.SymbolAndPath.Path.NumberOfConnectionsToSymbols.Logic.Output.ToString
            If MyUniverse.SymbolAndPath.Path.NumberOfConnectionsToSymbols.Logic.Other <> 0 Then RTN &= vbTab & " Logic.Other=" & MyUniverse.SymbolAndPath.Path.NumberOfConnectionsToSymbols.Logic.Other.ToString
            If MyUniverse.SymbolAndPath.Path.NumberOfErrors <> 0 Then RTN &= vbTab & " NumberOfErrors=" & MyUniverse.SymbolAndPath.Path.NumberOfErrors.ToString
            If MyUniverse.SymbolAndPath.Symbol.Total <> 0 Then RTN &= vbTab & " Total=" & MyUniverse.SymbolAndPath.Symbol.Total.ToString
            If MyUniverse.SymbolAndPath.Symbol.NumberOfLines.Total <> 0 Then RTN &= vbTab & " Total=" & MyUniverse.SymbolAndPath.Symbol.NumberOfLines.Total.ToString
            If MyUniverse.SymbolAndPath.Symbol.NumberOfLines.Data.Both <> 0 Then RTN &= vbTab & " Data.Both=" & MyUniverse.SymbolAndPath.Symbol.NumberOfLines.Data.Both.ToString
            If MyUniverse.SymbolAndPath.Symbol.NumberOfLines.Data.Input <> 0 Then RTN &= vbTab & " Data.Input=" & MyUniverse.SymbolAndPath.Symbol.NumberOfLines.Data.Input.ToString
            If MyUniverse.SymbolAndPath.Symbol.NumberOfLines.Data.Output <> 0 Then RTN &= vbTab & " Data.Output=" & MyUniverse.SymbolAndPath.Symbol.NumberOfLines.Data.Output.ToString
            If MyUniverse.SymbolAndPath.Symbol.NumberOfLines.Data.Other <> 0 Then RTN &= vbTab & " Data.Other=" & MyUniverse.SymbolAndPath.Symbol.NumberOfLines.Data.Other.ToString
            If MyUniverse.SymbolAndPath.Symbol.NumberOfLines.Logic.Total <> 0 Then RTN &= vbTab & " Logic.Total=" & MyUniverse.SymbolAndPath.Symbol.NumberOfLines.Logic.Total.ToString
            If MyUniverse.SymbolAndPath.Symbol.NumberOfLines.Logic.Both <> 0 Then RTN &= vbTab & " Logic.Both=" & MyUniverse.SymbolAndPath.Symbol.NumberOfLines.Logic.Both.ToString
            If MyUniverse.SymbolAndPath.Symbol.NumberOfLines.Logic.Input <> 0 Then RTN &= vbTab & " Logic.Input=" & MyUniverse.SymbolAndPath.Symbol.NumberOfLines.Logic.Input.ToString
            If MyUniverse.SymbolAndPath.Symbol.NumberOfLines.Logic.Output <> 0 Then RTN &= vbTab & " Logic.Output=" & MyUniverse.SymbolAndPath.Symbol.NumberOfLines.Logic.Output.ToString
            If MyUniverse.SymbolAndPath.Symbol.NumberOfLines.Logic.Other <> 0 Then RTN &= vbTab & " Logic.Other=" & MyUniverse.SymbolAndPath.Symbol.NumberOfLines.Logic.Other.ToString
            If MyUniverse.SymbolAndPath.Symbol.NumberOfOther.Total <> 0 Then RTN &= vbTab & " Total=" & MyUniverse.SymbolAndPath.Symbol.NumberOfOther.Total.ToString
            If MyUniverse.SymbolAndPath.Symbol.NumberOfOther.Data.Both <> 0 Then RTN &= vbTab & " Data.Both=" & MyUniverse.SymbolAndPath.Symbol.NumberOfOther.Data.Both.ToString
            If MyUniverse.SymbolAndPath.Symbol.NumberOfOther.Data.Input <> 0 Then RTN &= vbTab & " Data.Input=" & MyUniverse.SymbolAndPath.Symbol.NumberOfOther.Data.Input.ToString
            If MyUniverse.SymbolAndPath.Symbol.NumberOfOther.Data.Output <> 0 Then RTN &= vbTab & " Data.Output=" & MyUniverse.SymbolAndPath.Symbol.NumberOfOther.Data.Output.ToString
            If MyUniverse.SymbolAndPath.Symbol.NumberOfOther.Data.Other <> 0 Then RTN &= vbTab & " Data.Other=" & MyUniverse.SymbolAndPath.Symbol.NumberOfOther.Data.Other.ToString
            If MyUniverse.SymbolAndPath.Symbol.NumberOfOther.Logic.Total <> 0 Then RTN &= vbTab & " Logic.Total=" & MyUniverse.SymbolAndPath.Symbol.NumberOfOther.Logic.Total.ToString
            If MyUniverse.SymbolAndPath.Symbol.NumberOfOther.Logic.Both <> 0 Then RTN &= vbTab & " Logic.Both=" & MyUniverse.SymbolAndPath.Symbol.NumberOfOther.Logic.Both.ToString
            If MyUniverse.SymbolAndPath.Symbol.NumberOfOther.Logic.Input <> 0 Then RTN &= vbTab & " Logic.Input=" & MyUniverse.SymbolAndPath.Symbol.NumberOfOther.Logic.Input.ToString
            If MyUniverse.SymbolAndPath.Symbol.NumberOfOther.Logic.Output <> 0 Then RTN &= vbTab & " Logic.Output=" & MyUniverse.SymbolAndPath.Symbol.NumberOfOther.Logic.Output.ToString
            If MyUniverse.SymbolAndPath.Symbol.NumberOfOther.Logic.Other <> 0 Then RTN &= vbTab & " Logic.Other=" & MyUniverse.SymbolAndPath.Symbol.NumberOfOther.Logic.Other.ToString
            If MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Total <> 0 Then RTN &= vbTab & " Total=" & MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Total.ToString
            If MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Data.Total <> 0 Then RTN &= vbTab & " Data.Total=" & MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Data.Total.ToString
            If MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Data.Both <> 0 Then RTN &= vbTab & " Data.Both=" & MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Data.Both.ToString
            If MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Data.Input <> 0 Then RTN &= vbTab & " Data.Input=" & MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Data.Input.ToString
            If MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Data.Output <> 0 Then RTN &= vbTab & " Data.Output=" & MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Data.Output.ToString
            If MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Data.Other <> 0 Then RTN &= vbTab & " Data.Other=" & MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Data.Other.ToString
            If MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Logic.Total <> 0 Then RTN &= vbTab & " Logic.Total=" & MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Logic.Total.ToString
            If MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Logic.Both <> 0 Then RTN &= vbTab & " Logic.Both=" & MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Logic.Both.ToString
            If MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Logic.Input <> 0 Then RTN &= vbTab & " Logic.Input=" & MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Logic.Input.ToString
            If MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Logic.Output <> 0 Then RTN &= vbTab & " Logic.Output=" & MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Logic.Output.ToString
            If MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Logic.Other <> 0 Then RTN &= vbTab & " Logic.Other=" & MyUniverse.SymbolAndPath.Symbol.NumberOfPoints.Logic.Other.ToString
            If MyUniverse.SymbolAndPath.Uses.Total <> 0 Then RTN &= vbTab & " Total=" & MyUniverse.SymbolAndPath.Uses.Total.ToString
            If MyUniverse.SymbolAndPath.Uses.IndexUseSymbol <> 0 Then RTN &= vbTab & " IndexUseSymbol=" & MyUniverse.SymbolAndPath.Uses.IndexUseSymbol.ToString
            If MyUniverse.SymbolAndPath.Uses.NumberOfConnections.Total <> 0 Then RTN &= vbTab & " Total=" & MyUniverse.SymbolAndPath.Uses.NumberOfConnections.Total.ToString
            If MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfLines.Total <> 0 Then RTN &= vbTab & " NumberOfLines.Total=" & MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfLines.Total.ToString
            If MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfLines.Data.Both <> 0 Then RTN &= vbTab & " NumberOfLines.Data.Both=" & MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfLines.Data.Both.ToString
            If MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfLines.Data.Input <> 0 Then RTN &= vbTab & " NumberOfLines.Data.Input=" & MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfLines.Data.Input.ToString
            If MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfLines.Data.Output <> 0 Then RTN &= vbTab & " NumberOfLines.Data.Output=" & MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfLines.Data.Output.ToString
            If MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfLines.Data.Other <> 0 Then RTN &= vbTab & " NumberOfLines.Data.Other=" & MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfLines.Data.Other.ToString
            If MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfLines.Logic.Total <> 0 Then RTN &= vbTab & " NumberOfLines.Logic.Total=" & MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfLines.Logic.Total.ToString
            If MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfLines.Logic.Both <> 0 Then RTN &= vbTab & " NumberOfLines.Logic.Both=" & MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfLines.Logic.Both.ToString
            If MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfLines.Logic.Input <> 0 Then RTN &= vbTab & " NumberOfLines.Logic.Input=" & MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfLines.Logic.Input.ToString
            If MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfLines.Logic.Output <> 0 Then RTN &= vbTab & " NumberOfLines.Logic.Output=" & MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfLines.Logic.Output.ToString
            If MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfLines.Logic.Other <> 0 Then RTN &= vbTab & " NumberOfLines.Logic.Other=" & MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfLines.Logic.Other.ToString
            If MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfOther.Total <> 0 Then RTN &= vbTab & " NumberOfOther.Total=" & MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfOther.Total.ToString
            If MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfOther.Total <> 0 Then RTN &= vbTab & " NumberOfOther.Total=" & MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfOther.Total.ToString
            If MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfOther.Data.Both <> 0 Then RTN &= vbTab & " NumberOfOther.Data.Both=" & MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfOther.Data.Both.ToString
            If MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfOther.Data.Input <> 0 Then RTN &= vbTab & " NumberOfOther.Data.Input=" & MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfOther.Data.Input.ToString
            If MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfOther.Data.Output <> 0 Then RTN &= vbTab & " NumberOfOther.Data.Output=" & MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfOther.Data.Output.ToString
            If MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfOther.Data.Other <> 0 Then RTN &= vbTab & " NumberOfOther.Data.Other=" & MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfOther.Data.Other.ToString
            If MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfOther.Logic.Total <> 0 Then RTN &= vbTab & " NumberOfOther.Logic.Total=" & MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfOther.Logic.Total.ToString
            If MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfOther.Logic.Both <> 0 Then RTN &= vbTab & " NumberOfOther.Logic.Both=" & MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfOther.Logic.Both.ToString
            If MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfOther.Logic.Input <> 0 Then RTN &= vbTab & " NumberOfOther.Logic.Input=" & MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfOther.Logic.Input.ToString
            If MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfOther.Logic.Output <> 0 Then RTN &= vbTab & " NumberOfOther.Logic.Output=" & MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfOther.Logic.Output.ToString
            If MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfOther.Logic.Other <> 0 Then RTN &= vbTab & " NumberOfOther.Logic.Other=" & MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfOther.Logic.Other.ToString
            If MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfPoints.Total <> 0 Then RTN &= vbTab & " NumberOfPoints.Total=" & MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfPoints.Total.ToString
            If MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfPoints.Data.Both <> 0 Then RTN &= vbTab & " NumberOfPoints.Data.Both=" & MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfPoints.Data.Both.ToString
            If MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfPoints.Data.Input <> 0 Then RTN &= vbTab & " NumberOfPoints.Data.Input=" & MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfPoints.Data.Input.ToString
            If MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfPoints.Data.Output <> 0 Then RTN &= vbTab & " NumberOfPoints.Data.Output=" & MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfPoints.Data.Output.ToString
            If MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfPoints.Data.Other <> 0 Then RTN &= vbTab & " NumberOfPoints.Data.Other=" & MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfPoints.Data.Other.ToString
            If MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfPoints.Logic.Total <> 0 Then RTN &= vbTab & " NumberOfPoints.Logic.Total=" & MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfPoints.Logic.Total.ToString
            If MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfPoints.Logic.Both <> 0 Then RTN &= vbTab & " NumberOfPoints.Logic.Both=" & MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfPoints.Logic.Both.ToString
            If MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfPoints.Logic.Input <> 0 Then RTN &= vbTab & " NumberOfPoints.Logic.Input=" & MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfPoints.Logic.Input.ToString
            If MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfPoints.Logic.Output <> 0 Then RTN &= vbTab & " NumberOfPoints.Logic.Output=" & MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfPoints.Logic.Output.ToString
            If MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfPoints.Logic.Other <> 0 Then RTN &= vbTab & " NumberOfPoints.Logic.Other=" & MyUniverse.SymbolAndPath.Uses.NumberOfConnections.NumberOfPoints.Logic.Other.ToString

            'RTN &= "/Ignore=Total=" & MyUniverse.SymbolAndPath.Total
            If MyUniverse.SymbolAndPath.Symbol.Total <> 0 Then RTN &= " Symbol=" & MyUniverse.SymbolAndPath.Symbol.Total
            If MyUniverse.SymbolAndPath.Uses.Total <> 0 Then RTN &= " USE=" & MyUniverse.SymbolAndPath.Uses.Total
            If MyUniverse.SymbolAndPath.Path.Total <> 0 Then RTN &= " Path=" & MyUniverse.SymbolAndPath.Path.Total
        Else
            RTN = ""
            'RTN &= "/Ignore Total=" & MyUniverse.SymbolAndPath.Total
            If MyUniverse.SymbolAndPath.Symbol.Total <> 0 Then RTN &= " Symbol=" & MyUniverse.SymbolAndPath.Symbol.Total
            If MyUniverse.SymbolAndPath.Uses.Total <> 0 Then RTN &= " USE=" & MyUniverse.SymbolAndPath.Uses.Total
            If MyUniverse.SymbolAndPath.Path.Total <> 0 Then RTN &= " Path=" & MyUniverse.SymbolAndPath.Path.Total
        End If
        Return RTN
    End Function


    'for now only one point per Line, until I change the import to be able to get more than one at a time.
    Friend Function MyShowSymbolLines_detail(LocalIndex As Integer) As String
        'todo need to make sure that this is a /line, and nothing else
        MyShowSymbolLines_detail = Symbol_TableCoded_String(LocalIndex)
        MyShowSymbolLines_detail &= FD & Symbol_FileSymbolName(LocalIndex) 'color of the Line
        MyShowSymbolLines_detail &= "=" & Symbol_TableX1(LocalIndex)
        MyShowSymbolLines_detail &= FD & Symbol_TableY1(LocalIndex)
        MyShowSymbolLines_detail &= FD & Symbol_Table_X2(LocalIndex)
        MyShowSymbolLines_detail &= FD & Symbol_Table_Y2(LocalIndex)
        MyShowSymbolLines_detail &= FD & Symbol_Table_NameOfPoint(LocalIndex) 'Point Name should be color on a Line
        Return MyShowSymbolLines_detail
    End Function



    Friend Function MyShowSymbolPoint(expanded As Boolean, LocalIndex As Integer) As String
        MyShowSymbolPoint = Symbol_TableCoded_String(LocalIndex)
        MyShowSymbolPoint &= "=" & Symbol_FileSymbolName(LocalIndex)
        MyShowSymbolPoint &= FD & Symbol_TableX1(LocalIndex)
        MyShowSymbolPoint &= FD & Symbol_TableY1(LocalIndex)
        MyShowSymbolPoint &= FD & Symbol_Table_InputOutput(LocalIndex)
        MyShowSymbolPoint &= FD & Pop(Symbol_Table_DataType(LocalIndex), FD)
        MyShowSymbolPoint &= FD & Symbol_Table_NameOfPoint(LocalIndex) 'Point Name

        If expanded = True Then
            'todo make sure that this takes care of /name,/line,/point, and anything else like /error
            MyShowSymbolPoint &= vbCrLf & "\data direction=" + Symbol_Table_InputOutput(LocalIndex)
            MyShowSymbolPoint &= vbCrLf & "\DataType=" + Symbol_Table_DataType(LocalIndex)
            MyShowSymbolPoint &= vbCrLf & "\PointName=" + Symbol_Table_NameOfPoint(LocalIndex) 'Point Name
            If expanded = True Then
                MyShowSymbolPoint &= vbCrLf & "\Index= " & LocalIndex
            End If
        End If
        'MyShowSymbolPoint &= FD
        Return MyShowSymbolPoint ' & vbCrLf
    End Function


    Friend Function MyShowSymbolName(expanded As Boolean, LocalIndex As Integer) As String
        If expanded = True Then
            Return "/name=" & Symbol_TableSymbolName(LocalIndex) & COMMA & Symbol_Table_NameOfPoint(LocalIndex) & COMMA & " -----> " & Symbol_TableCoded_String(LocalIndex) & "= " & COMMA & Symbol_TableX1(LocalIndex).ToString & COMMA & Symbol_TableY1(LocalIndex).ToString & COMMA & Symbol_Table_X2(LocalIndex).ToString & COMMA & Symbol_Table_X2(LocalIndex).ToString & COMMA & Symbol_Table_DataType(LocalIndex) & COMMA & Symbol_Table_InputOutput(LocalIndex) & COMMA & Symbol_Table_LineColor(LocalIndex) & vbCr
        End If
        Return "/name=" & Symbol_TableSymbolName(LocalIndex) & COMMA & Symbol_TableX1(LocalIndex).ToString & COMMA & Symbol_TableY1(LocalIndex).ToString & COMMA & Symbol_Table_X2(LocalIndex).ToString & COMMA & Symbol_Table_X2(LocalIndex).ToString & COMMA & Symbol_Table_LineColor(LocalIndex) & vbTab & LocalIndex.ToString & vbCr

    End Function

    Friend Function MyShowAllSymbolNames(ByRef SourceForm As Source, SymbolName As String) As String
        Dim I As Integer
        If SymbolName = "" Then Return ""
        LogDebug(1052, Err7, "===>" & SymbolName & "<")
        For I = 1 To TopOfFile(SourceForm, "Symbol")
            If Named_TableSymbolName(I) <> "" Then
                LogDebug(3482, Err7, I.ToString & " --> " & MyTrim(PopLine(MyTrim(MyShowNamedRecord(False, I)))) & vbTab & vbTab & Named_TableSyntax(I))
            End If
        Next
        Return "XXXXXXXX"
    End Function

    Friend Function MyShowSymbolGraphic(expanded As Boolean, LocalIndex As Integer) As String
        If LocalIndex = 0 Or Symbol_TableCoded_String(LocalIndex) = "/unknown" Then
            MyShowSymbolGraphic = "/ignore Invalid Symbol code, ->" & Symbol_TableCoded_Byte(LocalIndex)
            MyShowSymbolGraphic &= FD & Symbol_TableCoded_String(LocalIndex)
            MyShowSymbolGraphic &= FD & Symbol_FileSymbolName(LocalIndex)
            MyShowSymbolGraphic &= FD & Symbol_TableX1(LocalIndex)
            MyShowSymbolGraphic &= FD & Symbol_TableY1(LocalIndex)
            MyShowSymbolGraphic &= FD & Symbol_Table_InputOutput(LocalIndex)
            MyShowSymbolGraphic &= FD & Symbol_Table_X2(LocalIndex)
            MyShowSymbolGraphic &= FD & Symbol_Table_DataType(LocalIndex)
            MyShowSymbolGraphic &= FD & Symbol_Table_Y2(LocalIndex) 'Point Name
            'MyShowSymbolGraphic &= vbCrLf
            logA(2171, MyShowSymbolGraphic)
            Exit Function
        End If

        'todo need to change the format to ALSO include /point=point name, X, Y [, point name, x, y ... ]
        'todo need to change the format to ALSO include /Line=color, x1,y1,x2,y2 [, {color,} x1, y1, x2, y2] ... 
        ' removed not needed ?MyShowSymbolGraphic=""
        Select Case LCase(Symbol_TableCoded_String(LocalIndex))
            Case "/name"
                MyShowSymbolGraphic = MyShowSymbolName(expanded, LocalIndex)
            Case "/point"
                MyShowSymbolGraphic = MyShowSymbolPoint(expanded, LocalIndex)
            Case "/Line"
                MyShowSymbolGraphic = MyShowSymbolLines_detail(LocalIndex)
            Case Else
                '
                'todo need to change this to something else that display the default record..
                'MyShowSymbolGraphic=MyShowNamedAndSymbolRecords(SourceForm ,expanded, LocalIndex)
                MyShowSymbolGraphic = Symbol_TableCoded_String(LocalIndex)
                MyShowSymbolGraphic &= FD & Symbol_TableX1(LocalIndex)
                MyShowSymbolGraphic &= FD & Symbol_TableY1(LocalIndex)
                MyShowSymbolGraphic &= FD & Symbol_Table_X2(LocalIndex)
                MyShowSymbolGraphic &= FD & Symbol_Table_InputOutput(LocalIndex)
                MyShowSymbolGraphic &= FD & Symbol_Table_Y2(LocalIndex)
                MyShowSymbolGraphic &= FD & Symbol_Table_DataType(LocalIndex)
                MyShowSymbolGraphic &= FD & Symbol_Table_NameOfPoint(LocalIndex) 'Point Name
                MyShowSymbolGraphic &= FD & Symbol_TableSymbolName(LocalIndex)
                MyShowSymbolGraphic &= FD & LocalIndex.ToString
                If expanded = True Then
                    MyShowSymbolGraphic &= "(" & Symbol_TableX1(LocalIndex)
                    MyShowSymbolGraphic &= FD & Symbol_TableY1(LocalIndex)
                    MyShowSymbolGraphic &= "),(" & Symbol_Table_X2(LocalIndex)
                    MyShowSymbolGraphic &= FD & Symbol_Table_Y2(LocalIndex)
                    MyShowSymbolGraphic &= ") " & CT & "\PointName " & Symbol_Table_NameOfPoint(LocalIndex) 'Point Name
                    MyShowSymbolGraphic &= vbCrLf & "\SymbolName=" & Symbol_FileSymbolName(LocalIndex)
                    MyShowSymbolGraphic &= FD & "Index->" & LocalIndex.ToString
                End If
        End Select
        'If MyRight(MyShowSymbolGraphic, 2) <> vbCrLf Then
        ' MyShowSymbolGraphic &= vbCrLf
        ' End If
        Return MyShowSymbolGraphic
    End Function



    Friend Function MyShowDataType(expanded As Boolean, Index As Integer) As String
        MyShowDataType = "/DataType" & "=" & DataType_TableName(Index)
        'MyShowDataType &= Space(32 - Len(MyShowDataType)) & vbTab
        MyShowDataType &= FD & DataType_TableNumberOfBytes(Index)
        MyShowDataType &= FD & Color_TableName(DataType_TableColorIndex(Index)) 'DataType_TableColor( i )
        MyShowDataType &= FD & DataType_TableWidth(Index)
        MyShowDataType &= FD & PrintAbleNull(Trim(DataType_TableDescription(Index)))
        If expanded = True Then
            MyShowDataType &= "\"
            MyShowDataType &= FD & DataType_FileColorIndex(Index)
            MyShowDataType &= FD & DataType_FileName(Index)
            MyShowDataType &= FD & (Index)
        End If
    End Function

    Friend Function MyShowColor(ByRef SourceForm As Source, Expand As Boolean, IndexColor As Integer) As String
        MyShowColor = "/color" & "=" & Color_TableName(IndexColor)
        MyGetPen(SourceForm, Color_TableName(IndexColor), "")
        MyShowColor &= FD & Color_TableAlpha(IndexColor) 'PenColor.Color.A
        MyShowColor &= FD & Color_TableRed(IndexColor) 'PenColor.Color.R
        MyShowColor &= FD & Color_TableGreen(IndexColor) 'PenColor.Color.G
        MyShowColor &= FD & Color_TableBlue(IndexColor) 'PenColor.Color.B
        '''''MyShowColor &= FD & MyUnEnum(Color_TableStyle(IndexColor), Options.ListboxPathLineStyle, 0)
        '''''MyShowColor &= FD & MyUnEnum(Color_TableStartCap(IndexColor), Options.ListboxPathStart, 0)
        '''''MyShowColor &= FD & MyUnEnum(Color_TableEndCap(IndexColor), Options.ListboxPathEnd, 0)
        If Expand = False Then Exit Function
        MyShowColor &= FD & "/ignore=" & formatColor
        MyShowColor &= vbCrLf & "\Index=" & IndexColor.ToString

        If Len(Color_TableName(IndexColor)) < 1 Then
            MyShowColor &= "/Error Invalid color Index at " & IndexColor.ToString
            Exit Function
        End If
    End Function


    Friend Function MyShowDataTypeTable(ByRef SourceForm As Source, expanded As Boolean, LocalIndex As Integer) As String
        If Len(DataType_FileName(LocalIndex)) < 1 Then
            MyShowDataTypeTable = "/ignore \Index=" & LocalIndex & " Invalid Data Type Name at " & LocalIndex.ToString
            Exit Function
        End If

        If DataType_TableColorIndex(LocalIndex) < 1 Then
            MyShowDataTypeTable = vbCrLf & "/ignore \Index=" & LocalIndex & " Invalid color For Data Type Name " & DataType_TableName(LocalIndex)
            Exit Function
        End If

        '"/DataType=DataTypeName" & Comma &  " Number Of Bytes" & Comma &  " Color Name" & Comma &  " Color Width" & Comma &  " Description"
        If expanded = False Then
            MyShowDataTypeTable = "/DataType=" & DataType_FileName(LocalIndex)
            MyShowDataTypeTable &= FD & DataType_FileNumberOfBytes(LocalIndex)
            MyShowDataTypeTable &= FD & FindColorFromDataType(DataType_FileName(LocalIndex))
            MyShowDataTypeTable &= FD & DataType_FileWidth(LocalIndex)
            MyShowDataTypeTable &= FD & DataType_FileDescription(LocalIndex)
            MyShowDataTypeTable &= vbCrLf & "\Index=" & LocalIndex
            MyShowDataTypeTable &= FD & DataType_TableColorIndex(FindDataTypeIndex(DataType_FileName(LocalIndex)))
            MyShowDataTypeTable &= FD & MyShowColor(SourceForm, False, DataType_TableColorIndex(FindDataTypeIndex(DataType_FileName(LocalIndex))))
        Else
            MyShowDataTypeTable = "/DataType=" & DataType_FileName(LocalIndex)
            MyShowDataTypeTable &= FD & "/#bytes" & DataType_FileNumberOfBytes(LocalIndex)
            MyShowDataTypeTable &= FD & "/color=" & FindColorFromDataType(DataType_FileName(LocalIndex))
            MyShowDataTypeTable &= FD & "/size=" & DataType_FileWidth(LocalIndex)
            MyShowDataTypeTable &= FD & "/Description=" & DataType_FileDescription(LocalIndex)
            MyShowDataTypeTable &= vbCrLf & "\Index=" & LocalIndex.ToString
        End If
    End Function


    Friend Function MyShowButton(A As ToolStripButton) As String
        Dim rtn As String
        rtn = A.Name
        rtn &= FD & "EnAbled=" & CStr(A.Enabled)
        'rtn += FD + CStr(A.GetCurrentParent.ToString)
        rtn &= FD & "Parent=" & A.GetCurrentParent.Name
        rtn &= FD & "Pressed=" & CStr(A.Pressed)
        rtn &= FD & "Selected=" & A.Selected.ToString
        rtn &= FD & "Text=" & A.Text
        rtn &= FD & "Tip=" & A.ToolTipText
        rtn &= FD & "String=" & A.ToString
        Return rtn
    End Function

    Friend Function MyShowControl(CTL As Control, What As HelpProvider) As String
        Const Y As String = Chr(34) & vbTab & Chr(34)
        Dim X As String
        Dim I As Integer
        X = vbCrLf & "/ignore= Control display  "
        X = X & Y & " control parent " & CTL.Parent.Name
        X = X & Y & " control name " & CTL.Name
        X = X & Y & " Help " & What.ToString
        X = X & Y & " Help Name Space " & What.HelpNamespace
        X = X & Y & " Help tag " & What.Tag.ToString
        X = X & Y & " name " & What.GetType.Name
        X = X & Y & " full name " & What.GetType.FullName
        X = X & Y & " length " & What.GetType.GetEnumNames.Length
        For I = 0 To What.GetType.GetEnumNames.Length - 1 ''What.GetType.GetEnumNames.Count - 1
            X = X & Y & " names Of  " & What.GetType.GetEnumNames(I).ToString
        Next
        X = X & Y & " Namespace " & What.GetType.Namespace
        X = X & Y & " DataType name " & What.GetType.UnderlyingSystemType.Name
        Return X
    End Function


    Friend Function MyShowComboBoxItems(ByRef X As ComboBox) As String
        Return vbTab & X.ToString & vbCrLf
    End Function




    Friend Function MyShowScale() As String
        Dim X As String
        X = " Scale Min,Is,max ="
        X &= vbTab
        X &= ConstantMinFlowChartScale.ToString
        X &= SHL(MyUniverse.SysGen.MyFlowChartScale.ToString)
        X &= SHL(ConstantMaxFlowChartScale.ToString)
        X &= vbTab & "(TopLine left window)" & MyShowPoint(MyUniverse.MyMouseAndDrawing.MyScreen00.x, MyUniverse.MyMouseAndDrawing.MyScreen00.y)
        X &= " Memory[Phy="
        X &= SHL(My.Computer.Info.AvailablePhysicalMemory.ToString())
        X &= " mb  "
        X &= My.Computer.Info.TotalPhysicalMemory.ToString()
        X &= " mb  "
        X &= " VirMem"
        X &= SHL(My.Computer.Info.AvailableVirtualMemory.ToString())
        X &= " mb  "
        X &= My.Computer.Info.TotalVirtualMemory.ToString()
        X &= " mb  "
        X &= vbTab
        X &= " Memory[Phy="
        X &= ((My.Computer.Info.TotalPhysicalMemory / 1000000) - (My.Computer.Info.AvailablePhysicalMemory / 1000000)).ToString
        X &= "]  [VirMem "
        X &= (My.Computer.Info.TotalVirtualMemory / 1000000) - (My.Computer.Info.AvailableVirtualMemory / 1000000)
        X &= "]"

        Return X
    End Function

    Friend Function MyShowDistance(XY1 As MyPointStructure, XY2 As MyPointStructure) As String
        XY1.Named.IsWorldWindow = WorldOrWindow(XY1)
        XY2.Named.IsWorldWindow = WorldOrWindow(XY2)

        Return SHL(CStr(MyABS(XY1.x - XY2.x) + MyABS(XY1.y - XY2.y))) & SHL(XY1.Named.PathName) & "" & SHL(XY1.Named.SymbolName) & "" & SHL(XY1.Named.PointName) & ", " & SHL(XY2.Named.PathName) & "" & SHL(XY2.Named.SymbolName) & "" & SHL(XY2.Named.PointName) & vbCrLf
    End Function


    Friend Function MyShow2Lines(a As MyLineStructure, b As MyLineStructure) As String
        Return SHL(MyShowALine(a)) & vbTab & SHL((MyShowALine(b)))
    End Function
    Friend Function MyShow3Lines(a As MyLineStructure, b As MyLineStructure, c As MyLineStructure) As String
        If MyDebug(A_FMB) Then logA(3300, MyShowALine(a), MyShowALine(b), MyShowALine(c))
        Return SHL(MyShowALine(a)) & vbTab & SHL((MyShowALine(b)) & vbTab & SHL(MyShowALine(c)))
    End Function

    Friend Function MyShowLineRecord(expanded As Boolean, IndexSymbol As Integer) As String
        Dim RTN As String
        RTN = Symbol_TableCoded_String(IndexSymbol)
        RTN &= "=" & Symbol_TableSymbolName(IndexSymbol)
        RTN &= FD & Symbol_TableX1(IndexSymbol)
        RTN &= FD & Symbol_TableY1(IndexSymbol)
        RTN &= FD & Symbol_Table_X2(IndexSymbol)
        RTN &= FD & Symbol_Table_Y2(IndexSymbol)
        RTN &= FD & Symbol_Table_NameOfPoint(IndexSymbol)
        If expanded = True Then
            RTN &= FD & vbTab & "\index" & IndexSymbol.ToString
            'Lines do not have DataType and IO, they have x2, y2
            'RTN &= FD & Symbol_Table_DataType(IndexSymbol)
            'RTN &= FD & Symbol_Table_InputOutput(IndexSymbol)
        End If
        Return RTN '& vbCrLf
    End Function

    Friend Function MyShowLineXYXY(X1 As Integer, Y1 As Integer, X2 As Integer, Y2 As Integer) As String
        Return MyShowPoint(X1, Y1) & MyShowPoint(X2, Y2)
        Return "(" & X1 & COMMA & Y1 & ")_(" & X2 & COMMA & Y2 & ")"
    End Function
    Friend Function MyShowLineXYXY(XY As MyLineStructure) As String
        Return MyShowPoint(XY.a) & " - " & MyShowPoint(XY.b)
        'Return "(" & XY.a.x & COMMA & XY.a.y & ")_(" & XY.b.x & COMMA & XY.b.y & ")"
    End Function
    Friend Function MyShowRectangle(XY As Rectangle) As String
        Return "(" & XY.X & COMMA & XY.Y & ")_(" & XY.Width & COMMA & XY.Height & ")"
    End Function

    Friend Function MyShowNames(XY As MyLineStructure) As String
        Return MyShowNames(XY.a) & MyShowNames(XY.b)
    End Function
    Friend Function MyShowNames(XY As MyPointStructure) As String
        Dim RTN As String = ""
        If XY.Named.SymbolName <> "" Then RTN &= "S=" & XY.Named.SymbolName & COMMA
        If XY.Named.PathName <> "" Then RTN &= "P=" & XY.Named.PathName & COMMA
        If XY.Named.PointName <> "" Then RTN &= "pt=" & XY.Named.PointName & COMMA
        If XY.Named.IsWorldWindow <> "" Then RTN &= "WW " & XY.Named.IsWorldWindow
        If RTN <> "" Then RTN = "[" & RTN & "]"
        Return RTN
    End Function

    Friend Function MyShowALine(XY As MyLineStructure) As String
        Return "(" & XY.a.x & COMMA & XY.a.y & MyShowNames(XY.a) & ")_(" & XY.b.x & COMMA & XY.b.y & MyShowNames(XY.a) & ")"
    End Function

    Friend Function MyShowPoint(X As Integer, Y As Integer) As String
        Return MyShowPoint(MyPoint1XY(X, Y))
    End Function

    Friend Function MyShowPoints(ByRef SourceForm As Source, X1 As Integer, Y1 As Integer, X2 As Integer, Y2 As Integer) As String
        Return MyShowPoint(MyPoint1XY(X1, Y1)) & " - " & MyShowPoint(MyPoint1XY(X2, Y2))
    End Function


    Friend Function MyShowXY(X As Integer, Y As Integer) As String
        Return "(" & X & COMMA & Y & ")"
    End Function

    Friend Function MyShowPointNames(XY As MyPointStructure) As String
        Dim RTN As String
        RTN = MyShowPoint(XY) & MyShowNames(XY)
        Return RTN
    End Function
    Friend Function MyShowPoint(XY As MyPointStructure) As String
        Return "(" & XY.x & FD & XY.y & ")" '& MyShowNames(XY)
    End Function

    Friend Function MyShowAllNet(ByRef SourceForm As Source, IndexNetLinks As Integer) As String
        Dim I As Integer
        Dim X As String
        Dim A As String
        Dim Del As String
        Del = ""
        A = "["
        X = Net_TableLinks(IndexNetLinks)

        Do
            X = NoFD(X)
            I = PopNonZeroValue(X)
            If MyInStr(FD & FlowChart_TablePathName(SourceForm, I) & FD, A) = 0 Then
                A &= Del & FlowChart_TablePathName(SourceForm, I)
            Else
                If MyDebug(A_FMB) Then
                    logA(1656, X, A, FlowChart_TablePathName(SourceForm, I))
                End If
            End If
            Del = FD
        Loop While Len(X) > 0

        Return A & "]"
    End Function



    Friend Function MyShowNetLinks(ByRef SourceForm As Source, IndexNetLink As Integer) As String
        Return Spaced(24, Net_TablePathNames(IndexNetLink)) & "paths : " & Net_TableLinks(IndexNetLink)
    End Function


    Friend Function MyShowNetLinks(ByRef SourceForm As Source, VariableName As String) As String
        Dim I As Integer
        For I = 0 To SourceForm.ListBoxVariables.Items.Count
            If SourceForm.ListBoxVariables.Items(I).ToString = VariableName Then
                Return VariableName & vbTab & Spaced(24, Net_TablePathNames(I)) & "paths : " & Net_TableLinks(I)
            End If
        Next
        Return ""
    End Function


    '    Friend Function MyShowNetLinks(expanded As Boolean, IndexNetLink As Integer) As String
    '    Return expanded.ToString & "# " &
    '            IndexNetLink.ToString & vbTab &
    '            Spaced(24, Net_TablePathNames(IndexNetLink)) & vbTab & vbTab &
    '            "paths : " & Net_TableLinks(IndexNetLink)
    '    End Function



    Friend Function MyShowKeyWord(Switch As String, KeyWord As String) As String
        Return Switch & "=" & KeyWord
    End Function

    'todo need to make sure that all ⬂*.pathname⬃ is matched
    Friend Function MakeStatementSyntax(ByRef SourceForm As Source, ParsedString() As String) As String
        Const debugLevel As Integer = A_STATUS
        Dim LocalIndex As Integer
        Dim A1, B1, C1, D1 As String
        Dim DeLimit As String
        Dim WS As String
        'todo need to add white space between each 'atom' of the code Line Output
        WS = MyLeft(MyUniverse.SysGen.Constants.ConstantWhiteSpaces, 1)
        MakeStatementSyntax = WS
        ' LocalIndex might be counting twice and missing Syntax
        DeLimit = "" ' Do not start with a comma(or what ever the field delimiter is right now
        LocalIndex = 1

        While PrintAbleNull(ParsedString(LocalIndex)) <> PrintAbleNull(Nothing)
            A1 = ParsedString(LocalIndex)
            B1 = LCase(WhatIsThis(A1))
            'C1=""
            Select Case B1
                Case MyUniverse.ProgramOptions.FCCL_MultiLine
                    MakeStatementSyntax = Trim(MakeStatementSyntax & DeLimit & MyUniverse.ProgramOptions.FCCL_MultiLine) & WS
                Case MyUniverse.SysGen.Markers.BranchToNextLine
                    MakeStatementSyntax = Trim(MakeStatementSyntax & DeLimit & MyUniverse.SysGen.Markers.BranchToNextLine & COMMA & MakePathName(ParsedString(LocalIndex + 1))) & WS 'HACK making it a code keyword BranchTo, hope the computer language has that as a keyword!!!!!!!
                    LocalIndex += 1
                Case MyUniverse.SysGen.Markers.CameFromLine
                    MakeStatementSyntax = Trim(MakeStatementSyntax & DeLimit & MyUniverse.SysGen.Markers.CameFromLine & COMMA & MakePathName(ParsedString(LocalIndex + 1)) & "") & WS
                    LocalIndex += 1
                Case Options.ListBoxSymbolData.Items.Item(21).ToString
                    MakeStatementSyntax = Trim(MakeStatementSyntax & DeLimit & MyUniverse.SysGen.Markers.Comments) & WS
                Case Options.ListBoxSymbolData.Items.Item(25).ToString
                    MakeStatementSyntax = Trim(MakeStatementSyntax & DeLimit & ThisExtension(Options.ListBoxSymbolData.Items.Item(25).ToString, 1)) & WS
                Case MyUniverse.ProgramOptions.FCCL_VarChars 'todo Not so sure about this!!!!!!! ' Possible error
                    MakeStatementSyntax = Trim(MakeStatementSyntax & DeLimit & MyUniverse.SysGen.Markers.BranchToNextLine) & WS
                Case MyUniverse.SysGen.Markers.Comments 'Ignore the rest of the Line
                    'todo need to make a constant record of the comment string
                    MakeStatementSyntax = Trim(MakeStatementSyntax & DeLimit & MyUniverse.SysGen.Markers.Comments) & WS
                Case MyUniverse.SysGen.Markers.Quotes
                    ' Save The First Quote
                    'todo need to better place ALL of the constants from a statement
                    AddFlowChartRecordOther(SourceForm, A1,
"/constant",
                                                MyUniverse.SysGen.PlacementCurrent.x + MyUniverse.SysGen.Constants.ConstantSymbolCenter * 3,
                                                MyUniverse.SysGen.PlacementCurrent.y + MyUniverse.SysGen.Constants.ConstantSymbolCenter * 3,
                                                0, 0, "string")
                    MakeStatementSyntax = Trim(MakeStatementSyntax & DeLimit & MyUniverse.SysGen.Markers.Quotes) & WS
                Case MyUniverse.SysGen.Markers.KeyWords
                    MakeStatementSyntax = Trim(MakeStatementSyntax & DeLimit & AddRM(NoRM(B1) & "." & A1)) & WS' change from keyword to 'keyword.'keyword'
                Case MyUniverse.SysGen.Markers.DataType
                    MakeStatementSyntax = Trim(MakeStatementSyntax & DeLimit & AddRM(NoRM(B1) & "." & A1)) & WS
                Case MyUniverse.SysGen.Markers.Operators
                    MakeStatementSyntax = Trim(MakeStatementSyntax & DeLimit & AddRM(NoRM(B1) & "." & A1)) & WS
                Case MyUniverse.SysGen.Markers.Functions
                    MakeStatementSyntax = Trim(MakeStatementSyntax & DeLimit & MyUniverse.SysGen.Markers.Functions) & WS
                Case MyUniverse.SysGen.Markers.SpecialCharacter
                    MakeStatementSyntax = Trim(MakeStatementSyntax & DeLimit & AddRM(NoRM(B1) & "." & A1)) & WS
                Case MyUniverse.SysGen.Markers.Numbers
                    MakeStatementSyntax = Trim(MakeStatementSyntax & DeLimit & AddRM(NoRM(B1) & "." & A1)) & WS
                Case MyUniverse.SysGen.Markers.Alphas
                    MakeStatementSyntax = Trim(MakeStatementSyntax & DeLimit & MyUniverse.SysGen.Markers.Alphas) & WS
                Case MyUniverse.SysGen.Markers.AlphaNumeric
                    'todo THis needs to be changed to be ⬂VariableName.PATH⬃
                    'MakeStatementSyntax=Trim(MakeStatementSyntax & DeLimit & MyUniverse.SysGen.Markers.Variables)
                    MakeStatementSyntax = Trim(MakeStatementSyntax & DeLimit & MakePathName(A1)) & WS
                Case MyUniverse.SysGen.Markers.FieldDelimiters 'do nothing
                    MakeStatementSyntax = Trim(MakeStatementSyntax & DeLimit & AddRM(NoRM(B1) & "." & A1)) & WS
                Case MyUniverse.SysGen.Markers.Unknowns
                    logA(1662, B1, A1, WhatIsThis(A1), AddRM(NoRM(MyUniverse.SysGen.Markers.Unknowns) & "." & A1))
                    MakeStatementSyntax = Trim(MakeStatementSyntax & DeLimit & A1 & WS)'MyUniverse.SysGen.Markers.Unknowns & A1) & WS
                Case MyUniverse.SysGen.Markers.Grammar
                    'MakeStatementSyntax=Trim(MakeStatementSyntax & DeLimit & MyUniverse.SysGen.Markers.Numbers) & WS
                    MakeStatementSyntax = Trim(MakeStatementSyntax & DeLimit & AddRM(NoRM(B1) & "." & A1)) & WS
                Case MyUniverse.SysGen.Markers.WhiteSpaces
                    MakeStatementSyntax = Trim(MakeStatementSyntax & DeLimit & vbTab) & WS
                Case Else ' This is a variable period pointAttribute
                    C1 = WhatCouldThisBe(SourceForm, A1)
                    Select Case C1
                        Case "BLOCK, Special Character, "
                            MakeStatementSyntax = Trim(MakeStatementSyntax & DeLimit & WhatIsThis(A1)) & WS
                        Case "White Space, "
                            MakeStatementSyntax = Trim(MakeStatementSyntax & DeLimit & WhatIsThis(A1)) & WS
                                'ignore white space
                        Case "Literal, "
                            MakeStatementSyntax = Trim(MakeStatementSyntax & DeLimit & WhatIsThis(A1)) & WS
                        Case "Literal, Terminal, "
                            MakeStatementSyntax = Trim(MakeStatementSyntax & DeLimit & WhatIsThis(A1)) & WS
                        Case "Marker, Marker 2, Keyword, Marker 2, "
                            MakeStatementSyntax = Trim(MakeStatementSyntax & DeLimit & A1) & WS
                        Case "Marker, Marker 2, Marker 2, "
                            D1 = WhatCouldThisBe(SourceForm, NoRM(C1))
                            Select Case D1
                                Case "Variable Name, Letter, ", "Marker, Marker 2, Marker 2, "
                                    MakeStatementSyntax = Trim(MakeStatementSyntax & DeLimit & B1) & WS
                                Case Else 'todo need to add something here
                                    logA(2173, A1, B1, C1, D1)
                            End Select
                        Case "Special Character, "
                            MakeStatementSyntax = Trim(MakeStatementSyntax & DeLimit & B1) & WS
                            A1 = "" : B1 = ""
                        Case "Variable Name, "
                            MakeStatementSyntax = Trim(MakeStatementSyntax & DeLimit & AddRM(NoRM(WhatIsThis(A1)) & ".PathName")) & WS
                        Case "Variable Name, Letter, PointAttribute, "
                            MakeStatementSyntax = Trim(MakeStatementSyntax & DeLimit & AddRM(NoRM(WhatIsThis(A1)) & ".PathName")) & WS
                            A1 = "" : B1 = ""
                        Case "Variable Name, Letter, "
                            MakeStatementSyntax = Trim(MakeStatementSyntax & DeLimit & AddRM(NoRM(WhatIsThis(A1)) & ".PathName")) & WS
                            A1 = "" : B1 = ""
                        Case "Variable Name, Letter, Hex_Digit, "
                            MakeStatementSyntax = Trim(MakeStatementSyntax & DeLimit & AddRM(NoRM(WhatIsThis(A1)) & ".PathName")) & WS
                            A1 = "" : B1 = ""
                        Case "Variable Name, Number, Hex_Digit, "
                            MakeStatementSyntax = Trim(MakeStatementSyntax & DeLimit & AddRM(NoRM(WhatIsThis(A1)) & ".PathName")) & WS
                        Case "Variable Name, Letter, Hex_Range, "
                            MakeStatementSyntax = Trim(MakeStatementSyntax & DeLimit & AddRM(NoRM(WhatIsThis(A1)) & ".PathName")) & WS
                        Case Else
                            logA(1574, A1, B1, C1, WhatCouldThisBe(SourceForm, NoRM(C1)))
                            MakeStatementSyntax = Trim(MakeStatementSyntax & DeLimit & WhatIsThis(A1)) & WS
                    End Select
                    If MyDebug(debugLevel) Then logA(1633, MakeStatementSyntax)
                    If MyInStr(".", A1) <> 0 Then
                        If MyInStr(MyUniverse.SysGen.Constants.RMStart, A1) > 0 Then
                            If MyInStr(MyUniverse.SysGen.Constants.RMEnd, A1) > 0 Then
                                MakeStatementSyntax = Trim(MakeStatementSyntax & DeLimit & MakePathName(A1)) & WS
                            Else
                                logA(1663, MyUniverse.SysGen.Constants.RMEnd, A1, MyUniverse.SysGen.Constants.RMStart)
                            End If
                        Else
                            MakeStatementSyntax = Trim(MakeStatementSyntax & DeLimit & A1) & WS
                        End If
                    Else
                        If MyLeft(A1, Len(MyUniverse.SysGen.Constants.RMStart & "'")) = MyUniverse.SysGen.Constants.RMStart & "'" Then
                            If MyRight(A1, Len("'" & MyUniverse.SysGen.Constants.RMEnd)) = "'" & MyUniverse.SysGen.Constants.RMEnd Then
                                MakeStatementSyntax &= DeLimit & A1 & WS
                            Else
                                logA(1664, MyUniverse.SysGen.Constants.RMEnd, MyUniverse.SysGen.Constants.RMStart)
                            End If
                        Else
                            If A1 <> "" Or B1 <> "" Then
                                'a1? b1? c1? 
                                MakeStatementSyntax &= DeLimit & B1 & WS
                                logA(1665, A1, WhatIsThis(A1), WhatCouldThisBe(SourceForm, A1), B1, C1)
                            End If
                            'MakeStatementSyntax &= MyUniverse.SysGen.Constants.RMStart & MyTrim(A1) & ".PathName" & MyUniverse.SysGen.Constants.RMEnd
                        End If
                    End If
            End Select
            LocalIndex += 1
            DeLimit = FD ' Now make everything separated with a Field DeLimiter
            If MyDebug(A_DISPLAY) Then logA(1581, MakeStatementSyntax)
        End While

        If MyRight(MakeStatementSyntax, Len(FD)) <> FD Then
            MakeStatementSyntax &= FD
        End If
    End Function


    Friend Function FindSymbolSyntax(ByRef SourceForm As Source, KeyLine As String) As Integer ' This will return the Named_File(index) of the matching Syntax
        Dim Syntax1, SyntaxArray(1) As String
        Dim SymbolName As String
        Dim Debug1 As Integer ', Debug2 
        'todo need to add to make a Symbol from the /Grammar if no syntax found
        'create symbol name
        SymbolName = MakeNewName(SourceForm, "SYMBOL_", KeyLine)
        'see if that name has already been used
        MyParse(SyntaxArray, KeyLine)
        Syntax1 = MakeStatementSyntax(SourceForm, SyntaxArray)
        Debug1 = BinarySearch4Index(Options.ListBoxSymbols, Syntax1) 'TPar)
        If Debug1 > 0 Then
            Return Debug1
        End If
        Return ConstantMyErrorCode
    End Function

    Friend Function MyCompareSyntax(A1 As String, A2 As String) As Boolean
        Dim S1(0) As String
        Dim S2(0) As String
        Dim I As Integer

        If A1 = A2 Then Return True

        MyParse(S1, A1)
        MyParse(S2, A2)

        If MySizeOf(S1) <> MySizeOf(S2) Then Return False

        For I = 1 To MySizeOf(S1)
            If NoRM(S1(I)) <> NoRM(S2(I)) Then Return False
        Next
        Return True
    End Function
    Friend Function MyCompareSyntax(ByRef SourceForm As Source) As String
        Dim ParsedItem, MyErrors As Integer
        MyErrors = 1024
        ' for now stupid comparison test
        ParsedItem = 0
        MyCompareSyntax = "equal"


        While MyErrors > 1
            Select Case LCase(NoRM(WhatIsThis(MyUniverse.MyStaticData.My_Syntax_Line_Parsed(ParsedItem))))
                Case Options.ListBoxSymbolData.Items.Item(21).ToString
                Case Options.ListBoxSymbolData.Items.Item(25).ToString
                Case MyUniverse.ProgramOptions.FCCL_MultiLine
                Case MyUniverse.ProgramOptions.FCCL_VarChars
                Case MyUniverse.SysGen.Markers.CameFromLine
                    If Not Do_Not_Use_IsThisACameFromLine(MyUniverse.MyStaticData.My_Code_Line_Parsed(ParsedItem)) Then
                        MyCompareSyntax = "notEqual"

                        Exit Function
                    End If
                Case MyUniverse.SysGen.Markers.BranchToNextLine
                    If Not Do_Not_Use_IsThisABranchToNextLine(MyUniverse.MyStaticData.My_Code_Line_Parsed(ParsedItem)) Then
                        MyCompareSyntax = "notEqual"

                        Exit Function
                    End If
                Case MyUniverse.SysGen.Markers.Comments ' The rest is all comment 
                    If Not Do_Not_Use_IsThisAComment(MyUniverse.MyStaticData.My_Code_Line_Parsed(ParsedItem)) Then
                        MyCompareSyntax = "notEqual"

                        Exit Function
                    End If
                Case MyUniverse.SysGen.Markers.KeyWords, MyUniverse.SysGen.Markers.Functions, MyUniverse.SysGen.Markers.Operators 'must match exactly
                    Select Case MyCompareSyntax_S(MyUniverse.MyStaticData.My_Syntax_Line_Parsed(ParsedItem), MyUniverse.MyStaticData.My_Code_Line_Parsed(ParsedItem))
                        Case "equal"
                            MyCompareSyntax = "notEqual"

                            Exit Function
                        Case "notEqual"
                        Case Else
                            logA(2089, MyUniverse.MyStaticData.My_Code_Line_Parsed(ParsedItem))
                    End Select
                Case MyUniverse.SysGen.Markers.SpecialCharacter 'must match exactly
                    Select Case MyCompareSyntax_S(MyUniverse.MyStaticData.My_Syntax_Line_Parsed(ParsedItem), MyUniverse.MyStaticData.My_Code_Line_Parsed(ParsedItem))
                        Case "notEqual"
                            MyCompareSyntax = "notEqual"

                            Exit Function
                        Case "equal"
                        Case Else
                            logA(2090, MyUniverse.MyStaticData.My_Syntax_Line_Parsed(ParsedItem))
                    End Select
        'Case MyUniverse.SysGen.Markers.Variables
        '    If Not  Do_Not_Use_IsThisAVariableName(MyUniverse.MyStaticData.My_Code_Line_Parsed(ParsedItem)) Then
        '    MyCompareSyntax="notEqual"
        '    Exit Function
    '    End If
                Case MyUniverse.SysGen.Markers.Quotes
                    If Not Do_Not_Use_IsThisAQuote(MyUniverse.MyStaticData.My_Code_Line_Parsed(ParsedItem)) Then
                        MyCompareSyntax = "notEqual"

                        Exit Function
                    End If
                Case MyUniverse.SysGen.Markers.Alphas
                    If Not Do_Not_Use_IsThisAnAlpha(SourceForm, MyUniverse.MyStaticData.My_Code_Line_Parsed(ParsedItem)) Then
                        MyCompareSyntax = "notEqual"

                        Exit Function
                    End If
                Case MyUniverse.SysGen.Markers.Numbers
                    If Not Do_Not_Use_IsThisANumber(SourceForm, MyUniverse.MyStaticData.My_Code_Line_Parsed(ParsedItem)) Then
                        MyCompareSyntax = "notEqual"

                        Exit Function
                    End If
                Case Nothing ' ran out of Syntax to compare to
                    MyCompareSyntax = "notEqual"

                    Exit Function
                Case MyUniverse.SysGen.Markers.Unknowns ' DoNot know what it is but it is not a good syntax
                    'If MyUniverse.MyStaticData.My_Code_Line_Parsed(ParsedItem)) Then
                    MyCompareSyntax = "notEqual"

                    Exit Function
                    'End If
                Case Else
                    If IsThisAVariable(MyUniverse.MyStaticData.My_Code_Line_Parsed(ParsedItem)) <> "" Then
                        MyCompareSyntax = "notEqual"
                        Exit Function
                    End If
            End Select
            ParsedItem += 1
        End While

    End Function


    Friend Function MakeConstant(ByRef SourceForm As Source, X As Integer, Y As Integer, Constant As String) As Integer
        Return AddFlowChartRecordOther(SourceForm, Constant, "/constant", X, Y, 0, 0, "String")
    End Function



    Friend Sub MakeUseANDPath(ByRef SourceForm As Source, Code_Line As String, SymbolName As String, IndexSymbol As Integer)
        Dim MyIndex, IndexFlowChart, I1, I2, I4 As Integer
        Dim Offxs, Offys As Integer 'symbol point offset 
        Dim TempXY As MyLineStructure
        'Might also assume that we can go through all of the points and only pick the ones that are not logic
        Dim PointNumber As Integer = 3 'assumed that every symbol has a goTo and cameFrom and the third point is a variable point?
        Dim FCCLRecord As FCCL_FlowChart = Nothing
        Dim PathNameS As String 'all of the path names for this line of code
        Dim PathName As String ' the path name that is currently working on
        Dim Temp As String
        Dim ThisDataType As String = ""

        Dim DebugLevel As Integer = A_DISPLAY

        Dim CollectNames(10) As String
        Dim MyArray(0) As String
        '0=Symbol names
        '1=path names
        '2=quotes, blocks comments
        '3=Variable name (Should match #1)
        '4=Keywords
        '5=special characters, operators
        '6=DataTypes
        '7=Numbers
        '8=nothing, Not defined
        '9=

        For I1 = LBound(CollectNames) To MySizeOf(CollectNames) : CollectNames(I1) = "" : Next
        CollectNames(0) &= vbTab & vbTab & SymbolName

        PathNameS = MyParse(MyArray, Code_Line)
        logA(4331, MyUniverse.MyStaticData.LastDataType)

        For I1 = LBound(MyArray) To MySizeOf(MyArray)
            If IsthisADataType(MyArray(I1)) <> "" Then
                ThisDataType &= FD & MyArray(I1)
            End If
        Next
        If Len(ThisDataType) < 3 Then
            ThisDataType = "," & MyUniverse.MyStaticData.LastDataType
        End If

        If PathNameS <> "," And PathNameS <> "" Then
            CollectNames(1) &= vbTab & vbTab & PathNameS
        Else
            'todo if there is no point names 
            PathNameS = "" ' "Errored_" & MyRnd(5) & NoFD(ThisDataType) 'END SUB and other compiler directives with no changes in the data
        End If

        If MyDebug(DebugLevel) Then logA(3316, SymbolName, Code_Line)
        If Len(Trim(Code_Line)) = 0 Then
            logA(1540)
            Return
        End If

        If Len(SymbolName) < 2 Then
            SymbolName = MakeNewName(SourceForm, "Copy_3_" & Symbol_TableSymbolName(IndexSymbol), SymbolName)
            CollectNames(0) &= FD & vbTab & vbTab & SymbolName
        End If
        FCCLRecord.PathSymbolName = SymbolName
        FCCLRecord.Coded = My_KeyConstUse ' MyKeyword2Number(My_keyWord(My_KeyConstUse))
        FCCLRecord.X1 = MyUniverse.SysGen.PlacementCurrent.x
        FCCLRecord.Y1 = MyUniverse.SysGen.PlacementCurrent.y
        FCCLRecord._X2_Rotation = 5 'default
        FCCLRecord._Y2_Option = 0

        If CheckFlowChartExist(SourceForm, FCCLRecord) Then
            logA(1647, Code_Line, SymbolName)
        Else
            'todo need to get the datatype of this path
            Temp = FindDataTypeAt(SourceForm, MyUniverse.SysGen.PlacementCurrent.x, MyUniverse.SysGen.PlacementCurrent.y)
            'todo fix this kludge 
            If MyTrim(Temp) = "Errored" Then
                logA(1152, MyUniverse.MyStaticData.LastDataType)
                logA(1092, Temp, PathNameS)
                Temp = ""

                For I4 = 1 To MySizeOf(MyArray)
                    If IsthisADataType(MyArray(I4)) <> "" Then
                        Temp &= MyArray(I4) & ", "
                    End If
                    If Len(MyArray(I4)) = 0 Then Exit For
                Next

            End If


            IndexFlowChart = AddFlowChartRecordUse(SourceForm, SymbolName, My_keyWord(My_KeyConstUse), MyUniverse.SysGen.PlacementCurrent.x, MyUniverse.SysGen.PlacementCurrent.y, "Default", Temp) 'no DataType, no links
            PaintAll(SourceForm, IndexFlowChart, IndexFlowChart)
        End If

        MyIndex = 1
        If MySizeOf(MyArray) > 1 Then


            While PrintAbleNull(MyArray(MyIndex)) <> PrintAbleNull(Nothing)
                Offxs = MyUniverse.MySymbolPoints(PointNumber).x
                Offys = MyUniverse.MySymbolPoints(PointNumber).y
                If MyDebug(A_DISPLAY) Then logA(1178, MyArray(MyIndex), WhatIsThis(MyArray(MyIndex)), WhatCouldThisBe(SourceForm, MyArray(MyIndex)))
                Temp = WhatCouldThisBe(SourceForm, MyArray(MyIndex))
                Select Case Temp
                    Case "BLOCK, Quote, Special Character, "
                        CollectNames(2) &= FD & vbTab & vbTab & Temp & "   =   " & MyArray(MyIndex)
                    Case "Comment, BLOCK, Literal, "
                        CollectNames(2) &= FD & vbTab & vbTab & Temp & "   =   " & MyArray(MyIndex)
                    Case "Comment, BLOCK, Keyword, Literal, "
                        CollectNames(2) &= FD & vbTab & vbTab & Temp & "   =   " & MyArray(MyIndex)
                    Case "Comment, CommentMark, Special Character, "
                        CollectNames(8) &= FD & vbTab & vbTab & Temp & "   =   " & MyArray(MyIndex)
                        I2 = MakeConstant(SourceForm, MyUniverse.SysGen.PlacementCurrent.x + Offxs, MyUniverse.SysGen.PlacementCurrent.y + Offys + MyUniverse.SysGen.Snaps.MySymbolSnap * 2, MyArray(MyIndex))
                        PaintAll(SourceForm, I2, I2)
                    Case "Comment, Keyword, Special Character, "
                        CollectNames(2) &= FD & vbTab & vbTab & Temp & "   =   " & MyArray(MyIndex)
                    Case "Variable Name, Letter, ", "Variable Name, Letter, Hex_Digit, "
                        CollectNames(3) &= FD & vbTab & vbTab & Temp & "   =   " & MyArray(MyIndex)
                        Offxs = MyUniverse.MySymbolPoints(PointNumber).x
                        Offys = MyUniverse.MySymbolPoints(PointNumber).y
                        PathNameS = MyTrim(PathNameS)
                        PathName = Pop(PathNameS, FD)
                        TempXY = OtherEndOfNewMadePath(SourceForm, MyUniverse.SysGen.PlacementCurrent.x, MyUniverse.SysGen.PlacementCurrent.y, Offxs, Offys, PathName)
                        'todo this should have the data type not 'Error'
                        IndexFlowChart = AddFlowChartRecordPath(SourceForm, PathName, "/path", TempXY.a.x, TempXY.a.y, TempXY.b.x, TempXY.b.y, FlowChart_TableDataType(SourceForm, IndexFlowChart)) 'todo need data type for this path'
                        PaintAll(SourceForm, IndexFlowChart - 1, IndexFlowChart + 2)
                        PointNumber += 1
                    Case "Keyword, Function Name, Variable Name, Letter, ", "Keyword, Variable Name, Letter, "
                        CollectNames(4) &= FD & vbTab & vbTab & Temp & "   =   " & MyArray(MyIndex)
                            'keyword is in the symbol syntax defination
                    Case "Special Character, "
                        CollectNames(5) &= FD & vbTab & vbTab & Temp & "   =   " & MyArray(MyIndex)
                            'special characters is part of the syntax in the symbol
                    Case "DataType, Variable Name, Letter, "
                        CollectNames(6) &= FD & vbTab & vbTab & Temp & "   =   " & MyArray(MyIndex)
                        ThisDataType &= FD & MyArray(MyIndex)
                            'todo if only one dataType and One point then change the one point to this data type and connecting path
                            'todo if only one data type then change all non logic points to this data type. (Assume that this one data type defines all of the non defined points)
                            'todo if number of dataTypes match the number of non logic points then make each point a different data type
                            'todo This is a datatype and if there is just one data type or just one variable name then change it/them
                    Case "Keyword, DataType, Variable Name, Letter, "
                        CollectNames(4) &= FD & vbTab & vbTab & Temp & "   =   " & MyArray(MyIndex)
                    Case "Operator, Special Character, "
                        CollectNames(5) &= FD & vbTab & vbTab & Temp & "   =   " & MyArray(MyIndex)
                            'This is an operator 
                    Case "Number, Hex_Digit, "
                        CollectNames(7) &= FD & vbTab & vbTab & Temp & "   =   " & MyArray(MyIndex)
                    Case "Comment, Special Character, "
                        CollectNames(2) &= FD & vbTab & vbTab & Temp & "   =   " & MyArray(MyIndex)
                        'todo Need to fix this hack  -  This is a comment (Make Comment)
                        I2 = MakeConstant(SourceForm, MyUniverse.SysGen.PlacementCurrent.x + Offxs, MyUniverse.SysGen.PlacementCurrent.y + Offys + MyUniverse.SysGen.Snaps.MySymbolSnap * 2, MyArray(MyIndex))
                        PaintAll(SourceForm, I2, I2)
                    Case "Number, Special Character, "
                        CollectNames(7) &= FD & vbTab & vbTab & Temp & "   =   " & MyArray(MyIndex)
                            'This is a negative number
                    Case "Operator, Extension, Special Character, " 'period
                        CollectNames(7) &= FD & vbTab & vbTab & Temp & "   =   " & MyArray(MyIndex)
                    Case Nothing
                        CollectNames(8) &= FD & vbTab & vbTab & Temp & "   =   " & MyArray(MyIndex)
                    Case Else
                        CollectNames(8) &= FD & vbTab & vbTab & Temp & "   =   " & MyArray(MyIndex)
                        logA(1648, MyArray(MyIndex), WhatCouldThisBe(SourceForm, MyArray(MyIndex)))
                End Select
                MyIndex += 1
            End While
        End If
        Return 'ConstantMyErrorCode
    End Sub ' end make use and make path

    Friend Function SymbolNameFromCodeLine(ByRef SourceForm As Source, CodeLine As String) As String
        Return SymbolNameFromCodeLine1(SourceForm, CodeLine)
    End Function


    Friend Function CreateFileNameFromSyntax(ByRef SourceForm As Source, SyntaxLine As String) As String
        Return CreateFileNameFromSyntax1(SourceForm, SyntaxLine)
    End Function
    Friend Function CreateFileNameFromSyntax1(ByRef SourceForm As Source, SyntaxLine As String) As String
        Dim X, EXT As String
        Dim I As Integer

        If MyDebug(A_DISPLAY) Then
            logA(3317, SyntaxLine)
        End If

        EXT = ""
        X = SyntaxLine
        CreateFileNameFromSyntax1 = ""

        While Len(X) > 0
            X = MyTrim(X)
            Select Case LCase(WhatIsThis(X))
                Case MyUniverse.SysGen.Markers.FieldDelimiters
                    X = Mid(X, Len(FD) + 1, Len(X))
                Case MyUniverse.ProgramOptions.FCCL_MultiLine
                    Pop1(SourceForm, X, FD)
                    CreateFileNameFromSyntax1 &= "a"
                Case MyUniverse.SysGen.Markers.CameFromLine
                    CreateFileNameFromSyntax1 &= "g"
                    Pop1(SourceForm, X, FD)
                Case MyUniverse.SysGen.Markers.BranchToNextLine
                    CreateFileNameFromSyntax1 &= "c"
                    Pop1(SourceForm, X, FD)
                Case Options.ListBoxSymbolData.Items.Item(21).ToString, "comment"
                    CreateFileNameFromSyntax1 &= "Q"
                    Pop1(SourceForm, X, FD)
                Case Options.ListBoxSymbolData.Items.Item(25).ToString
                    EXT = Pop(X, FD) ' Save the extension till last
                    CreateFileNameFromSyntax1 &= "e"
                Case MyUniverse.ProgramOptions.FCCL_VarChars
                    CreateFileNameFromSyntax1 &= Pop1(SourceForm, X, FD)
                Case MyUniverse.SysGen.Markers.Comments 'Ignore the rest of the Line
                    CreateFileNameFromSyntax1 &= "h"
                    PopLine(X)
                Case MyUniverse.SysGen.Markers.Quotes
                    'CreateFileNameFromSyntax1 &=
                    PopQuote(X) 'Throw quote away???
                    CreateFileNameFromSyntax1 &= "q"
                Case MyUniverse.SysGen.Markers.KeyWords
                    CreateFileNameFromSyntax1 &= Pop(X, FD)'Save the actual keyword ... 
                Case MyUniverse.SysGen.Markers.Functions
                    CreateFileNameFromSyntax1 &= "f"
                    Pop(X, FD)
                Case MyUniverse.SysGen.Markers.Operators
                    CreateFileNameFromSyntax1 &= "o"
                    Pop(X, FD)'Save the actual keyword ... 
                Case MyUniverse.SysGen.Markers.Alphas
                    CreateFileNameFromSyntax1 &= "l"
                    Pop1(SourceForm, X, FD)'should be a variable name
                Case MyUniverse.SysGen.Markers.Numbers
                    Pop(X, FD) 'treated as a variable name
                    CreateFileNameFromSyntax1 &= "3"
                Case MyUniverse.SysGen.Markers.SpecialCharacter
                    Pop(X, FD)
                    CreateFileNameFromSyntax1 &= "_"
        'Case MyUniverse.SysGen.Markers.Variables
        '    CreateFileNameFromSyntax1 &= "V"
    '    Pop1(SourceForm, X, FD)
                Case MyUniverse.SysGen.Markers.Unknowns
                    CreateFileNameFromSyntax1 &= "_"
                    Pop(X, FD)
                Case Else
                    If IsThisAVariable(NoRM(WhatIsThis(X))) <> "" Then
                        CreateFileNameFromSyntax1 &= "V"
                    Else
                        CreateFileNameFromSyntax1 &= WhatIsThis(X)
                    End If
                    Pop1(SourceForm, X, FD)
            End Select
        End While


        ' re-moved any special characters from the file name

        For I = 1 To Len(CreateFileNameFromSyntax1)

            While Do_Not_Use_IsThisASpecialCharacter(SourceForm, Mid(CreateFileNameFromSyntax1, I, 1)) And PrintAbleNull(Mid(CreateFileNameFromSyntax1, I, 1)) <> PrintAbleNull(Nothing)
                CreateFileNameFromSyntax1 = Mid(CreateFileNameFromSyntax1, 1, I - 1) & Mid(CreateFileNameFromSyntax1, I + 1, Len(CreateFileNameFromSyntax1))
                '2020 0907    mid(CreateFileNameFromSyntax1, I, 1)="_" ' Over ride any left over special characters with an underscore
            End While


            While WhatIsThis(Mid(CreateFileNameFromSyntax1, I, 1)) <> "BLANK"
                CreateFileNameFromSyntax1 = Mid(CreateFileNameFromSyntax1, 1, I - 1) & Mid(CreateFileNameFromSyntax1, I + 1, Len(CreateFileNameFromSyntax1))
            End While

        Next

        If CreateFileNameFromSyntax1 = "" Or MyIsNothing(CreateFileNameFromSyntax1) Then
            CreateFileNameFromSyntax1 = MakeNewName(SourceForm, "FileName_", SyntaxLine) & ".Symbol"
        Else
            'need to know if it will become a Symbol or will become program code
            If EXT = "" Then
                CreateFileNameFromSyntax1 &= ".Symbol"
            Else
                CreateFileNameFromSyntax1 &= "." & EXT
            End If
        End If
    End Function

    Friend Sub MakeSymbolPoints(X1 As Integer, Y1 As Integer, MySymbolName As String, CodeLine As String)
        Dim PathNames, PointName As String
        Dim MyArray(0) As String
        Dim I As Integer = 1
        Dim X2, Y2 As Integer
        PathNames = MyParse(MyArray, CodeLine)
        logA(1093, X1.ToString, Y1.ToString, MySymbolName, CodeLine)

        'todo MAKE SURE THAT YOU ADD CAMEFROM AND BRANCHTO TO THE SYNTAX

        X2 = MyUniverse.MySymbolPoints(I).x
        Y2 = MyUniverse.MySymbolPoints(I).y
        AddNEWSymbolPointRecord(Source, MySymbolName, "/point", X2, Y2, "input", "Logic", "CameFrom")
        I += 1
        X2 = MyUniverse.MySymbolPoints(I).x
        Y2 = MyUniverse.MySymbolPoints(I).y
        'todo This needs to be fix to be the right goTo label instead of 'branchTo'
        AddNEWSymbolPointRecord(Source, MySymbolName, "/point", X2, Y2, "Output", "Logic", "BranchTo")
        I += 1


        If PathNames = "," Then PathNames = ""
        While Len(PathNames) > 0
            PathNames = MyTrim(PathNames)
            PointName = Pop(PathNames, FD)
            X2 = MyUniverse.MySymbolPoints(I).x
            Y2 = MyUniverse.MySymbolPoints(I).y

            '''''If FindDataTypeIndex(PointName) > 0 Then
            AddNEWSymbolPointRecord(Source, MySymbolName, "/point", X2, Y2, "both", DataType_TableName(FindDataTypeIndex(PointName)), PointName)
            '''''Else
            '''''AddNEWSymbolPointRecord(Source, MySymbolName, "/point", X2, Y2, "both", BinarySearchList(Options.ListBoxDataTypes, MyUniverse.MyStaticData.LastDataType, X2, Y2), PointName)
            '''''End If
            I += 1
        End While

    End Sub



    Friend Sub MakeSymbolOutLine(ByRef SourceForm As Source, MySymbolName As String)
        Dim I As Integer
        CorrectingIndexes(SourceForm, MySymbolName)
        I = MyUniverse.SysGen.Constants.ConstantSymbolCenter
        'todo need to move this 6 spaces

        AddNEWSymbolLineRecord(SourceForm, MySymbolName, "/Line", I, I, I, -I, RandomColor(SourceForm))
        AddNEWSymbolLineRecord(SourceForm, MySymbolName, "/Line", I, -I, -I, -I, RandomColor(SourceForm))
        AddNEWSymbolLineRecord(SourceForm, MySymbolName, "/Line", -I, -I, -I, I, RandomColor(SourceForm))
        AddNEWSymbolLineRecord(SourceForm, MySymbolName, "/Line", -I, I, I, I, RandomColor(SourceForm))
        AddNEWSymbolLineRecord(SourceForm, MySymbolName, "/Line", I, I, -I, -I, RandomColor(SourceForm))
        AddNEWSymbolLineRecord(SourceForm, MySymbolName, "/Line", -I, I, I, -I, RandomColor(SourceForm))

    End Sub



    Friend Function MakeSymbolFromSyntax(ByRef SourceForm As Source, CodeLine As String) As Integer
        Dim IndexSymbol, IndexFlowChart, IndexNamed As Integer ', SavedSymbolIndex 
        Dim MySymbolName As String
        Dim SyntaxLine As String
        Dim debugLevel As Integer = A_DISPLAY
        Dim I, x1, y1 As Integer
        '  DIM   D As Integer
        Dim TempXY As MyLineStructure
        Dim PointCount As Integer
        Dim PointsCounted As Integer
        Dim FCCLRecord As FCCL_FlowChart = Nothing

        If MyDebug(A_DISPLAY) Then logA(3319, CodeLine)

        'todo needs to make sure that this name was not already used (not likely, but possible)
        If CodeLine = "" Then Return ConstantMyErrorCode  ' Return MakeSymbolFromSyntax("Empty_" & CodeLine & MyRnd(7).ToString)

        '?MakeSymbolFromSyntax=0 ' named index
        MyParse(MyUniverse.MyStaticData.My_Syntax_Line_Parsed, CodeLine)
        PointsCounted = CountPathNames(SourceForm, MyUniverse.MyStaticData.Path_Names)


        SyntaxLine = MicroCodeText2Syntax(SourceForm, MyUniverse.MyStaticData.My_Syntax_Line_Parsed, CodeLine)

        MySymbolName = Trim(MakeNewName(SourceForm, "S_", CodeLine)) '& keyWordForCodeLine(CodeLine)

        ' 2020 08 06 added to make a named record first

        AddNewNamedRecord(SourceForm, MySymbolName, CodeLine, "nop", "Made With DeCompile", CreateFileNameFromSyntax(SourceForm, SyntaxLine), "FlowChart Decompile", ".01", "", SyntaxLine) ', MyUniverse.ProgramOptions.FCCL_LanguageClassName
        If PointsCounted = 0 Then
            AddNEWSymbolPointRecord(Source, MySymbolName, "/Name", 0, 0, MyUniverse.ProgramOptions.SelectedInputOutput, MyUniverse.ProgramOptions.SelectedDataType, My_VariableName(SourceForm, I))
        End If

        For I = 1 To PointsCounted
            'todo 
            AddNEWSymbolPointRecord(Source, MySymbolName, "/Name", 0, 0, MyUniverse.ProgramOptions.SelectedInputOutput, MyUniverse.ProgramOptions.SelectedDataType, My_VariableName(SourceForm, I))
            'todo This should NOT be my variable() but the name of the point in code Line
        Next I



        FCCLRecord.PathSymbolName = MySymbolName
        FCCLRecord.Coded = My_KeyConstUse
        FCCLRecord.X1 = MyUniverse.SysGen.PlacementCurrent.x
        FCCLRecord.Y1 = MyUniverse.SysGen.PlacementCurrent.y
        FCCLRecord._X2_Rotation = 0 '"Default"
        FCCLRecord._Y2_Option = 0 '"Error ed"
        If CheckFlowChartExist(SourceForm, FCCLRecord) Then

        Else
            logA(4310, MyUniverse.MyStaticData.LastDataType)
            IndexFlowChart = AddFlowChartRecordUse(SourceForm, MySymbolName, My_keyWord(My_KeyConstUse), MyUniverse.SysGen.PlacementCurrent.x, MyUniverse.SysGen.PlacementCurrent.y, "Default", "Errored")
            PaintAll(SourceForm, IndexFlowChart, IndexFlowChart)
        End If
        MyUniverse.MyStaticData.Path_Names = MyParse(MyUniverse.MyStaticData.My_Code_Line_Parsed, CodeLine)
        MyUniverse.MyStaticData.Path_NamesCounted = CountPathNames(SourceForm, MyUniverse.MyStaticData.Path_Names)
        SyntaxLine = MakeStatementSyntax(SourceForm, MyUniverse.MyStaticData.My_Syntax_Line_Parsed)
        ' This should decompile a Line of code, add a Symbol, and Lines and a syntax for it.
        IndexSymbol = FindInSymbolList(SourceForm, MySymbolName) ' Should Never Happen
        If IndexSymbol < 1 Then
            AddNEWSymbolPointRecord(Source, MySymbolName, "/name", 0, 0, MyUniverse.ProgramOptions.SelectedInputOutput, MyUniverse.ProgramOptions.SelectedDataType, "") 'SyntaxLine) No Options for now ' This is adding a /name that should have already been added.
            IndexSymbol = FindInSymbolList(SourceForm, MySymbolName) ' Should Never Happen
            If MyOptionTest(34) Then PanToWindowXY(SourceForm, MyUniverse.SysGen.PlacementCurrent.x, MyUniverse.SysGen.PlacementCurrent.y)
        Else
            ' Should not happen, but why are we adding a name record, when we just found a name record?
        End If
        'SavedSymbolIndex=IndexSymbol
        PointCount = 0
        I = 1
        PointCount = MyMinMax(PointCount, 0, MyUniverse.MyStaticData.Path_NamesCounted)

        While I < MySizeOf(MyUniverse.MyStaticData.My_Syntax_Line_Parsed)
            If Len(WhatIsThis(MyUniverse.MyStaticData.My_Syntax_Line_Parsed(I))) > 0 Then
                logA(1588, MyUniverse.MyStaticData.My_Syntax_Line_Parsed(I), WhatCouldThisBe(SourceForm, MyUniverse.MyStaticData.My_Syntax_Line_Parsed(I)), WhatIsThis(MyUniverse.MyStaticData.My_Syntax_Line_Parsed(I)), I.ToString)
            End If
            Select Case WhatIsThis(MyUniverse.MyStaticData.My_Syntax_Line_Parsed(I))
                Case Nothing         'do nothing (emptying out the array )
                Case MyUniverse.SysGen.Markers.Comments
                    If MyDebug(debugLevel) Then logA(1691, "comment ", MyUniverse.MyStaticData.My_Syntax_Line_Parsed(I))
                Case MyUniverse.SysGen.Markers.KeyWords
                    If MyDebug(debugLevel) Then logA(1691, "keyword", MyUniverse.MyStaticData.My_Syntax_Line_Parsed(I))
                Case MyUniverse.SysGen.Markers.SpecialCharacter
                    If MyDebug(debugLevel) Then logA(1691, "special character ", MyUniverse.MyStaticData.My_Syntax_Line_Parsed(I))
                Case MyUniverse.SysGen.Markers.Functions
                    If MyDebug(debugLevel) Then logA(1691, "Function", MyUniverse.MyStaticData.My_Syntax_Line_Parsed(I))
                Case MyUniverse.SysGen.Markers.Operators
                    If MyDebug(debugLevel) Then logA(1691, "operator ", MyUniverse.MyStaticData.My_Syntax_Line_Parsed(I))
                Case MyUniverse.SysGen.Markers.Quotes, MyUniverse.SysGen.Markers.Alphas, MyUniverse.SysGen.Markers.Numbers, MyUniverse.SysGen.Markers.Unknowns, MyUniverse.SysGen.Markers.CameFromLine, MyUniverse.SysGen.Markers.BranchToNextLine
                    PointCount = MyMinMax(PointCount + 1, 0, MyUniverse.MyStaticData.Path_NamesCounted)
                    'todo the point count gets to high right here.
                    IndexSymbol += 1
                    If PointCount > UBound(MyUniverse.MySymbolPoints) Then
                        logA(1684, UBound(MyUniverse.MySymbolPoints).ToString, CodeLine)
                        MsgBox("This array needs to be bigger ")
                        Exit While
                    End If
                    PointCount = MyMinMax(PointCount + 1, 0, MyUniverse.MyStaticData.Path_NamesCounted)
                    x1 = MyUniverse.MySymbolPoints(PointCount).x
                    y1 = MyUniverse.MySymbolPoints(PointCount).y
                    logA(4311, MyUniverse.MyStaticData.LastDataType)
                    AddNEWSymbolPointRecord(Source, MySymbolName, "/Point", x1, y1, "both", "Errored", My_VariableName(SourceForm, PointCount)) ' errored as the data type
                    TempXY = OtherEndOfNewMadePath(SourceForm, MyUniverse.SysGen.PlacementCurrent.x, MyUniverse.SysGen.PlacementCurrent.y, x1, y1, My_VariableName(SourceForm, PointCount))
                    ' A I N F O 2 (170)
                    IndexFlowChart = AddFlowChartRecordPath(SourceForm, My_VariableName(SourceForm, PointCount), "/path", TempXY, "Logic")

                    ' A I N F O 2 (171)
                    'why am I trying to connect paths here? or even see if it is connected?
                    If RouterConnectPath(SourceForm, IndexFlowChart) < 1 Then
                        If MyDebug(A_INFORMATION) Then logA(1685, MyShowFlowChartRecord(SourceForm, True, IndexFlowChart))
                    Else
                        logA(1686, RouterConnectPath(SourceForm, IndexFlowChart).ToString, MyShowFlowChartRecord(SourceForm, False, IndexFlowChart))
                    End If
        'NumberOfPoints += 1
                Case MyUniverse.ProgramOptions.FCCL_MultiLine
                Case Options.ListBoxSymbolData.Items.Item(21).ToString
                    If MyDebug(debugLevel) Then logA(1688, MyUniverse.MyStaticData.My_Syntax_Line_Parsed(I))
                    MyPlacement(SourceForm, True)
                    AddNEWFlowChartRecordPath(SourceForm, "Comment", "/Constant", MyUniverse.SysGen.PlacementCurrent.x, MyUniverse.SysGen.PlacementCurrent.y, 0, 0, MyUniverse.MyStaticData.My_Syntax_Line_Parsed(I))
                Case Options.ListBoxSymbolData.Items.Item(25).ToString
                Case MyUniverse.ProgramOptions.FCCL_VarChars
                Case MyUniverse.SysGen.Markers.FieldDelimiters ' no use continuing with nothing there.
                Case FD, MyUniverse.SysGen.Markers.FieldDelimiters
                    logA(2116, MyUniverse.MyStaticData.My_Syntax_Line_Parsed(I), CodeLine)
                Case MyUniverse.SysGen.Markers.Grammar
                    logA(1497, MyUniverse.MyStaticData.My_Syntax_Line_Parsed(I))
                Case Else
                    logA(1589, MyUniverse.MyStaticData.My_Syntax_Line_Parsed(I))
                    If Do_Not_Use_IsThisAVariableNameX(SourceForm, MyUniverse.MyStaticData.My_Syntax_Line_Parsed(I)) = True Then
                        PointCount = MyMinMax(PointCount + 1, 0, MyUniverse.MyStaticData.Path_NamesCounted)
                        IndexSymbol += 1
                        x1 = MyUniverse.MySymbolPoints(PointCount).x
                        y1 = MyUniverse.MySymbolPoints(PointCount).y
                        ' errored as the data type
                        PointCount = MyMinMax(PointCount + 1, 0, MyUniverse.MyStaticData.Path_NamesCounted)
                        logA(4312, MyUniverse.MyStaticData.LastDataType)
                        AddNEWSymbolPointRecord(Source, MySymbolName, "/Point", x1, y1, "both", "Errored", My_VariableName(SourceForm, PointCount))
                        TempXY = OtherEndOfNewMadePath(SourceForm, MyUniverse.SysGen.PlacementCurrent.x, MyUniverse.SysGen.PlacementCurrent.y, x1, y1, My_VariableName(SourceForm, PointCount))
                        IndexFlowChart = AddFlowChartRecordPath(SourceForm, My_VariableName(SourceForm, PointCount), "/path", TempXY, "Logic")
                    Else
                        If MyDebug(debugLevel) Then logA(2199, MyUniverse.MyStaticData.My_Syntax_Line_Parsed(I), WhatIsThis(MyUniverse.MyStaticData.My_Syntax_Line_Parsed(I)))
                        logA(1696, WhatIsThis(MyUniverse.MyStaticData.My_Syntax_Line_Parsed(I)), MyUniverse.MyStaticData.My_Syntax_Line_Parsed(I), I.ToString)
                    End If
            End Select
            I += 1
        End While



        IndexNamed = FindInNamedList(MySymbolName)
        If IndexNamed < 1 Then
            IndexNamed = AddNewNamedRecord(SourceForm, MySymbolName, CodeLine, "nop", CodeLine, CreateFileNameFromSyntax(SourceForm, SyntaxLine), "FlowChart", "0.0", "?", SyntaxLine) ', MyUniverse.ProgramOptions.FCCL_LanguageClassName
        End If
        'need to pan here to the location of the Symbol
        If IndexNamed > 1 Then
            MyPlacement(SourceForm, False) ' just to mark here
            MakeSymbolOutLine(SourceForm, MySymbolName)
        End If

        '''''ReSortSymbolList()


        OLD.Clear_Window(Library.PictureBox1)
        AddSymbolToDropDown(MySymbolName)
        'todo to speed up DoEvent(203)
        ' Below should redraw the top of the list (providing it is not sorted (Which is is now), if it is, then it has to 
        'be changed to a FindIndexOfComboBoxList ... 
        '2020 07 04 options.ListboxButtonSymbolNames.SelectedIndex=MyMinMax(LocalIndex, 1, options.ListboxButtonSymbolNames.Items.Count - 1)
        SelectInToolStripDropDownButton(Options.ListBoxRotation, MySymbolName)
        'todo to speed up DoEvent(204)
        'todo to speed up DoEvent(205)
        CheckSymbolByNamedIndex(SourceForm, IndexNamed)
        Return IndexNamed
    End Function


    Friend Function CheckPointNameToSyntax(PointName As String, IndexNamed As Integer) As Boolean
        Dim Syntax As String
        Syntax = Named_TableSyntax(IndexNamed)
        If MyInStr(PointName, Syntax) <> 0 Then
            Return False
        End If
        Return True
    End Function


    'used 
    Friend Function CheckPointNameToDropDown(MyPointName As String) As Integer
        Dim I As Integer
        Dim Z1 As String, Z2 As String
        Z2 = MyPointName
        Z2 = Pop(Z2, FD) 'make sure that we only have the point name passed
        If PrintAbleNull(MyPointName) = PrintAbleNull(Nothing) Then Return 1 'nothing in the point name so it is an error

        For I = 0 To Library.ListBoxPointNameList.Items.Count - 1
            Z1 = Library.ListBoxPointNameList.Items.Item(I).ToString
            Z1 = Pop(Z1, FD)
            If Z2 = Z1 Then
                Return 0 ' Do Not Add it again.
            End If
        Next I

        Library.ListBoxPointNameList.Items.Add(MyPointName)
        If MyDebug(A_DISPLAY) Then logA(1144, "Added point name " & MyPointName & vbCrLf)
        Return 1 ' there is no match, so the ProGrammar (me) needs to find out why not.
    End Function 'CheckPointNameToDropDown

    Friend Sub AddPointNameToDropDownX(ByRef SourceForm As Source, MyPointName As String)
        Dim I As Integer
        Dim Z1 As String, Z2 As String, Z3 As String

        If MyDebug(A_FMB) Then logA(1145)

        Z2 = NameOfPointOnly(MyPointName)
        If Len(MyPointName) = 0 Then Return
        'to make a new name and return it if my point name is unusable 
        Z3 = FD
        If PrintAbleNull(MyPointName) = PrintAbleNull(Nothing) Then
            For I = 0 To Library.ListBoxPointNameList.Items.Count - 1
                Z3 &= Library.ListBoxPointNameList.Items.Item(I).ToString & FD
            Next
            Z2 = My_VariableName(SourceForm, Library.ListBoxPointNameList.Items.Count)
        End If

        For I = 0 To Library.ListBoxPointNameList.Items.Count - 1
            Z1 = Library.ListBoxPointNameList.Items.Item(I).ToString
            Z1 = Pop(Z1, FD)

            If I <> 0 Then Z3 = Library.ListBoxPointNameList.Items.Item(I - 1).ToString
            If Z2 = Z3 Then
                logA(2749, I.ToString, Z1, (I - 1).ToString, Z3)
            End If

            If Z2 = Z1 Then
                If MyPointName <> Library.ListBoxPointNameList.Items.Item(I).ToString Then
                    logA(1701, MyPointName, Library.ListBoxPointNameList.Items.Item(I).ToString)
                End If
                Return ' Do Not Add it again.
            End If
        Next I
        For I = 0 To Library.ListBoxPointNameList.Items.Count - 1
            If Library.ListBoxPointNameList.Items.Item(I).ToString = MyPointName Then
                If MyDebug(A_FMB) Then logA(2744, MyPointName, Library.ListBoxPointNameList.Items.Item(I).ToString)
            End If
        Next
        Library.ListBoxPointNameList.Items.Add(MyPointName)
        'if MyDebug(a_fmb) then  log_X ( 2743,MyPointName, MyShowComboBoxItems(library.ListBoxPointNameList ))
    End Sub


    Friend Sub AddLineNameToDropDown(MyLineName As String)
        Dim I As Integer
        Dim Z1 As String, Z2 As String
        Z2 = MyLineName
        Z2 = Pop(Z2, FD)
        For I = 0 To Library.ListBoxLineColor.Items.Count - 1
            Z1 = Library.ListBoxLineColor.Items.Item(I).ToString
            Z1 = Pop(Z1, FD)
            If Z2 = Z1 Then
                Return ' Do Not Add it again.
            End If
        Next I
        Library.ListBoxLineColor.Items.Add(Z2)     'MyLineName)
    End Sub


    Friend Sub AddSymbolToDropDown(MySymbolName As String)
        Dim I As Integer
        Dim FlowChartFlag As Boolean

        If IsTheDropDownText_TheSameAs_TheSelectedText(False, Options.ListBoxSymbols.SelectedItem.ToString, Options.ListBoxRotation) = False Then
            logA(1704, Options.ListBoxSymbols.SelectedItem.ToString, Options.ListBoxRotation.Text)
            If IsTheDropDownText_TheSameAs_TheSelectedText(False, MyUniverse.ProgramOptions.SelectedSymbolName, Options.ListBoxRotation) = True Then
                logA(1705, MyUniverse.ProgramOptions.SelectedSymbolName, Options.ListBoxSymbols.SelectedItem.ToString)
                SelectInToolStripDropDownButton(Options.ListBoxSymbols, MyUniverse.ProgramOptions.SelectedSymbolName)
            End If
            If IsTheDropDownText_TheSameAs_TheSelectedText(False, MyUniverse.ProgramOptions.SelectedSymbolName, Options.ListBoxSymbols) = True Then
                logA(1706, MyUniverse.ProgramOptions.SelectedSymbolName, Options.ListBoxRotation.Text)
                SelectInToolStripDropDownButton(Options.ListBoxRotation, MyUniverse.ProgramOptions.SelectedSymbolName)
            End If
        End If


        '''''FlowChartFlag = False
        'make sure that the Symbol is not already in the DropDownList
        '''''If Options.ListBoxSymbols.SelectedItem.ToString.items.Count <> Options.ListBox14 .items.Count Then
        '''''LogA(1707, Options.ListBoxSymbols.SelectedItem.ToString.items.Count.ToString, Options.ListBox14 .items.Count.ToString)
        '''''End If



        'This takes way to long, need to change to a .find()
        For I = 0 To Options.ListBoxSymbols.Items.Count - 1
            If MySymbolName = Options.ListBoxSymbols.Items.Item(I).ToString() Then
                FlowChartFlag = True
                Exit For ' Do Not Add it again.
            End If
        Next I

        If FlowChartFlag = False Then
            Options.ListBoxSymbols.Items.Add(MySymbolName)
            'todo need to also add the .changed from FlowChart to Library., to make sure they are both in sync.
            Options.ListBoxRotation.Items.Add(MySymbolName)
        End If
    End Sub

    Friend Function OtherEndOfNewMadePath(ByRef SourceForm As Source, SymbolX1 As Integer, SymbolY1 As Integer, PointX1 As Integer, PointY1 As Integer, PathName As String) As MyLineStructure
        Dim SizeOfStubLines As Integer
        SizeOfStubLines = CInt(MyUniverse.SysGen.Constants.ConstantSymbolCenter * 4 / 5) 'todo this needs to be changeable???

        OtherEndOfNewMadePath = Nothing
        OtherEndOfNewMadePath.a.Named.PathName = PathName
        OtherEndOfNewMadePath.b.Named.PathName = PathName

        OtherEndOfNewMadePath.b.x = SizeOfStubLines * MySign(PointX1) + PointX1 + SymbolX1
        OtherEndOfNewMadePath.b.y = SizeOfStubLines * MySign(PointY1) + PointY1 + SymbolY1

        OtherEndOfNewMadePath.a.x = PointX1 + SymbolX1
        OtherEndOfNewMadePath.a.y = PointY1 + SymbolY1

        OtherEndOfNewMadePath.a.Named.IsWorldWindow = WorldOrWindow(OtherEndOfNewMadePath.a)
        OtherEndOfNewMadePath.b.Named.IsWorldWindow = WorldOrWindow(OtherEndOfNewMadePath.b)
        PanToWorldXYXY(SourceForm, OtherEndOfNewMadePath.a.x, OtherEndOfNewMadePath.a.y, OtherEndOfNewMadePath.b.x, OtherEndOfNewMadePath.b.y)
    End Function


    '
    ' Check if this is something, nothing, or flagged as nothing ('_')

    Friend Function DoesPathNamesMatch(ByRef SourceForm As Source, IndexFlowChart1 As Integer, IndexFlowChart2 As Integer, XY As MyPointStructure) As MyPointStructure
        ' removed not used?  DIM   Temp As MyPointStructure
        'todo need to change this for case sensitive in the future.
        If IndexFlowChart1 = IndexFlowChart2 Then Return MyUniverse.MyStaticData.ZeroZero 'same so they match
        If FlowChart_TablePathName(SourceForm, IndexFlowChart1) = FlowChart_TablePathName(SourceForm, IndexFlowChart2) Then
            If FlowChart_Table(SourceForm, IndexFlowChart1) <> FlowChart_Table(SourceForm, IndexFlowChart2) Then
                logA(1722, MyShowFlowChartRecord(SourceForm, True, IndexFlowChart1), MyShowFlowChartRecord(SourceForm, True, IndexFlowChart2), MyShowNetLinks(SourceForm, FlowChart_Table(SourceForm, IndexFlowChart1)), MyShowNetLinks(SourceForm, FlowChart_TablePathName(SourceForm, IndexFlowChart2)))
                RouterConnectPaths(SourceForm, IndexFlowChart1, IndexFlowChart2, FlowChart_TablePathName(SourceForm, IndexFlowChart2))
                Return Nothing
            End If
        Else 'test if any end of the path matches each other
            If DoesPathMeet(MyLine1(SourceForm, IndexFlowChart1), MyLine2(SourceForm, IndexFlowChart2)) = True Then
                Return XY
            End If
            logA(1724, MyShowFlowChartRecord(SourceForm, False, IndexFlowChart1) & MyShowFlowChartRecord(SourceForm, False, IndexFlowChart2), MyShowPoint(XY), FlowChart_TablePathName(SourceForm, IndexFlowChart1), FlowChart_TablePathName(SourceForm, IndexFlowChart2))
            Return XY 'failed because the names do not match
        End If
        Return Nothing
    End Function



    Friend Function DistanceBetween2Points(ByRef SourceForm As Source, IndexFlowChart1 As Integer, IndexFlowChart2 As Integer) As Integer
        Dim Xa1, Ya1, Xa2, Ya2 As Integer
        Dim Xb1, Yb1, Xb2, Yb2 As Integer
        DistanceBetween2Points = 98989898
        If IndexFlowChart1 = IndexFlowChart2 Then Return DistanceBetween2Points
        If FlowChart_TableCode(SourceForm, IndexFlowChart1) <> "/path" Then Return DistanceBetween2Points
        If FlowChart_TableCode(SourceForm, IndexFlowChart2) <> "/path" Then Return DistanceBetween2Points

        Xa1 = FlowChart_TableX1(SourceForm, IndexFlowChart1)
        Ya1 = FlowChart_TableY1(SourceForm, IndexFlowChart1)
        Xa2 = FlowChart_TableX2(SourceForm, IndexFlowChart1)
        Ya2 = FlowChart_TableY2(SourceForm, IndexFlowChart1)

        Xb1 = FlowChart_TableX1(SourceForm, IndexFlowChart2)
        Yb1 = FlowChart_TableY1(SourceForm, IndexFlowChart2)
        Xb2 = FlowChart_TableX2(SourceForm, IndexFlowChart2)
        Yb2 = FlowChart_TableY2(SourceForm, IndexFlowChart2)

        DistanceBetween2Points = MyMin(DistanceBetween2Points, DistanceBetweenTwoPoints(Xa1, Ya1, Xb1, Yb1))
        DistanceBetween2Points = MyMin(DistanceBetween2Points, DistanceBetweenTwoPoints(Xa1, Ya1, Xb2, Yb2))
        DistanceBetween2Points = MyMin(DistanceBetween2Points, DistanceBetweenTwoPoints(Xa2, Ya2, Xb1, Yb1))
        DistanceBetween2Points = MyMin(DistanceBetween2Points, DistanceBetweenTwoPoints(Xa2, Ya2, Xb2, Yb2))

        Return DistanceBetween2Points
    End Function


    Friend Function DistanceBetweenTwoPoints(X1 As Integer, Y1 As Integer, X2 As Integer, Y2 As Integer) As Integer
        'todo to get the 'real' distance you need to take the square root of the return value, 
        'todo but since It is only to compare relative distance . ... 
        Return MyABS(X1 - X2) + MyABS(Y1 - Y2)
        'not taking the 'real' distance between them to avoid using floating point (since I am only comparing this distance with another.
    End Function



    'why is this combining two nets with different names?
    Friend Sub CombineNetLinksInto(ByRef SourceForm As Source, LocalIndexNetLinks As Integer, JIndexNetLinks As Integer)
        Dim I, J As Integer
        Dim Temp As String
        If MyDebug(A_FMB) Then logA(2476, MyShowNetLinks(SourceForm, LocalIndexNetLinks), MyShowNetLinks(SourceForm, JIndexNetLinks))
        If LocalIndexNetLinks = JIndexNetLinks Then Return

        'Check the links of the two nets
        If Net_TablePathNames(LocalIndexNetLinks) <> Net_TablePathNames(JIndexNetLinks) Then
            logA(1730, MyShowNetLinks(SourceForm, LocalIndexNetLinks), MyShowNetLinks(SourceForm, JIndexNetLinks))
            Temp = CombineNames(Net_TablePathNames(LocalIndexNetLinks), Net_TablePathNames(JIndexNetLinks))
        Else
            Temp = Net_TablePathNames(LocalIndexNetLinks) ' since they match, Net_TableLinks(JIndexNetLinks))
        End If

        'The nets in this list is in Temp
        Net_TableLinks(JIndexNetLinks, Net_TableLinks(JIndexNetLinks) & Net_TableLinks(LocalIndexNetLinks)) 'Combine the two nets
        CleanListOfNet_TableLinks(LocalIndexNetLinks)


        For I = 1 To TopOfListBox(SourceForm.ListBoxFlowChart)
            If FlowChart_TableCode(SourceForm, I) = "/path" Then
                Temp = FlowChart_TablePathName(SourceForm, I) 'index of this /path index =I
                '''''Temp = Net_TableLinks(J)    'The list of links of this path name

                While Len(Temp) > 0     'loop through all of the paths find this one
                    J = PopValue(Temp)  'Get another /path
                    If J = LocalIndexNetLinks Then
                        If I = JIndexNetLinks Then
                            If FlowChart_TablePathName(SourceForm, J) <> "" Then
                                If FlowChart_TablePathName(SourceForm, I) <> "" Then
                                    If Net_TablePathNames(I) = Net_TablePathNames(J) Then
                                        'Finally combine the two nets and get rid of the old, it does not matter which is changed.
                                        Net_TableLinks(I, Net_TableLinks(I) & FD & Net_TableLinks(J))
                                        CleanListOfNet_TableLinks(I)
                                        CleanListOfNet_TableLinks(J)
                                        Net_TablePathNames(J, "") 'Erase the old dup
                                        Net_TableLinks(J, "") 'Erase the old dup

                                        Return
                                    End If
                                Else
                                    logA(1731, MyShowFlowChartRecord(SourceForm, True, I), MyShowFlowChartRecord(SourceForm, True, J))
                                End If
                            Else
                                logA(1732, I.ToString, MyShowFlowChartRecord(SourceForm, True, I), J.ToString, MyShowFlowChartRecord(SourceForm, True, J))
                            End If
                        Else
                            logA(1738, I.ToString & COMMA & MyShowFlowChartRecord(SourceForm, True, I), J.ToString & COMMA & MyShowFlowChartRecord(SourceForm, True, J))
                        End If
                    Else
                        logA(1739, I.ToString & COMMA & MyShowFlowChartRecord(SourceForm, True, I), J.ToString & COMMA & MyShowFlowChartRecord(SourceForm, True, J))
                    End If
                End While

            End If
        Next

        logA(1740, I.ToString & COMMA & MyShowFlowChartRecord(SourceForm, True, I), J.ToString & COMMA & MyShowFlowChartRecord(SourceForm, True, J))
    End Sub


    Friend Function CombineNames(A As String, B As String) As String
        If MyDebug(A_FMB) Then logA(2477, A, B)
        If MyInStr("_&_", A & B) > 0 Then
            If MyInStr(A, B) <> 0 Then Return A
            If MyInStr(B, A) > 0 Then Return B
        End If
        Return A & "_&_" & B
    End Function 'CombineNames


    Friend Function RemoveNumberFromTextList(InputString As String, NumberToRemove As Integer) As String
        Dim Temp As String
        Dim I As Integer
        If MyDebug(A_FMB) Then logA(2478, InputString, NumberToRemove.ToString)
        Temp = FD & NumberToRemove.ToString & FD
        I = MyInStr(Temp, InputString)
        If I <> 0 Then
            Return Mid(InputString, 1, I) & FD & Mid(InputString, I + Len(Temp), Len(InputString))
        Else
            Return InputString
        End If
    End Function


    ' from the netLinks will go through and try to connect everything together 
    'router step one, Route this path to all other paths
    Friend Function ROUTERNetIndex(ByRef SourceForm As Source, IndexNet As Integer) As Integer
        Dim IndexFlowChart, debug2 As Integer
        Dim PathIndexes As String
        Dim PathName As String


        If FMBRecurse("ROUTERNetIndex") > 8 Then

            Return ConstantMyErrorCode
        End If
        logA(2345, "Router net index ", MyShowNetLinks(SourceForm, IndexNet))
        ROUTERNetIndex = 0

        PathIndexes = Net_TableLinks(IndexNet)
        IndexFlowChart = PopNonZeroValue(PathIndexes)
        debug2 = PopNonZeroValue(PathIndexes)
        If MyOptionTest(34) Then PanToWorldXYXY(SourceForm, FlowChart_TableX1(SourceForm, IndexFlowChart), FlowChart_TableY1(SourceForm, IndexFlowChart), FlowChart_TableX2(SourceForm, debug2), FlowChart_TableY2(SourceForm, debug2))
        PathIndexes = Net_TableLinks(IndexNet)
        PathName = Net_TablePathNames(IndexNet)

        While Len(PathIndexes) > 0
            IndexFlowChart = PopNonZeroValue(PathIndexes)
            MyDrawRouter(SourceForm, IndexFlowChart)
            MyDrawPathsPossible(SourceForm, FlowChart2Line(SourceForm, IndexFlowChart), FlowChart2Line(SourceForm, debug2))
            If IndexFlowChart > 0 Then
                If ROUTERIndex2Net(SourceForm, IndexFlowChart, IndexNet) = True Then
                    ROUTERNetIndex += 1
                End If
            Else
                logA(1786, IndexNet.ToString)
            End If
        End While


        Return 1
    End Function ' returns the number of connection there are in this list of path records (in net links)



    Friend Function Line2WindowScale(ByRef SourceForm As Source, xy As MyLineStructure) As MyLineStructure
        If MyDebug(A_FMB) Then logA(2480)
        Line2WindowScale.a = Copy2WindowXY(SourceForm, xy.a)
        Line2WindowScale.b = Copy2WindowXY(SourceForm, xy.b)
    End Function

    Friend Function RouterDrawWhileSearching(ByRef SourceForm As Source, IndexFlowChart1 As Integer, IndexFlowChart2 As Integer, ColorCode As Integer) As Boolean
        Dim RTN As Boolean

        logA(2345, "Router draw while searching paths ", MyShowFlowChartRecord(SourceForm, False, IndexFlowChart1), vbCrLf, MyShowFlowChartRecord(SourceForm, False, IndexFlowChart2))
        ColorCode = MyMinMax(ColorCode Mod (TopOfFile(SourceForm, "Color") - 1), 1, TopOfFile(SourceForm, "Color") - 2)
        If FMBRecurse("RouterDrawWhileSearching") > 8 Then

            Return False
        End If
        RTN = RouterDrawWhileSearching(SourceForm, MyLine(SourceForm, IndexFlowChart1), MyLine2(SourceForm, IndexFlowChart2), Color_TableName(ColorCode))

        Return RTN
    End Function
    Friend Sub MyDrawWorldPaths(ByRef SourceForm As Source, IndexFlowChart1 As Integer, IndexFlowChart2 As Integer)
        If IndexFlowChart1 = IndexFlowChart2 Then Return
        If MyDebug(A_DEBUG) Then
            logA(2481, MyShowFlowChartRecord(SourceForm, False, IndexFlowChart1), MyShowFlowChartRecord(SourceForm, False, IndexFlowChart2))
        End If
        MyDrawWorldPaths(SourceForm, MyLine(SourceForm, IndexFlowChart1), MyLine2(SourceForm, IndexFlowChart2))
    End Sub
    Friend Sub MyDrawWorldPaths(ByRef SourceForm As Source, Line1 As MyLineStructure, Line2 As MyLineStructure)
        MyDrawPathsPossible(SourceForm, Line1, Line2)
        Line1.a = Copy2WindowXY(SourceForm, Line1.a)
        Line1.b = Copy2WindowXY(SourceForm, Line1.b)
        Line2.a = Copy2WindowXY(SourceForm, Line2.a)
        Line2.b = Copy2WindowXY(SourceForm, Line2.b)
        MyDrawPathsPossible(SourceForm, Line1, Line2)
    End Sub



    Friend Function ROUTERMakePathIndex(ByRef SourceForm As Source, IndexFlowChart1 As Integer, InDexFlowChart2 As Integer) As MyPointStructure
        'todo Need to get the two closest ends.
        Dim XY1, XY2 As MyLineStructure

        If MyDebug(A_DEBUG) Then
            logA(2482, IndexFlowChart1.ToString & COMMA & InDexFlowChart2.ToString, MyShowFlowChartRecord(SourceForm, False, IndexFlowChart1), MyShowFlowChartRecord(SourceForm, False, InDexFlowChart2))
        End If
        If IndexFlowChart1 = InDexFlowChart2 Then

            Return MyUniverse.MyStaticData.ZeroZero
        End If
        MyUniverse.MyStaticData.LastColor = MyMinMax((MyUniverse.MyStaticData.LastColor + 1) Mod TopOfFile(SourceForm, "Color"), 1, TopOfFile(SourceForm, "Color"))
        logA(2345, "Router make paths ", MyShowFlowChartRecord(SourceForm, False, IndexFlowChart1), vbCrLf, MyShowFlowChartRecord(SourceForm, False, InDexFlowChart2))
        If RouterDrawWhileSearching(SourceForm, IndexFlowChart1, InDexFlowChart2, MyUniverse.MyStaticData.LastColor) = True Then
            If MyOptionTest(25) Then
            Else
            End If
        Else
        End If
        XY1 = FindClosestPathEnds(SourceForm, IndexFlowChart1, InDexFlowChart2)
        XY2 = XY1
        Dim Dx As Integer

        Dx = DistanceBetween2Points(SourceForm, IndexFlowChart1, InDexFlowChart2)
        If Dx = 0 Then                ' The X or Y is already stright up/down OR level right/left
        Else
            If RouterMakePathPoints(SourceForm, XY1.a, XY2.b) = False Then ' first try to route
                XY2 = XY1
                If RouterMakePathPoints(SourceForm, XY2.a, XY1.b) = False Then ' second try to route backwards
                    XY2 = XY1 : XY2.a.x = XY1.b.x
                    If RouterMakePathPoints(SourceForm, XY1.a, XY2.b) = False Then ' try to get half way
                        XY2 = XY1 : XY2.b.x = XY1.a.x
                        If RouterMakePathPoints(SourceForm, XY2.a, XY1.b) = False Then ' try the other half way
                            XY2 = XY1 : XY2.a.y = XY1.b.y
                            If RouterMakePathPoints(SourceForm, XY1.a, XY2.b) = False Then ' sideways
                                XY2 = XY1 : XY2.b.y = XY1.a.y
                                If RouterMakePathPoints(SourceForm, XY1.a, XY2.b) = False Then ' other way sideways
                                    XY2 = XY1 : XY2.a.x = XY1.b.x
                                    If RouterMakePathPoints(SourceForm, XY1.a, XY2.b) = False Then
                                        XY2 = XY1 : XY2.a.x = XY1.b.x
                                        If RouterMakePathPoints(SourceForm, XY1.a, XY2.b) = False Then
                                        Else
                                        End If
                                    End If
                                End If
                            End If
                        End If
                    End If
                End If
            End If
        End If

        Return MyUniverse.MyStaticData.ZeroZero 'failed to make a path
    End Function



    'add a path record going from xy1 to xy2
    ' returns if path record created
    'assumes that only one pathname at that XY location
    'makes sure that this path is clear except for paths of its own name
    Friend Function RouterMakePathPoints(ByRef SourceForm As Source, myXY1 As MyPointStructure, MyXy2 As MyPointStructure) As Boolean
        Dim IndexFlowChart1, IndexFlowChart2, I As Integer

        If MyDebug(A_DEBUG) Then
            logA(2483, MyShowPoint(myXY1), MyShowPoint(MyXy2))
        End If
        If FMBRecurse("RouterMakePath") > 10 Then

            Return False
        End If
        logA(2345, "Router make paths ", MyShowFlowChartRecord(SourceForm, False, IndexFlowChart1), vbCrLf, MyShowFlowChartRecord(SourceForm, False, IndexFlowChart2))
        If myXY1.x = 0 And myXY1.y = 0 Then

            Return False
        End If
        If MyXy2.x = 0 And MyXy2.y = 0 Then

            Return False
        End If
        MyDrawWorldPath(SourceForm, MyLine(myXY1, MyXy2), RandomColor(SourceForm))
        'todo need to check if paths are going over symbol's
        If myXY1.x = MyXy2.x And myXY1.y = MyXy2.y Then

            Return False
        End If
        If myXY1.x = 0 Or myXY1.y = 0 Or MyXy2.x = 0 Or MyXy2.y = 0 Then
            logA(1728, MyShowPoints(SourceForm, myXY1.x, myXY1.y, MyXy2.x, MyXy2.y))

            Return False ' Can not route from zero to zero 
        End If

        If myXY1.x <> 0 Or myXY1.y <> 0 Or MyXy2.x <> 0 Or MyXy2.y <> 0 Then

            logA(1742, MyShowPoint(myXY1), MyShowPoint(MyXy2))
            'first find net name for this point
            IndexFlowChart1 = FindPathNameAt(SourceForm, myXY1)
            IndexFlowChart2 = FindPathNameAt(SourceForm, MyXy2)
            'then add a new path there 
            MyDrawWindowPath(SourceForm, MyLine(myXY1, MyXy2), "")
            If FlowChart_TablePathName(SourceForm, IndexFlowChart1) <> FlowChart_TablePathName(SourceForm, IndexFlowChart2) Then
                MakeErrorAt(SourceForm, myXY1, "ERROR Two path at same point does not match names " & FlowChart_TablePathName(SourceForm, IndexFlowChart1) & " <===> " & FlowChart_TablePathName(SourceForm, IndexFlowChart2))
                MakeErrorAt(SourceForm, MyXy2, "ERROR Two path at same point does not match names " & FlowChart_TablePathName(SourceForm, IndexFlowChart2) & " <===> " & FlowChart_TablePathName(SourceForm, IndexFlowChart1))
                PaintAll(SourceForm, 1, TopOfListBox(SourceForm.ListBoxFlowChart))
            End If
            If FlowChart_TablePathName(SourceForm, IndexFlowChart1) <> FlowChart_TablePathName(SourceForm, IndexFlowChart2) Then
                MakeErrorAt(SourceForm, myXY1, "ERROR same path does not match datatypes " & FlowChart_TablePathName(SourceForm, IndexFlowChart1) & "<===>" & FlowChart_TablePathName(SourceForm, IndexFlowChart2))
                MakeErrorAt(SourceForm, MyXy2, "ERROR same path does not match datatype " & FlowChart_TablePathName(SourceForm, IndexFlowChart2) & "<===>" & FlowChart_TablePathName(SourceForm, IndexFlowChart1))
            End If
            I = AddFlowChartRecordPath(SourceForm, FlowChart_TablePathName(SourceForm, IndexFlowChart1), "/path", myXY1.x, myXY1.y, MyXy2.x, MyXy2.y, FlowChart_TableDataType(SourceForm, IndexFlowChart1))
            If MyOptionTest(34) Then
                OLD.Clear_Window(SourceForm.FlowChartPictureBox)
                PaintAll(SourceForm, I, I)
                PaintAll(SourceForm, IndexFlowChart1, IndexFlowChart1) 'todo remove this
                PaintAll(SourceForm, IndexFlowChart2, IndexFlowChart2) 'todo remove this
            End If


            Return True
        Else
            MyDrawWindowPath(SourceForm, MyLine(myXY1, MyXy2), "orange")
            If MyDebug(A_DEBUG) Then
                logA(1743, MyShowPoint(myXY1), MyShowPoint(MyXy2))
            End If

        End If

        Return False
    End Function ' returns false if a path could/should not be made here because it routes to zeroZero

    Friend Function WorldOrWindow(What As String, XY As MyLineStructure) As String
        Const MAXxy As Integer = 2500
        If XY.a.x = 0 And XY.a.y = 0 And XY.b.x = 0 And XY.b.y = 0 Then Return " ZERO "
        If XY.a.x > MAXxy Or XY.a.y > MAXxy Or XY.b.x > MAXxy Or XY.b.y > MAXxy Then
            If What = "World" Then
                Return "_____________________________ World " & MyShowLineXYXY(XY) & What
            Else
                Return "*** World " & MyShowLineXYXY(XY) & What
            End If
        End If
        If What = "Window" Then
            Return "---------------------------- Window " & MyShowLineXYXY(XY) & What
        Else
            Return "############################# Window " & MyShowLineXYXY(XY) & What
        End If

    End Function


    Friend Function ZeroZero(XY As MyPointStructure) As Boolean
        If XY.x = 0 And XY.y = 0 Then Return True
        Return False
    End Function

    Friend Function ROUTERend(ByRef SourceForm As Source, IndexFlowChart As Integer, MyXY As MyPointStructure) As MyPointStructure
        Dim MyXY1 As MyLineStructure
        Dim MyXY2 As MyPointStructure = Nothing
        Dim MyXY3 As MyPointStructure = Nothing

        If MyDebug(A_DEBUG) Then
            logA(2485, MyShowPoint(MyXY), MyShowFlowChartRecord(SourceForm, False, IndexFlowChart))
        End If
        If FMBRecurse("ROUTERend") > 10 Then

            Return MyUniverse.MyStaticData.ZeroZero
        End If
        MyXY1 = FlowChart2Line(SourceForm, IndexFlowChart)
        'test to make sure we are on a path
        If FlowChart_TableCode(SourceForm, IndexFlowChart) <> "/path" Then
            If MyDebug(A_ERROR) Then
                logA(1744, MyShowFlowChartRecord(SourceForm, False, IndexFlowChart))
            End If

            Return MyUniverse.MyStaticData.ZeroZero
        End If
        'get the two end points of the path
        logA(2345, "Router end? ", MyShowFlowChartRecord(SourceForm, False, IndexFlowChart))

        If MyOptionTest(34) Then
            PanToWorldXY(SourceForm, CInt((MyXY1.a.x + MyXY.x) / 2), CInt((MyXY1.a.y + MyXY.y) / 2))
            MyReSizeWorld(SourceForm, MyLine(SourceForm, IndexFlowChart))
            MyReSizeWorld(SourceForm, MyLine(MyXY1.a, MyXY))
            MyReSizeWorld(SourceForm, MyLine(MyXY1.b, MyXY))
            'Clear_Window( SourceForm.flowchartpicturebox )
            MyDrawWorldCircle(SourceForm, MyXY, "ORANGE")
            MyXY2.x = MyXY1.a.x
            MyXY2.y = MyXY1.a.y
            MyXY3.x = MyXY1.b.x
            MyXY3.y = MyXY1.b.y
            If MyOptionTest(34) Then
                MyDrawWorldCircle(SourceForm, MyXY2, "PURPLE")
                MyDrawWorldCircle(SourceForm, MyXY3, RandomColor(SourceForm))
                MyDrawWorldPath(SourceForm, MyLine(MyXY, MyXY2), RandomColor(SourceForm))
                MyDrawWorldPath(SourceForm, MyLine(MyXY, MyXY3), RandomColor(SourceForm))
                MyDrawWorldPath(SourceForm, MyLine(MyXY2, MyXY3), RandomColor(SourceForm))
                MyDrawPathsPossible(SourceForm, MyLine(MyXY, MyXY2), MyLine(MyXY, MyXY2))
            End If
        End If
        If MyXY2.x = MyXY.x And MyXY2.y = MyXY.y Then

            Return MyXY2
        End If
        If MyXY3.x = MyXY.x And MyXY3.y = MyXY.y Then

            Return MyXY3
        End If
        If MyOptionTest(34) Then
            OLD.Clear_Window(SourceForm.FlowChartPictureBox)
            MyDrawWorldCircle(SourceForm, MyXY, "Purple")
            MyDrawWorldCircle(SourceForm, MyXY2, "Purple")
            MyDrawWorldCircle(SourceForm, MyXY3, "Purple")
        End If

        Return MyUniverse.MyStaticData.ZeroZero
    End Function 'text to see if this path meats this point (zeroZero if it does not)

    'draw the possible paths on the screen
    Friend Sub MyDrawPathsPossible(ByRef SourceForm As Source, xy1 As MyLineStructure, xy2 As MyLineStructure)
        If MyOptionTest(34) = False Then Return
        MyReSizeWorld(SourceForm, xy1)
        MyReSizeWorld(SourceForm, xy2)
        WW3_My_Draw_Line_Or_Path(SourceForm, MyLine(xy1.a.x, xy1.a.y, xy1.a.x, xy2.a.y), RandomColor(SourceForm), 10) 'stright up
        WW3_My_Draw_Line_Or_Path(SourceForm, MyLine(xy1.a.x, xy1.a.y, xy2.b.x, xy1.b.y), RandomColor(SourceForm), 10) ' stright right/left
        WW3_My_Draw_Line_Or_Path(SourceForm, MyLine(xy1.a.x, xy1.a.y, xy2.b.x, xy1.b.y), RandomColor(SourceForm), 10) ' stright right/left
        WW3_My_Draw_Line_Or_Path(SourceForm, MyLine(xy1.a.x, xy1.a.y, xy1.b.x, xy2.b.y), RandomColor(SourceForm), 10) ' stright right/left

        WW3_My_Draw_Line_Or_Path(SourceForm, MyLine(xy1.a.x, xy1.a.y, xy2.a.x, xy2.a.y), "YellowGreen", 10) ' stright right/left
        WW3_My_Draw_Line_Or_Path(SourceForm, MyLine(xy1.a.x, xy1.a.y, xy2.b.x, xy2.b.y), "YellowGreen", 10) ' stright right/left
        WW3_My_Draw_Line_Or_Path(SourceForm, MyLine(xy1.b.x, xy1.b.y, xy2.a.x, xy2.a.y), "YellowGreen", 10) ' stright right/left
        WW3_My_Draw_Line_Or_Path(SourceForm, MyLine(xy1.b.x, xy1.b.y, xy2.b.x, xy2.b.y), "YellowGreen", 10) ' stright right/left



    End Sub

    ' This draw lines for the 4 possible connections of two paths
    'router step 3 try to find paths to connect from here to the end 
    'todo should also try to connect from the end to the start,
    'todo as well as from the start to the end (4 searches to complete a path)
    Friend Function RouterDrawWhileSearching(ByRef SourceForm As Source, XY1 As MyLineStructure, XY2 As MyLineStructure, ColorName As String) As Boolean
        Dim xy As MyLineStructure = Nothing
        Dim Z As MyPointStructure
        Dim D1, D2, D3, D4 As Integer
        If FMBRecurse("ROUTERend") > 10 Then Return False

        If MyOptionTest(34) Then
            MyDrawWorldPath(SourceForm, XY2, ColorName)
            MyDrawWorldPath(SourceForm, XY1, ColorName)
        End If
        logA(2345, "Router draw while searching  ", MyShowLineXYXY(XY1), vbCrLf, MyShowLineXYXY(XY2))

        D1 = DistanceBetweenTwoPoints(XY1.a.x, XY1.a.y, XY2.a.x, XY2.a.y)
        D2 = DistanceBetweenTwoPoints(XY1.a.x, XY1.a.y, XY2.b.x, XY2.b.y)
        D3 = DistanceBetweenTwoPoints(XY1.b.x, XY1.b.y, XY2.a.x, XY2.a.y)
        D4 = DistanceBetweenTwoPoints(XY1.b.x, XY1.b.y, XY2.b.x, XY2.b.y)
        If MyDebug(A_DEBUG) Then logA(1729, D1.ToString, D2.ToString, D3.ToString, D4.ToString)
        If MyOptionTest(34) Then
            WW3_My_Draw_Line_Or_Path(SourceForm, XY1, ColorName, 4)
            WW3_My_Draw_Line_Or_Path(SourceForm, XY2, ColorName, 4)
            MyDrawPathsPossible(SourceForm, XY1, XY2)
            Z = CenterOf2Lines(XY1, XY2)
            'todo change the search pattern color to be changeable.
            PanToWorldXY(SourceForm, Z.x, Z.y)
            'first to first
            MyDrawPathsPossible(SourceForm, XY1, XY2)
        End If
        xy.a.x = XY1.a.x : xy.a.y = XY1.a.y : xy.b.x = XY2.a.x : xy.b.y = XY2.a.y ': xy=Line2WindowScale(xy)
        If MyOptionTest(34) Then WW3_My_Draw_Line_Or_Path(SourceForm, xy, ColorName, 1)
        If ROUTER_Auto_Path(SourceForm, xy.a, xy.b, FlowChart_TablePathName(SourceForm, FindPathNameAt(SourceForm, xy.a))) = True Then
            If MyOptionTest(25) Then
            Else
            End If
        Else
        End If


        'first to second
        xy.a.x = XY1.a.x : xy.a.y = XY1.a.y : xy.b.x = XY2.b.x : xy.b.y = XY2.b.y ': xy=Line2WindowScale(xy)
        If MyOptionTest(34) Then WW3_My_Draw_Line_Or_Path(SourceForm, xy, ColorName, 1)
        If ROUTER_Auto_Path(SourceForm, xy.a, xy.b, FlowChart_TablePathName(SourceForm, FindPathNameAt(SourceForm, xy.a))) = True Then
            If MyOptionTest(25) Then
            Else
            End If
        Else
        End If
        If MyOptionTest(34) Then PanToWorldXY(SourceForm, XY1.b.x, XY1.b.y)
        'second to first
        xy.a.x = XY1.b.x : xy.a.y = XY1.b.y : xy.b.x = XY2.a.x : xy.b.y = XY2.a.y ': xy=Line2WindowScale(xy)
        If MyOptionTest(34) Then WW3_My_Draw_Line_Or_Path(SourceForm, xy, ColorName, 1)
        If ROUTER_Auto_Path(SourceForm, xy.a, xy.b, FlowChart_TablePathName(SourceForm, FindPathNameAt(SourceForm, xy.a))) = True Then
            If MyOptionTest(25) Then
            Else
            End If
        Else
        End If
        'second to second
        xy.a.x = XY1.b.x : xy.a.y = XY1.b.y : xy.b.x = XY2.b.x : xy.b.y = XY2.b.y ': xy=Line2WindowScale(xy)
        If MyOptionTest(34) Then WW3_My_Draw_Line_Or_Path(SourceForm, xy, ColorName, 1)
        If ROUTER_Auto_Path(SourceForm, xy.a, xy.b, FlowChart_TablePathName(SourceForm, FindPathNameAt(SourceForm, xy.a))) = True Then
            If MyOptionTest(25) Then
            Else
            End If
        Else
        End If

        Return True
    End Function 'end of Router Draw While Searching return false if no path could be found 



    'make a list of paths that connect these two
    'trying to connect from the indexFlowChart (which is the first in the NetLinks list) to anything else in the NetLinks list
    'Router step two A Have a path index, and the index of the path name/list of all path indexes that connect to this
    'router step two B find the closest two points to rout to
    'todo Should change this to route to all four possibilities
    Friend Function ROUTERIndex2Net(ByRef SourceForm As Source, IndexFlowChart As Integer, IndexNets As Integer) As Boolean
        Dim Temp1, Temp2, Temp3 As String ' 1 holds the list not tried (to try others), 2 holds the list of the one we are trying to ROUTER
        Dim XY1 As MyLineStructure
        Dim XY2 As MyLineStructure
        Dim LastDistance, LastIndexFlowChart, LocalIndex As Integer

        'option (19) turns off auto ROUTER
        If MyDebug(A_DEBUG) Then
            logA(2487, MyShowFlowChartRecord(SourceForm, False, IndexFlowChart), MyShowNetLinks(SourceForm, IndexNets))
        End If
        logA(2345, "Router index to net ", MyShowFlowChartRecord(SourceForm, False, IndexFlowChart), vbCrLf, MyShowNetLinks(SourceForm, IndexNets))
        MyDrawRouter(SourceForm, IndexFlowChart)
        If MyOptionTest(19) = False Then
            logA(1755)

            Return False
        End If

        'If MyDebug(a_information) Then log_X ( 1756,MyShowFlowChartRecord(SourceForm, true, IndexFlowChart), MyShowNetLinks(SourceForm, IndexNets))

        LastDistance = 100000000 'really really big number.
        LastIndexFlowChart = -1
        'First find the closest one
        Temp1 = Net_TableLinks(IndexNets)
        XY1 = FlowChart2Line(SourceForm, IndexFlowChart)

        'already drawn
        MyDrawWorldPath(SourceForm, XY1, "green")

        Temp2 = RemoveNumberFromTextList(Temp1, IndexFlowChart)
        'Router step two B find the closest two points
        'Doc loop to find closest one

        While Len(Temp2) > 0
            LocalIndex = PopNonZeroValue(Temp2)
            MyDrawRouter(SourceForm, LocalIndex)
            MyDrawWorldPaths(SourceForm, LocalIndex, IndexFlowChart)
            If LocalIndex <> IndexFlowChart And LocalIndex <> 0 Then
                If MyDebug(A_DEBUG) Then logA(1757, IndexFlowChart.ToString & MyShowFlowChartRecord(SourceForm, False, IndexFlowChart), LocalIndex.ToString & MyShowFlowChartRecord(SourceForm, False, LocalIndex))
                XY2 = FlowChart2Line(SourceForm, LocalIndex)
                MyDrawWindowPath(SourceForm, XY1, "")
                MyDrawWindowPath(SourceForm, XY2, "")
                ' log_X (1718, MyShow2Lines(XY1, XY2))
                If RouterDrawWhileSearching(SourceForm, XY1, XY2, "debugging") = True Then
                    If MyOptionTest(25) Then
                    Else
                    End If
                Else
                End If


                MyShowWorldRouter(SourceForm, XY1, XY2)
                Temp3 = MyShowALine(XY1) & "  " & MyShowALine(XY2)
                If FlowChart_TablePathName(SourceForm, IndexFlowChart) <> FlowChart_TablePathName(SourceForm, LocalIndex) Then
                    logA(1758, MyShowFlowChartRecord(SourceForm, True, IndexFlowChart), MyShowFlowChartRecord(SourceForm, True, LocalIndex))
                End If

                'MyDrawPaths(XY1, XY2, MyUniverse.OptionDisplay(LocalIndex Mod MySizeOf(MyUniverse.OptionDisplay)).ColorName)
                If RouterDrawWhileSearching(SourceForm, XY1, XY2, "debugging") = True Then
                    If MyOptionTest(25) Then
                    Else
                    End If
                Else
                End If


                If MyDistancePath(XY1, XY2) < LastDistance Then
                    WW3_My_Draw_Line_Or_Path(SourceForm, XY1, RandomColor(SourceForm), 8)
                    WW3_My_Draw_Line_Or_Path(SourceForm, XY2, RandomColor(SourceForm), 8)
                    logA(1759, MyDistancePath(XY1, XY2).ToString, LastDistance.ToString, MyShowFlowChartRecord(SourceForm, False, IndexFlowChart), MyShowFlowChartRecord(SourceForm, False, LocalIndex))
                    LastDistance = MyDistancePath(XY1, XY2)
                    LastIndexFlowChart = LocalIndex
                End If
            End If
            Temp2 = RemoveNumberFromTextList(Temp2, LocalIndex)
        End While


        'This is where the router actually starts to work between two paths.
        If LastIndexFlowChart < 1 Then

            Return False
        End If
        'router Step two C Try to connect these two paths together.
        XY1 = FlowChart2Line(SourceForm, IndexFlowChart)
        XY2 = FlowChart2Line(SourceForm, LastIndexFlowChart)
        If RouterDrawWhileSearching(SourceForm, XY1, XY2, RandomColor(SourceForm)) = True Then
            If MyOptionTest(25) Then
            Else
            End If
        Else
        End If

        ' re-moved this selected from the list
        LocalIndex = LastIndexFlowChart
        logA(1760, MyShowFlowChartRecord(SourceForm, True, IndexFlowChart), MyShowFlowChartRecord(SourceForm, True, LocalIndex))
        If MyOptionTest(14) = True Then
            If IndexFlowChart > 0 And LocalIndex > 0 Then
                If ZeroZero(ROUTERMakePathIndex(SourceForm, IndexFlowChart, LocalIndex)) = True Then
                    If MyOptionTest(25) Then
                    Else
                    End If
                Else
                End If

                Return True
            Else
                logA(1761, MyShowFlowChartRecord(SourceForm, True, IndexFlowChart), MyShowFlowChartRecord(SourceForm, True, LocalIndex))

                Return False
            End If
        End If

        'Now should have the two closest together
        If LastIndexFlowChart > ConstantMyErrorCode Then 'We found something to ROUTER to
            If ROUTERPath_IsAPathROUTERd(SourceForm, IndexFlowChart, LastIndexFlowChart) = True Then

                Return True
            Else
                If ROUTERAutoPath(SourceForm, IndexFlowChart, LastIndexFlowChart) = False Then
                    logA(1762, MyShowFlowChartRecord(SourceForm, True, IndexFlowChart), MyShowFlowChartRecord(SourceForm, True, LastIndexFlowChart))
                Else
                    'todo need to make the path of the auto route success? (or do it in the recursion
                    logA(1763, MyShowFlowChartRecord(SourceForm, False, IndexFlowChart))

                    Return True
                End If
            End If
        End If

        Return False
    End Function 'router path to the next in the list of net links paths


    'have determined that a path needs to be between index flow chart1 and indexFlowChart2

    Friend Function ROUTERAutoPath(ByRef SourceForm As Source, IndexFlowChart1 As Integer, IndexFlowChart2 As Integer) As Boolean
        Dim TempXY As MyLineStructure
        Dim PathName As String
        Dim rtn As Boolean
        logA(2345, "Router auto paths ", MyShowFlowChartRecord(SourceForm, False, IndexFlowChart1), vbCrLf, MyShowFlowChartRecord(SourceForm, False, IndexFlowChart2))

        If MyDebug(A_DEBUG) Then
            logA(2488, MyShowFlowChartRecord(SourceForm, False, IndexFlowChart1) & MyShowFlowChartRecord(SourceForm, False, IndexFlowChart2))
        End If
        If FlowChart_TablePathName(SourceForm, IndexFlowChart1) = FlowChart_TablePathName(SourceForm, IndexFlowChart2) Then
            PathName = FlowChart_TablePathName(SourceForm, IndexFlowChart1)
        Else
            PathName = FlowChart_TablePathName(SourceForm, IndexFlowChart1) & "_" & FlowChart_TablePathName(SourceForm, IndexFlowChart2)
        End If
        TempXY = FindClosestPathEnds(SourceForm, IndexFlowChart1, IndexFlowChart2)
        rtn = ROUTER_Auto_Path(SourceForm, TempXY.a, TempXY.b, PathName)

        Return rtn
    End Function 'ROUTERAutoPath returns true if a path could be found for path1 to path2



    'This is to see if the Line is clear all the way from a to b with out anything in the way
    ' returns MyUniverse.MyStaticData.ZeroZero if not doable
    ' return the A if recursion is doable
    'returns b when finished
    ' assumes that a path is then made from A to Be if returns B 
    ' all the way back to the top
    'Calls itself with a point between A and B going to B till it finds a path
    'First find where the list of the path is in X
    ' Why I am only using X, I have no Idea, it should be for X for directions 
    ' and when using Y it should be fore directions 
    'Y1 XY2 X3 X4 X5 XY6 Y7 Y8 Y9 XY10 X11 X12 X13 XY14 Y15 Y16
    Friend Function ROUTERIsItClearPath(ByRef SourceForm As Source, A As MyPointStructure, B As MyPointStructure) As MyPointStructure
        Dim IndexISAMX1, zIndex, MyDirZ As Integer
        Dim MyXY, MyXYZ0 As MyPointStructure
        Dim CenterXY As MyLineStructure
        Dim I, J As Integer
        logA(2345, "Router is it clear path ", MyShowPoint(A), vbCrLf, MyShowPoint(B))
        logA(1787, MyShowLineXYXY(MyLine(A, B)))

        If 0 = B.x And 0 = B.y Then

            Return MyUniverse.MyStaticData.ZeroZero
        End If
        If A.x = 0 And A.y = 0 Then

            Return MyUniverse.MyStaticData.ZeroZero
        End If
        I = FindPathNameAt(SourceForm, A)
        J = FindPathNameAt(SourceForm, B)
        logA(1799, I.ToString, MyShowFlowChartRecord(SourceForm, False, I), J.ToString, MyShowFlowChartRecord(SourceForm, False, J), FlowChart_TablePathName(SourceForm, I), FlowChart_TablePathName(SourceForm, J))
        If MyOptionTest(34) Then PanToWorldXYXY(SourceForm, A.x, A.y, B.x, B.y)
        MyDrawWorldPath(SourceForm, MyLine(A, B), "BLUE")

        If MyOptionTest(34) Then
            MyDrawAll(SourceForm, A.x, A.y)
            MyDrawAll(SourceForm, B.x, B.y)
        End If

        If FMBRecurse("ROUTERIsItClearPath") > 10 Then

            Return MyUniverse.MyStaticData.ZeroZero ' end trying after 10 tries
        End If
        If MyOptionTest(34) Then
            PanToWorldXY(SourceForm, CInt((A.x + B.x) / 2), CInt((A.y + B.y) / 2))
            MyDrawWorldPath(SourceForm, MyLine(A, B), RandomColor(SourceForm))
        End If
        If A.x = B.x And A.y = B.y Then
            logA(1810, MyShowLineXYXY(MyLine(A, B)))
            If MyOptionTest(34) Then MyDrawWorldPath(SourceForm, MyLine(A, B), "GREEN")

            Return A
        End If
        If MyOptionTest(34) Then MyDrawWorldPath(SourceForm, MyLine(A, B), "LightGray")
        If A.x <> B.x And A.y <> B.y Then
            logA(1812, MyShowPointNames(A), MyShowPointNames(B))
            MyXY = ROUTERIsItClearPath(SourceForm, MyPoint1XY(A.x, A.y), MyPoint1XY(A.x, B.y)) ' try horizonal first
            If ZeroZero(MyXY) = False Then
                AddNEWFlowChartRecordPath(SourceForm, FlowChart_TablePathName(SourceForm, FindPathNameAt(SourceForm, A)), "/PATH", A.x, A.y, B.x, B.y, FlowChart_TableDataType(SourceForm, FindPathNameAt(SourceForm, A)))

                Return A
            End If


            MyXY = ROUTERIsItClearPath(SourceForm, MyPoint1XY(A.x, A.y), MyPoint1XY(B.x, A.y)) 'then vertical
            If ZeroZero(MyXY) = False Then
                AddNEWFlowChartRecordPath(SourceForm, FlowChart_TablePathName(SourceForm, FindPathNameAt(SourceForm, A)), "/PATH", A.x, A.y, B.x, B.y, FlowChart_TableDataType(SourceForm, FindPathNameAt(SourceForm, A)))

                Return A
            End If

            MyXY = ROUTERIsItClearPath(SourceForm, MyPoint1XY(A.x, B.y), MyPoint1XY(A.x, A.y)) ' try backwards second
            If ZeroZero(MyXY) = False Then
                AddNEWFlowChartRecordPath(SourceForm, FlowChart_TablePathName(SourceForm, FindPathNameAt(SourceForm, A)), "/PATH", A.x, A.y, B.x, B.y, FlowChart_TableDataType(SourceForm, FindPathNameAt(SourceForm, A)))

                Return A
            End If

            MyXY = ROUTERIsItClearPath(SourceForm, MyPoint1XY(B.x, A.y), MyPoint1XY(A.x, A.y))
            If ZeroZero(MyXY) = False Then
                AddNEWFlowChartRecordPath(SourceForm, FlowChart_TablePathName(SourceForm, FindPathNameAt(SourceForm, A)), "/PATH", A.x, A.y, B.x, B.y, FlowChart_TableDataType(SourceForm, FindPathNameAt(SourceForm, A)))

                Return A
            End If
            'not a valid direction from here?
        End If

        'Gets here when trying for a stright path 
        If MyOptionTest(34) Then MyDrawWorldPath(SourceForm, MyLine(A, B), RandomColor(SourceForm))
        If 0 = B.x And 0 = B.y Then

            Return MyUniverse.MyStaticData.ZeroZero
        End If
        If A.x = 0 And A.y = 0 Then

            Return MyUniverse.MyStaticData.ZeroZero
        End If
        'Clear_Window( SourceForm.flowchartpicturebox )
        If MyOptionTest(34) Then MyDrawWorldPath(SourceForm, MyLine(A, B), RandomColor(SourceForm))

        ' removed not needed ?MyDirZ=MyDirection(A, B)
        'Select Case MyDirZ
        ' Case 1, 7, 8, 9, 15, 16 'search in Y direction instead
        ' Case 2, 6, 10, 14 'special case search in both directions
        ' Case 3, 4, 5, 11, 12, 13
        If MyOptionTest(34) Then WW3_My_Draw_Line_Or_Path(SourceForm, MyLine(A, B), RandomColor(SourceForm), 10)
        ' find a path record for this X
        ISAMOpen(SourceForm, "FlowChart:X1")
        IndexISAMX1 = ISAMFindFirst(SourceForm, A.x)
        '''''IndexISAMX1 = FlowChart_Table??(Sourceform,  A.x)

        While IndexISAMX1 > 0 And FlowChart_TableCode(SourceForm, IndexISAMX1) <> "/Path"
            IndexISAMX1 = ISAMNext(SourceForm, IndexISAMX1)
        End While

        If IndexISAMX1 < 1 Then
            IndexISAMX1 = TopOfListBox(SourceForm.ListBoxFlowChart)

            While IndexISAMX1 > 1 And FlowChart_TableX1(SourceForm, IndexISAMX1) > A.x
                logA(1752, IndexISAMX1.ToString, A.x.ToString, FlowChart_TableX1(SourceForm, IndexISAMX1).ToString)
                IndexISAMX1 -= 1
            End While


            While FlowChart_TableX1(SourceForm, IndexISAMX1) < A.x
                IndexISAMX1 += 1
                If IndexISAMX1 > TopOfListBox(SourceForm.ListBoxFlowChart) Then


                    Return MyUniverse.MyStaticData.ZeroZero
                End If
            End While

            IndexISAMX1 -= 1
        Else
            If MyOptionTest(34) Then
                MyDrawPath(SourceForm, IndexISAMX1 - 1)
                MyDrawPath(SourceForm, IndexISAMX1)
                MyDrawPath(SourceForm, IndexISAMX1 + 1)
                MyDrawPath(SourceForm, IndexISAMX1)
                MyDrawPath(SourceForm, IndexISAMX1 - 1)
                WW3_My_Draw_Line_Or_Path(SourceForm, FlowChart2Line(SourceForm, IndexISAMX1 - 1), RandomColor(SourceForm), 10)
                WW3_My_Draw_Line_Or_Path(SourceForm, FlowChart2Line(SourceForm, IndexISAMX1), RandomColor(SourceForm), 10)
                WW3_My_Draw_Line_Or_Path(SourceForm, FlowChart2Line(SourceForm, IndexISAMX1 + 1), RandomColor(SourceForm), 10)
            End If
        End If
        'search for the first a.x

        While IndexISAMX1 > 1 And FlowChart_TableX1(SourceForm, IndexISAMX1) > 1 And FlowChart_TableX1(SourceForm, IndexISAMX1 - 1) >= A.x
            IndexISAMX1 -= 1
        End While


        'now the first a.x that is not a /path

        While FlowChart_TableCode(SourceForm, IndexISAMX1) <> "/Path"
            IndexISAMX1 += 1
            If IndexISAMX1 > TopOfListBox(SourceForm.ListBoxFlowChart) Then


                Return MyUniverse.MyStaticData.ZeroZero
            End If
        End While

        IndexISAMX1 -= 1
        MyDrawPath(SourceForm, IndexISAMX1)
        'search for the first a.x

        While IndexISAMX1 > 1 And FlowChart_TableX1(SourceForm, IndexISAMX1) > 1 And FlowChart_TableX1(SourceForm, IndexISAMX1 - 1) >= A.x
            IndexISAMX1 -= 1
        End While


        'now the first a.x that is not a /path

        While FlowChart_TableCode(SourceForm, IndexISAMX1) <> "/Path"
            IndexISAMX1 += 1
        End While


        While ROUTER_IsPathOnPath(SourceForm, MyLineXY(A, B),
                                      MyFlowChartPathLine(SourceForm, IndexISAMX1)) = False And
                                      A.x = FlowChart_TableX1(SourceForm, IndexISAMX1)
            IndexISAMX1 += 1
        End While


        If MyOptionTest(34) Then
            MyDrawWorldPath(SourceForm, MyLine(A, B), RandomColor(SourceForm))
            MyDrawPath(SourceForm, IndexISAMX1)
            logA(1768, MyShowPoint(A), MyShowPoint(B), IndexISAMX1.ToString)
        End If

        Do
            'testing if it is at the first location
            MyXY = ROUTERend(SourceForm, IndexISAMX1, B) ' only trying for first end?
            If ZeroZero(MyXY) = True Then


                Return MyUniverse.MyStaticData.ZeroZero
            End If
            'testing if it is at the end location
            If ZeroZero(MyXY) Then
                logA(1811, MyShowPoint(A), MyShowPoint(B))

                Return MyXY
            Else
                If MyOptionTest(34) Then
                    MyDrawWorldPath(SourceForm, MyLine(MyXY, A), RandomColor(SourceForm))
                End If
            End If
            If MyOptionTest(34) Then
                'draw the line that needs to be routed
                MyDrawWorldPath(SourceForm, MyLine(MyXY, B), RandomColor(SourceForm))
            End If
            'testing if this line goes from A to B points
            If ZeroZero(MyXY) = False And ZeroZero(B) = False And (MyXY.x = B.x Or MyXY.y = B.y) Then
                logA(1767, MyShowPoint(A), MyShowPoint(MyXY)) '
                If RouterMakePathPoints(SourceForm, MyXY, B) = True Then
                    If MyOptionTest(25) Then
                    Else
                    End If
                Else
                End If


                Return MyXY ' cause we made it to the end ' so tell itself to make a path from a to MyXYZ1
            Else
                logA(1746, MyShowPoint(A), MyShowPoint(B))
            End If

            OLD.Clear_Window(SourceForm.FlowChartPictureBox)
            'first try stepping in the right directions
            For zIndex = -4 To 4
                MyXY = ROUTERIsItClearPath(SourceForm, A, B)
                If ZeroZero(MyXY) = False Then
                    MyDirZ = (MyDirection(A, B) + zIndex + 16) Mod 16 ' clock step about the direction of where we are going
                    MyXY.x += MyUniverse.SysGen.Snaps.MyPointSnap * MySign(MyDirections(MyDirZ, 1, 1)) + MyUniverse.SysGen.Snaps.MyPointSnap * MySign(MyDirections(MyDirZ, 1, 2))
                    MyXY.y += MyUniverse.SysGen.Snaps.MyPointSnap * MySign(MyDirections(MyDirZ, 2, 1)) + MyUniverse.SysGen.Snaps.MyPointSnap * MySign(MyDirections(MyDirZ, 2, 2))
                    If MyOptionTest(34) Then
                        CenterXY = MyMinMaxP(A, B)
                        PanToWorldXYXY(SourceForm, A.x, A.y, B.x, B.y)
                        MyDrawLineXY_XY(SourceForm, CenterXY, RandomColor(SourceForm))
                        WW3_My_Draw_Line_Or_Path(SourceForm, MyLine(A, MyXY), RandomColor(SourceForm), 4)
                        WW3_My_Draw_Line_Or_Path(SourceForm, MyLine(B, MyXY), RandomColor(SourceForm), 4)
                        WW3_My_Draw_Line_Or_Path(SourceForm, MyLine(A, B), RandomColor(SourceForm), 4)
                    End If
                    ' so try to make a short path here
                    If RouterMakePathPoints(SourceForm, A, MyXY) = True Then
                        If MyOptionTest(25) Then
                        Else
                        End If
                    Else
                        'can not make a path because something is in the way
                    End If

                    logA(1734, MyShowPoint(A), MyShowPoint(B), MyShowPoint(MyXY))
                    MyXYZ0 = ROUTERCheckLinesEndAtEachOther(SourceForm, MyLine(A, MyXY), MyLine(MyXY, B))
                    If ZeroZero(MyXYZ0) = False Then
                        If RouterMakePathPoints(SourceForm, MyXY, B) = True Then
                            If MyOptionTest(25) Then
                            Else
                            End If
                        Else
                        End If

                        Return MyXY
                    End If
                End If
            Next zIndex
            IndexISAMX1 += 1
        Loop While IndexISAMX1 <= TopOfListBox(SourceForm.ListBoxFlowChart) And FlowChart_TableX1(SourceForm, IndexISAMX1) = A.x


        Return MyUniverse.MyStaticData.ZeroZero  ' return how far (in XY) it BranchTo below
    End Function



    'Find a Line all the want to match
    'returns A if path found, MyUniverse.MyStaticData.ZeroZero if not possible, and B if did not make it to B
    'router this actually tries to find a blank space from A to B and returns a mid point as close as it could get 
    Friend Function RouterHowCloseCanYouGetToHere(ByRef SourceForm As Source, A As MyPointStructure, B As MyPointStructure) As MyPointStructure
        Dim XY As MyPointStructure = Nothing
        Dim E, F, XY0 As MyPointStructure
        Dim J As Integer
        DoEvent(1232, "How Close")

        logA(2345, "Router How Close Can You Get to Here  ", MyShowPoint(A), vbCrLf, MyShowPoint(B))
        If MyOptionTest(34) Then
            PanToWorldPP(SourceForm, A, B)
            MyDrawWorldPath(SourceForm, MyLine(A, B), "green")
        End If
        If ZeroZero(A) = True Then

            Return MyUniverse.MyStaticData.ZeroZero
        End If
        If ZeroZero(B) = True Then

            Return MyUniverse.MyStaticData.ZeroZero
        End If

        If MyDebug(A_DEBUG) Then
            logA(2490, MyShowPointNames(A), MyShowPointNames(B))
        End If
        E = A
        If MyABS(E.x) >= MyABS(E.y) Then
            E.x = 0
        Else
            E.y = 0
        End If

        F = A
        F.x += 1 * MySign(E.x) * MyUniverse.SysGen.Constants.ConstantSymbolCenter
        F.y += 1 * MySign(E.y) * MyUniverse.SysGen.Constants.ConstantSymbolCenter
        J = MyUniverse.SysGen.Snaps.MyPointSnap
        If MyOptionTest(34) Then
            WW3_My_Draw_Line_Or_Path(SourceForm, MyLine(A, B), "Blue", 4)
            WW3_My_Draw_Line_Or_Path(SourceForm, MyLine(F, B), "Blue", 2)
            WW3_My_Draw_Line_Or_Path(SourceForm, MyLine(A, F), "Blue", 2)
            'Find the longest stright Line from a to b
            'First try the longest way
        End If
        XY0 = MyUniverse.MyStaticData.ZeroZero  'ROUTERIsItClearPath(F, B)
        WW3_My_Draw_Line_Or_Path(SourceForm, MyLine(XY0.x, XY0.y, 0, 0), RandomColor(SourceForm), 1)
        XY0 = ROUTERIsItClearPath(SourceForm, B, A)
        If MyOptionTest(34) Then WW3_My_Draw_Line_Or_Path(SourceForm, MyLine(XY0.x, XY0.y, 0, 0), RandomColor(SourceForm), 1)


        'try to route a point from a.xy to 
        If ZeroZero(ROUTERIsItClearPath(SourceForm, A, B)) = False Then
            'getting here means that I need to add a path from A to B
            If RouterMakePathPoints(SourceForm, A, F) = True Then
                If MyOptionTest(25) Then
                Else
                End If
            Else
            End If
            If ROUTER_Auto_Path(SourceForm, F, B, A.Named.PathName) = True Then
                If MyOptionTest(25) Then
                Else
                End If
            Else
            End If

            Return F
        End If

        'from here on we should step in any direction to find a path
        logA(1770, MyShowPoint(A), MyShowPoint(B))

        If ZeroZero(ROUTERIsItClearPath(SourceForm, A, MyPoint1XY(A.x, B.y))) = False Then
            If RouterMakePathPoints(SourceForm, A, MyPoint1XY(A.x, A.y + XY.y)) = True Then
                If MyOptionTest(25) Then
                Else
                End If
            Else
            End If

            Return MyPoint1XY(A.x, A.y + XY.y)
        Else

        End If

        If ZeroZero(ROUTERIsItClearPath(SourceForm, A, MyPoint1XY(A.x + XY.x, A.y))) = False Then

            Return MyPoint1XY(A.x + XY.x, A.y)
        End If

        Return A
    End Function ' returns how close it got (or zeroZero if it fails to find many path segments)




    'THis tries to find a path from A to B (If fails then save the path that ends  closest to B)
    'router step four Try to find blank space to put a path from point A to point B
    ' When a path is made for connect A to ending of path B then return true and write all of the
    ' path segments to flowChart
    Friend Function ROUTER_Auto_Path(ByRef SourceForm As Source, P_A As MyPointStructure, P_B As MyPointStructure, PathName As String) As Boolean
        Dim NextPointXY As MyPointStructure
        Dim ColorName As String

        If P_A.x = 0 And P_A.y = 0 Then

            Return False
        End If
        If P_B.x = 0 And P_B.y = 0 Then

            Return False
        End If
        ColorName = "GREEN"
        If MyDebug(A_DEBUG) Then
            logA(3348, PathName, ColorName, MyShowPoint(P_A), MyShowPoint(P_B))
        End If
        logA(2345, "Router AUTO PATH  ", MyShowPoint(P_A), vbTab & vbTab, MyShowPoint(P_B))
        MyDrawWorldPath(SourceForm, MyLine(P_A, P_B), ColorName)
        MyDrawAllPaths(SourceForm, FindNetName(PathName))
        ' If I can find a point between these two then make a path, and then return true
        ' If NOT try again from as close as I got.(Recursive trying) utile it makes it (or is unable to make it.

        '1.0 try stepping across the longest path looking for one that goes the the X or Y of B
        'Assume that there is already a point where we are starting from.
        'ToDo make it so that it can do 8 directions, (For now just 4)  Angles will be off the grid by half so that they will not interfere with the horizonal/vert Lines..

        'sets the myUniverse ... to have the distance you can go in each direction 
        logA(1772, PathName, MyShowPoint(P_A), MyShowPoint(P_B))
        If MyOptionTest(34) Then
            OLD.Clear_Window(SourceForm.FlowChartPictureBox)
            MyDrawWorldPath(SourceForm, MyLine(P_A, P_B), ColorName)
        End If
        If P_A.x = 0 And P_A.y = 0 And P_B.x = 0 And P_B.y = 0 Then
            'This should not happen?

            Return False
        End If
        ' log_X (1815, MyShowPoint(P_A) & MyShowPoint(P_B))
        NextPointXY = RouterHowCloseCanYouGetToHere(SourceForm, P_A, P_B) 'returns the longest that you can go in the (1-16) directions.
        If MyComparePoint(NextPointXY, MyUniverse.MyStaticData.ZeroZero) Then

            Return False
        End If
        logA(1773, MyShowPoint(NextPointXY), MyShowPoint(P_B))
        If NextPointXY.x = P_B.x And NextPointXY.y = P_B.y Then
            logA(1774, MyShowPoint(P_A), MyShowPoint(P_B))
            AddFlowChartRecordPath(SourceForm, PathName, "/path", NextPointXY.x, NextPointXY.y, P_B.x, P_B.y, "DataType")

            Return True
        End If
        If (P_A.x = NextPointXY.x) And (P_A.y = NextPointXY.y) Then
            logA(1775, MyShowPoint(P_A))

            Return False
        End If
        If ROUTER_Auto_Path(SourceForm, NextPointXY, P_B, PathName) = True Then
            'So we have to add the path before this also (Cause the recursion found the above or the below and is returning here
            AddFlowChartRecordPath(SourceForm, PathName, "/path", P_A.x, P_A.y, NextPointXY.x, NextPointXY.y, "DataType")

            Return True
        End If
        'todo in the future
        '2.0 try stepping across the shortest path looking for one that goes the the X or Y of B
        logA(1776, PathName, MyShowPointNames(P_A), MyShowPointNames(P_B))

        Return False
    End Function 'ROUTER_Auto_Path returns  false if not found returns false it a path could not be found

    Friend Function FlowChart2Point(ByRef SourceForm As Source, IndexFlowChart As Integer) As MyPointStructure
        FlowChart2Point = Nothing
        If MyDebug(A_DISPLAY) Then logA(2492)
        FlowChart2Point.x = FlowChart_TableX1(SourceForm, IndexFlowChart)
        FlowChart2Point.y = FlowChart_TableY1(SourceForm, IndexFlowChart)
        FlowChart2Point.Named.PathName = FlowChart_TablePathName(SourceForm, IndexFlowChart)
        FlowChart2Point.Named.SymbolName = ""
        FlowChart2Point.Named.PointName = ""
        FlowChart2Point.Named.IsWorldWindow = WorldOrWindow(FlowChart2Point)
        Return FlowChart2Point
    End Function

    Friend Function FlowChart2Line(ByRef SourceForm As Source, IndexFlowChart As Integer) As MyLineStructure
        FlowChart2Line = Nothing
        If FlowChart_TableCode(SourceForm, IndexFlowChart) <> "/path" Then
            Return MyUniverse.MyStaticData.ZeroZeroZeroZero
        End If
        FlowChart2Line.a.x = FlowChart_TableX1(SourceForm, IndexFlowChart)
        FlowChart2Line.a.y = FlowChart_TableY1(SourceForm, IndexFlowChart)
        FlowChart2Line.b.x = FlowChart_TableX2(SourceForm, IndexFlowChart)
        FlowChart2Line.b.y = FlowChart_TableY2(SourceForm, IndexFlowChart)
        FlowChart2Line.a.Named.PathName = FlowChart_TablePathName(SourceForm, IndexFlowChart)
        FlowChart2Line.b.Named.PathName = FlowChart_TablePathName(SourceForm, IndexFlowChart)
        FlowChart2Line.a.Named.IsWorldWindow = "World"
        FlowChart2Line.b.Named.IsWorldWindow = "World"
    End Function


    'test all four ends of the two paths to see if they are connected together.
    Friend Function FindClosestPathEnds(ByRef SourceForm As Source, IndexFlowChart1 As Integer, IndexFlowChart2 As Integer) As MyLineStructure
        Dim XY1, XY2 As MyLineStructure
        Dim T1, T2, T3, T4, T5, T6, T7 As Integer
        XY1 = FlowChart2Line(SourceForm, IndexFlowChart1)
        XY2 = FlowChart2Line(SourceForm, IndexFlowChart2)
        If MyDebug(A_DISPLAY) Then logA(2494, MyShowALine(XY1), MyShowALine(XY2))

        If XY1.a.x = 0 And XY1.a.y = 0 Then logA(1780)
        If XY1.b.x = 0 And XY1.b.y = 0 Then logA(1780)
        If XY2.a.x = 0 And XY2.a.y = 0 Then logA(1780)
        If XY2.b.x = 0 And XY2.b.y = 0 Then logA(1780)
        'Test if they are already connected
        T1 = MyDistancePath(XY1, XY2)
        If T1 = 0 Then Return Nothing 'do not need to route it, cause they are connected.
        'First find one from each that is the closest 
        T1 = MyDistance(XY1.a, XY2.a)
        T2 = MyDistance(XY1.a, XY2.b)
        T3 = MyDistance(XY1.b, XY2.a)
        T4 = MyDistance(XY1.b, XY2.b)
        T5 = MyMin(T1, T2)
        T6 = MyMin(T3, T4)
        T7 = MyMin(T5, T6)
        If T7 = T1 Then Return MyLine(XY1.a, XY2.a) 'a to a
        If T7 = T2 Then Return MyLine(XY1.a, XY2.b) 'a to b
        If T7 = T3 Then Return MyLine(XY1.b, XY2.a) 'b to a
        If T7 = T4 Then Return MyLine(XY1.b, XY2.b) 'b to b
        Return MyLine(XY1.a, XY2.a)

    End Function

    'checks if there is a path
    ' returns false if the two Line segments meet.
    ' if the two do not meet then this path is not routed between paths 1 and path 2)
    Friend Function ROUTERPath_IsAPathROUTERd(ByRef SourceForm As Source, IndexFlowChart1 As Integer, IndexFlowChart2 As Integer) As Boolean
        Dim XY As MyLineStructure

        logA(2345, "Router path is a path routered ", MyShowFlowChartRecord(SourceForm, False, IndexFlowChart1), vbCrLf, MyShowFlowChartRecord(SourceForm, False, IndexFlowChart2))

        XY = FindClosestPathEnds(SourceForm, IndexFlowChart1, IndexFlowChart2)
        'Now find a path for the Line XY
        If XY.a.x = 0 And XY.a.y = 0 And XY.b.x = 0 And XY.b.y = 0 Then 'returning nothing, which is all zeros 

            Return False
        End If

        logA(1785, MyShowALine(XY), MyShowFlowChartRecord(SourceForm, True, IndexFlowChart1), MyShowFlowChartRecord(SourceForm, True, IndexFlowChart2))
        ROUTERAutoPath(SourceForm, IndexFlowChart1, IndexFlowChart2)

        Return True
    End Function ' returns true if these two paths are connected.


    Friend Function RouterConnectPaths(ByRef SourceForm As Source, IndexFlowChart1 As Integer, IndexFlowChart2 As Integer, PathName As String) As Boolean
        Dim I As Integer ' look through all of the NetLinks
        Dim PutIt1, PutIt2 As Integer
        If IndexFlowChart1 = IndexFlowChart2 Then Return False
        If MyDebug(A_DISPLAY) Then logA(2500, IndexFlowChart1.ToString, IndexFlowChart2.ToString)
        'todo is this necessary '''I1=BinarySearch4Index(Options.ListBoxVariables,IndexFlowChart1)
        'todo is this necessary '''I2=BinarySearch4Index(Options.ListBoxVariables,IndexFlowChart2)

        PathName = CheckThisPathName(SourceForm, PathName, IndexFlowChart1)
        PathName = CheckThisPathName(SourceForm, PathName, IndexFlowChart2)


        PutIt1 = 0
        PutIt2 = 0

        For I = LBound(Net_FileLinks) To SourceForm.ListBoxVariables.count - 1
            If MyInStr(FD & IndexFlowChart1 & FD, Net_TableLinks(I)) > 0 Then
                PutIt1 = I
            End If
            If MyInStr(FD & IndexFlowChart2 & FD, Net_TableLinks(I)) > 0 Then
                PutIt2 = I
            End If
            If PutIt1 <> 0 And PutIt2 <> 0 Then Exit For
        Next


        'Everything is OK
        If PutIt1 <> 0 And PutIt2 <> 0 And PutIt1 = PutIt2 Then
            Return True
        End If



        'One not there so add to two
        If PutIt1 = 0 And PutIt2 <> 0 Then
            Net_TableLinks(PutIt2, Net_TableLinks(PutIt2) & FD & IndexFlowChart1 & FD)
            CleanListOfNet_TableLinks(PutIt2)
            Return False
        End If
        'Two not there so add to one
        If PutIt2 = 0 And PutIt1 <> 0 Then
            Net_TableLinks(PutIt1, Net_TableLinks(PutIt1) & FD & IndexFlowChart2 & FD)
            CleanListOfNet_TableLinks(PutIt1)
            Return False
        End If

        ' If neither one or two is there then add a new NetLinks
        If PutIt1 = 0 And PutIt2 = 0 Then
            I = SourceForm.ListBoxVariables.count - 1 + 1
            ReDim Preserve Net_FileLinks(I)
            ReDim Preserve Net_FilePathNames(I)
            Net_TableLinks(I, FD & IndexFlowChart1 & FD & IndexFlowChart2 & FD)
            Net_TablePathNames(I, PathName) ' Add a new path name
            Return False
        End If

        ' Check if they are in different ones, not and fix them.
        If PutIt1 <> 0 And PutIt2 <> 0 And PutIt1 <> PutIt2 Then
            ' We have to connect the two nets together.
            CombineNetLinksInto(SourceForm, PutIt1, PutIt2)
        Else
        End If

        Return False
    End Function


    'This tries to combine paths with or without the same name when they both end at the same point
    ' Returns the NetIndex that it is in, and cleans up (ignores what it say's it is in for now)
    Friend Function RouterConnectPath(ByRef SourceForm As Source, IndexFlowChart_1 As Integer) As Integer
        Dim IndexFlowChart_2, IndexNetLinks_1, IndexNetLinks_2 As Integer

        If FlowChart_TableCode(SourceForm, IndexFlowChart_1) <> "/path" Then Return ConstantMyErrorCode
        logA(2345, "Router Connnect Path " & MyShowFlowChartRecord(SourceForm, False, IndexFlowChart_1))
        LogDebug(1053, Err7, "##### Start with " & MyShowFlowChartRecord(SourceForm, False, IndexFlowChart_1))
        IndexFlowChart_2 = RouterPathConnects2(SourceForm, FlowChart_TableCode(SourceForm, IndexFlowChart_1), IndexFlowChart_1) ' get what else it is connected to (Could return either to another path, or to a Symbol or nothing (an error?)
        LogDebug(1054, Err7, "##### add with " & IndexFlowChart_1.ToString & "," & IndexFlowChart_2.ToString)
        If IndexFlowChart_2 <= 1 Then
            Return ConstantMyErrorCode
        End If
        logA(1094, MyShowFlowChartRecord(SourceForm, False, IndexFlowChart_1), MyShowFlowChartRecord(SourceForm, False, IndexFlowChart_2))
        MyDrawLineXYXY(SourceForm, IndexFlowChart_1, IndexFlowChart_2, "RED")
        If MyDebug(A_DISPLAY) Then
            IndexNetLinks_1 = FlowChart_TableNet(SourceForm, IndexFlowChart_1) ' Get if this is already there
            logA(2501, MyShowFlowChartRecord(SourceForm, False, IndexFlowChart_1), MyShowFlowChartRecord(SourceForm, False, IndexFlowChart_2), MyShowNetLinks(SourceForm, IndexNetLinks_1))
        End If

        If IndexFlowChart_2 = IndexFlowChart_1 Then
            If MyDebug(A_INFORMATION) Then logA(1788,
                                                MyShowFlowChartRecord(SourceForm, True, IndexFlowChart_1),
                                                MyShowFlowChartRecord(SourceForm, True, IndexFlowChart_2),
                                                MyShowNetLinks(SourceForm, FlowChart_TableNet(SourceForm, IndexFlowChart_1)))
        End If

        If DistanceBetween2Points(SourceForm, IndexFlowChart_1, IndexFlowChart_2) = 0 Then
            logA(1789, MyShowFlowChartRecord(SourceForm, False, IndexFlowChart_1), MyShowFlowChartRecord(SourceForm, False, IndexFlowChart_2))
            Return ConstantMyErrorCode
        End If
        logA(1095, DistanceBetween2Points(SourceForm, IndexFlowChart_1, IndexFlowChart_2).ToString, MyShowFlowChartRecord(SourceForm, False, IndexFlowChart_1), MyShowFlowChartRecord(SourceForm, False, IndexFlowChart_2))

        IndexNetLinks_1 = FlowChart_TableNet(SourceForm, IndexFlowChart_1) ' Get if this is already there
        IndexNetLinks_2 = FlowChart_TableNet(SourceForm, IndexFlowChart_2) ' Get if this is already there
        logA(1096, Net_TablePathNames(IndexNetLinks_1), Net_TablePathNames(IndexNetLinks_2))
        If Net_TablePathNames(IndexNetLinks_1) <> Net_TablePathNames(IndexNetLinks_2) Then
            'need to tell more about this XY point (and Symbols attached? more Lines?
            If PathOnTop(SourceForm, IndexFlowChart_1, IndexFlowChart_2) Then
                logA(2207,
                         MyShowAllNet(SourceForm, IndexNetLinks_1),
                         MyShowNetLinks(SourceForm, IndexNetLinks_1),
                         MyShowFlowChartRecord(SourceForm, False, IndexFlowChart_1),
                         MyShowAllNet(SourceForm, IndexNetLinks_2),
                         MyShowNetLinks(SourceForm, IndexNetLinks_2),
                         MyShowFlowChartRecord(SourceForm, False, IndexFlowChart_2))
                logA(2208,
                           FlowChart_TableX1(SourceForm, IndexFlowChart_1).ToString,
                           FlowChart_TableY1(SourceForm, IndexFlowChart_1).ToString,
                           MyShowFlowChartRecord(SourceForm, True, IndexFlowChart_1),
                           MyShowFlowChartRecord(SourceForm, True, IndexFlowChart_2))
                Return ConstantMyErrorCode
            Else
                'the two paths are not the same variable / path name, and they do not connect.
                logA(1097, MyShowNetLinks(SourceForm, IndexNetLinks_1), MyShowNetLinks(SourceForm, IndexNetLinks_2))
                Return ConstantMyErrorCode
            End If
        Else
            logA(1098, MyShowNetLinks(SourceForm, IndexNetLinks_1), MyShowNetLinks(SourceForm, IndexNetLinks_2))
        End If
        If IndexNetLinks_1 <> IndexNetLinks_2 Then
            If IndexNetLinks_1 > 0 Then ' Found the nets that index FlowChart is in
                If IndexNetLinks_2 > 0 Then ' also found that it is in this network
                    If FlowChart_TableCode(SourceForm, IndexFlowChart_1) = "/path" Then
                        If FlowChart_TableCode(SourceForm, IndexFlowChart_2) = "/path" Then
                            If MyDebug(A_INFORMATION) Then logA(1791, MyShowFlowChartRecord(SourceForm, True, IndexFlowChart_1), MyShowNetLinks(SourceForm, IndexNetLinks_1) & CT & MyShowFlowChartRecord(SourceForm, True, IndexFlowChart_2))
                            'DoesPathNamesMatch(IndexFlowChart_1, IndexFlowChart_2  )
                            CombineNetLinksInto(SourceForm, IndexNetLinks_1, IndexNetLinks_2) ' combine them together and change all of the FlowChart links to point to the new
                            Return IndexNetLinks_2
                        Else
                            If FlowChart_TableCode(SourceForm, IndexFlowChart_2) = My_keyWord(My_KeyConstUse) Then
                                If MyDebug(A_INFORMATION) Then logA(1792, MyShowFlowChartRecord(SourceForm, True, IndexFlowChart_2), MyShowFlowChartRecord(SourceForm, True, IndexFlowChart_1), MyShowNetLinks(SourceForm, IndexNetLinks_1) & CT & MyShowNetLinks(SourceForm, IndexNetLinks_2))
                            Else
                                If MyDebug(A_INFORMATION) Then logA(1793, MyShowFlowChartRecord(SourceForm, True, IndexFlowChart_1), MyShowNetLinks(SourceForm, IndexNetLinks_1), vbCrLf & MyShowNetLinks(SourceForm, IndexNetLinks_2))
                            End If
                        End If
                    Else
                        If FlowChart_TableCode(SourceForm, IndexFlowChart_2) = "/path" Then
                            If MyDebug(A_INFORMATION) Then logA(1794, MyShowFlowChartRecord(SourceForm, True, IndexFlowChart_1), MyShowNetLinks(SourceForm, IndexNetLinks_1) & CT & MyShowNetLinks(SourceForm, IndexNetLinks_2))
                        Else
                            If MyDebug(A_INFORMATION) Then logA(1795, MyShowFlowChartRecord(SourceForm, True, IndexFlowChart_1), MyShowNetLinks(SourceForm, IndexNetLinks_1) & CT & MyShowNetLinks(SourceForm, IndexNetLinks_2))
                        End If
                    End If
                End If
            End If
        End If
        'autoroute path
        If CountLinks(IndexNetLinks_1) > 1 Then
            If IndexNetLinks_1 > 0 And IndexFlowChart_1 > 0 And IndexNetLinks_2 <> IndexNetLinks_1 Then
                If MyDebug(A_INFORMATION) Then logA(1796, MyShowNetLinks(SourceForm, IndexNetLinks_1), MyShowNetLinks(SourceForm, IndexNetLinks_2))
                If ROUTERIndex2Net(SourceForm, IndexFlowChart_1, IndexNetLinks_1) = True Then
                    logA(1797, MyShowNetLinks(SourceForm, IndexNetLinks_1) & CT & MyShowNetLinks(SourceForm, IndexNetLinks_2), MyShowFlowChartRecord(SourceForm, False, IndexFlowChart_1))
                Else
                    logA(1798)
                End If
            End If
        End If
        Return 0
    End Function


    Friend Function CountLinks(IndexNetLinks As Integer) As Integer
        Dim Temp As String
        If MyDebug(A_FMB) Then logA(2502, IndexNetLinks.ToString)
        'would be faster to count the comma's (FD's)  than decompile the numbers from the list
        CountLinks = 0
        Temp = Net_TableLinks(IndexNetLinks)


        While Len(Temp) > 0
            If PopValue(Temp) > 0 Then
                CountLinks += 1
            End If
        End While

    End Function 'count links




    ' returns the index of the FlowChart atom that it connects to.(or zero if none)
    ' return to what other FlowChart it connect to (either /use or /path)
    Friend Function RouterPathConnects2(ByRef SourceForm As Source, Connects2 As String, IndexFlowChart1 As Integer) As Integer
        Dim IndexFlowChart2, Index_Named, IndexSymbol, MyTopOfFile, X1, Y1 As Integer
        Dim TempR As MyPointStructure
        Dim TempD As Integer

        For IndexFlowChart2 = 1 To TopOfListBox(SourceForm.ListBoxFlowChart)
            If IndexFlowChart2 <> IndexFlowChart1 Then 'do nothing with itself 
                Select Case LCase(FlowChart_TableCode(SourceForm, IndexFlowChart2))
                    Case My_keyWord(My_KeyConstUse)
                        If Connects2 = "/path" Then
                            'this should get the 
                            'IndexNamed = CorrectingIndexes(SourceForm   ,   FlowChart_TableSymbol_Name(SourceForm  ,  IndexFlowChart2))
                            logA(1000, "Starting to connect path to symbol ", Connects2, MyShowFlowChartRecord(SourceForm, False, IndexFlowChart1))
                            LogDebug(1055, Err7, "A1)" & FlowChart_TableSymbol_Name(SourceForm, IndexFlowChart1) & ",   " & IndexFlowChart1.ToString)
                            LogDebug(1056, Err7, "A2)" & FlowChart_TableSymbol_Name(SourceForm, IndexFlowChart2) & ",   " & IndexFlowChart2.ToString)
                            LogDebug(1057, Err7, "B1)" & FindInSymbolList(SourceForm, FlowChart_TableSymbol_Name(SourceForm, IndexFlowChart1)).ToString & ",   " & IndexFlowChart1.ToString)
                            LogDebug(1058, Err7, "B2)" & FindInSymbolList(SourceForm, FlowChart_TableSymbol_Name(SourceForm, IndexFlowChart2)).ToString & ",   " & IndexFlowChart2.ToString)
                            LogDebug(1059, Err7, "C1)" & MyShowNamedRecord(False, FindInSymbolList(SourceForm, FlowChart_TableSymbol_Name(SourceForm, IndexFlowChart1))) & ",   " & IndexFlowChart1.ToString)
                            LogDebug(1060, Err7, "C2)" & MyShowNamedRecord(False, FindInSymbolList(SourceForm, FlowChart_TableSymbol_Name(SourceForm, IndexFlowChart2))) & ",   " & IndexFlowChart2.ToString)
                            LogDebug(1061, Err7, "D1)" & MyShowSymbolRecord(SourceForm, False, FindInSymbolList(SourceForm, FlowChart_TableSymbol_Name(SourceForm, IndexFlowChart1))) & ",   " & IndexFlowChart1.ToString)
                            LogDebug(1062, Err7, "D2)" & MyShowSymbolRecord(SourceForm, False, FindInSymbolList(SourceForm, FlowChart_TableSymbol_Name(SourceForm, IndexFlowChart2))) & ",   " & IndexFlowChart2.ToString)
                            LogDebug(1063, Err7, "E1)" & MyShowNamedAndSymbolRecords(SourceForm, False, FindInSymbolList(SourceForm, FlowChart_TableSymbol_Name(SourceForm, IndexFlowChart1))) & ",   " & IndexFlowChart1.ToString)
                            LogDebug(1064, Err7, "E2)" & MyShowNamedAndSymbolRecords(SourceForm, False, FindInSymbolList(SourceForm, FlowChart_TableSymbol_Name(SourceForm, IndexFlowChart2))) & ",   " & IndexFlowChart2.ToString)
                            Index_Named = FindInSymbolList(SourceForm, FlowChart_TableSymbol_Name(SourceForm, IndexFlowChart2))
                            LogDebug(1065, Err7, "F) ????? Invalid Named index " & Index_Named.ToString & CT & MyShowNamedAndSymbolRecords(SourceForm, False, Index_Named))
                            logA(1099, MyShowNamedRecord(False, Index_Named))
                            If Index_Named > 0 Then
                                IndexSymbol = Named_TableSymbolIndexes(Index_Named) ' Get the shortcut to the start of the name
                                If IndexSymbol > 0 Then
                                    If MyDebug(A_STATUS) Then logA(2696, SHL(MyNoCR(MyShowFlowChartRecord(SourceForm, False, IndexFlowChart2), vbTab & ":" & vbTab)) & FD & SHL(MyNoCR(MyShowSymbolGraphic(False, IndexSymbol), vbTab & ":" & vbTab)))
                                    IndexSymbol += 1 ' move over the name
                                    MyTopOfFile = TopOfFile(SourceForm, "Symbol") ' For the last Symbol in the list


                                    While Symbol_TableCoded_String(IndexSymbol) <> "/name" And IndexSymbol <= MyTopOfFile
                                        If MyDebug(A_STATUS) Then logA(2697, SHL(MyNoCR(MyShowFlowChartRecord(SourceForm, False, IndexFlowChart2), vbTab & ":" & vbTab)) & FD & SHL(MyNoCR(MyShowSymbolGraphic(False, IndexSymbol), vbTab & ":" & vbTab)))
                                        Select Case LCase(Symbol_TableCoded_String(IndexSymbol))
                                            Case "/point"
                                                TempR = MyRotated(SourceForm, IndexSymbol, IndexFlowChart2)
                                                X1 = FlowChart_TableX1(SourceForm, IndexFlowChart2) + TempR.x 'Symbol_TableX1(IndexSymbol)
                                                Y1 = FlowChart_TableY1(SourceForm, IndexFlowChart2) + TempR.y 'Symbol_TableY1(IndexSymbol)
                                                TempD = DistanceBetweenTwoPoints(FlowChart_TableX1(SourceForm, IndexFlowChart1), FlowChart_TableY1(SourceForm, IndexFlowChart1), X1, Y1)
                                                If TempD = 0 Then
                                                    logA(1801, MyShowNamedRecord(True, Index_Named), MyShowFlowChartRecord(SourceForm, True, IndexFlowChart2))


                                                    Return IndexFlowChart1
                                                End If
                                                TempD = DistanceBetweenTwoPoints(FlowChart_TableX2(SourceForm, IndexFlowChart1), FlowChart_TableY2(SourceForm, IndexFlowChart1), X1, Y1)
                                                If TempD = 0 Then
                                                    logA(1802, MyShowNamedRecord(True, Index_Named), MyShowFlowChartRecord(SourceForm, True, IndexFlowChart2))


                                                    Return IndexFlowChart1
                                                End If
                                            Case Nothing
                                                Exit While' Must be at the end of the list (last Symbol)
                                            Case "/unknown" 'ignore 
                                                logA(1803, MyShowSymbolGraphic(True, IndexFlowChart1), Symbol_TableCoded_String(IndexFlowChart1))
                                            Case "/Line" ' ignore Lines
                                            Case Else
                                                If MyDebug(A_INFORMATION) Then logA(1804, Symbol_TableCoded_String(IndexSymbol), IndexSymbol.ToString, MyShowSymbolGraphic(False, IndexSymbol))
                                                Exit While
                                        End Select
                                        IndexSymbol += 1 ' Try next
                                    End While

                                Else
                                    'todo Do I need self correcting pointer
                                    LogDebug(3483, Err7, IndexFlowChart1.ToString & ", " & IndexFlowChart2.ToString & ", " & Index_Named.ToString & ", " & IndexSymbol.ToString)
                                    LogDebug(3484, Err7, MyShowFlowChartRecord(SourceForm, True, IndexFlowChart1))
                                    LogDebug(3485, Err7, MyShowFlowChartRecord(SourceForm, True, IndexFlowChart2))
                                    LogDebug(3486, Err7, MyShowNamedRecord(True, Index_Named))
                                    LogDebug(3487, Err7, MyShowSymbolGraphic(True, IndexSymbol))
                                    CorrectingIndexes(SourceForm, Named_TableSymbolName(Index_Named))
                                    logA(1182, MyShowNamedAndSymbolRecords(SourceForm, False, Index_Named))
                                    LogDebug(3488, Err7, MyShowAllSymbolNames(SourceForm, FlowChart_TableSymbol_Name(SourceForm, IndexFlowChart1)))
                                    LogDebug(3489, Err7, MyShowAllSymbolNames(SourceForm, FlowChart_TableSymbol_Name(SourceForm, IndexFlowChart2)))
                                    LogDebug(3490, Err7, MyShowAllSymbolNames(SourceForm, Named_TableSymbolName(Index_Named)))
                                End If
                            Else
                                logA(1151, MyShowFlowChartRecord(SourceForm, False, IndexFlowChart1), MyShowNamedRecord(False, Index_Named), MyShowNamedAndSymbolRecords(SourceForm, False, IndexSymbol))
                                If FlowChart_TableCode(SourceForm, IndexFlowChart1) <> "/path" Then
                                    If MyDebug(A_INFORMATION) Then logA(1805, MyShowFlowChartRecord(SourceForm, True, IndexFlowChart2), MyShowFlowChartRecord(SourceForm, True, IndexFlowChart1))
                                End If
                            End If
                        End If
                    Case "/path"
                        If Connects2 = "/path" Then
                            ' Check Points
                            If MyDebug(A_FMB) Then
                                logA(1365, MyShowFlowChartRecord(SourceForm, False, IndexFlowChart1))
                                logA(1365, MyShowFlowChartRecord(SourceForm, False, IndexFlowChart2))
                            End If
                            TempD = DistanceBetween2Points(SourceForm, IndexFlowChart1, IndexFlowChart2)
                            logA(3565, "Distance between " & TempD.ToString & CT & vbTab & MyShowFlowChartRecord(SourceForm, False, IndexFlowChart1) & CT & vbTab & MyShowFlowChartRecord(SourceForm, False, IndexFlowChart2))
                            If TempD <> 0 And FlowChart_TablePathName(SourceForm, IndexFlowChart1) = FlowChart_TablePathName(SourceForm, IndexFlowChart2) Then
                                If FlowChart_TablePathName(SourceForm, IndexFlowChart1) <> FlowChart_TablePathName(SourceForm, IndexFlowChart2) Then
                                    If MyDebug(A_INFORMATION) Then
                                        logA(1808, IndexFlowChart1.ToString, MyShowFlowChartRecord(SourceForm, False, IndexFlowChart1), IndexFlowChart2.ToString, MyShowFlowChartRecord(SourceForm, False, IndexFlowChart2))
                                    End If
                                    '''''MakeErrorAt( SourceForm  , MyPoint1XY(FlowChart_TableX1(SourceForm ,IndexFlowChart2), FlowChart_TableY1(SourceForm    , SourceForm    , IndexFlowChart2)), MyErrorList(1024) & FlowChart_TablePathName(SourceForm, IndexFlowChart1))
                                    If MyDebug(A_INFORMATION) Then
                                        PanToWorldXY(SourceForm, FlowChart_TableX1(SourceForm, IndexFlowChart2), FlowChart_TableY1(SourceForm, IndexFlowChart2))
                                    End If
                                Else
                                    logA(1806, TempD.ToString, MyShowFlowChartRecord(SourceForm, True, IndexFlowChart1), MyShowFlowChartRecord(SourceForm, True, IndexFlowChart2))
                                    AddFlowChartRecordPath(SourceForm,
                                                           FlowChart_TablePathName(SourceForm, IndexFlowChart1),
                                                           "/path",
                                                           MyLine(FlowChart_TableX2(SourceForm, IndexFlowChart1),
                                                                  FlowChart_TableY2(SourceForm, IndexFlowChart1),
                                                                  FlowChart_TableX2(SourceForm, IndexFlowChart2),
                                                                  FlowChart_TableY2(SourceForm, IndexFlowChart2)),
                                                           FlowChart_TableDataType(SourceForm, IndexFlowChart1))
                                    OLD.Clear_Window(SourceForm.FlowChartPictureBox)
                                    PanToWorldXYXY(SourceForm, FlowChart_TableX2(SourceForm, IndexFlowChart1),
                                                               FlowChart_TableY2(SourceForm, IndexFlowChart1),
                                                               FlowChart_TableX2(SourceForm, IndexFlowChart2),
                                                               FlowChart_TableY2(SourceForm, IndexFlowChart2))

                                End If

                            Else 'not touching so should ignore this
                                If TempD = 0 Then
                                    If MyDebug(A_ERROR) Then logA(2210, MyShowFlowChartRecord(SourceForm, False, IndexFlowChart1), MyShowFlowChartRecord(SourceForm, False, IndexFlowChart2), IndexFlowChart1.ToString, IndexFlowChart2.ToString)
                                Else
                                    If FlowChart_TablePathName(SourceForm, IndexFlowChart1) <> FlowChart_TablePathName(SourceForm, IndexFlowChart2) Then
                                        If MyDebug(A_FMB) Then
                                            If MyDebug(A_INFORMATION) Then
                                                logA(1339, IndexFlowChart1.ToString, MyShowFlowChartRecord(SourceForm, False, IndexFlowChart1), IndexFlowChart2.ToString, MyShowFlowChartRecord(SourceForm, False, IndexFlowChart2))
                                            End If
                                        End If
                                    Else
                                        logA(2209, IndexFlowChart1.ToString, FlowChart_TablePathName(SourceForm, IndexFlowChart1), IndexFlowChart2.ToString, FlowChart_TablePathName(SourceForm, IndexFlowChart2))
                                    End If
                                End If

                                Return IndexFlowChart2
                            End If
                        ElseIf Connects2 = "/raw" Then ' ignore
                        Else
                            logA(2211, MyShowFlowChartRecord(SourceForm, False, IndexFlowChart1), Connects2, IndexFlowChart1.ToString)
                        End If
                    Case "/Constant" 'todo This needs to be written
                        logA(1331, IndexFlowChart1.ToString, MyShowFlowChartRecord(SourceForm, False, IndexFlowChart1), IndexFlowChart2.ToString, MyShowFlowChartRecord(SourceForm, False, IndexFlowChart2))
                    Case "/Delete" 'ignore
                            'LogDebug(1066,err7,"##### ignore /delete " & MyShowFlowChartRecord(SourceForm, False, IndexFlowChart1) & vbTab & vbTab & MyShowFlowChartRecord(SourceForm, False, IndexFlowChart2))
                    Case "/error" 'ignore
                    Case "/unknown"
                    Case "/raw"
                        Raw2Symbol(SourceForm, IndexFlowChart1)
                        FlowChart_TableCode(SourceForm, IndexFlowChart1, "/Delete")
                        Dump2(SourceForm) 'todo remove this
                    Case Else
                        logA(1809, FlowChart_TableCode(SourceForm, IndexFlowChart2), MyShowFlowChartRecord(SourceForm, False, IndexFlowChart1), MyShowFlowChartRecord(SourceForm, False, IndexFlowChart2))
                End Select
            End If
        Next

        Return 0 ' not connected anywhere
    End Function





    'it is replacing '?' to ''0x0000''
    Friend Function MyBin2HEX(S As String) As String
        If IsNothing(S) Then
            MyBin2HEX = ""
        Else
            MyBin2HEX = S
        End If

        MyBin2HEX = MyBin2HEX.Replace(vbCrLf, "'0X000D'") 'CRLF to CR (not 202B or 2029)
        MyBin2HEX = MyBin2HEX.Replace("\", "'0X005C'") 'Backslash 
        MyBin2HEX = MyBin2HEX.Replace(Chr(34), "'0X0022'") 'Quote (0X201c and 0X201D)
        'MyBin2HEX=MyBin2HEX.Replace(vbVerticalTab, "'0X00??'")
        'MyBin2HEX=MyBin2HEX.Replace(vbFormFeed, "'0X00??'")
        MyBin2HEX = MyBin2HEX.Replace(vbLf, "'0X000D'") 'LF to CR
        MyBin2HEX = MyBin2HEX.Replace(vbCr, "'0X000D'") 'CR only to CR
        'MyBin2HEX=MyBin2HEX.Replace(vbTab, "'0X0009'") 'tab
        'MyBin2HEX=MyBin2HEX.Replace(".", "'0X002E'")
        MyBin2HEX = MyBin2HEX.Replace(ChrW(1), "'0X0001'") '0001    start heading
        MyBin2HEX = MyBin2HEX.Replace(ChrW(2), "'0X0002'") '0002    start text
        MyBin2HEX = MyBin2HEX.Replace(ChrW(3), "'0X0003'") '0003    end text
        MyBin2HEX = MyBin2HEX.Replace(ChrW(4), "'0X0004'") '0004    end transmission
        MyBin2HEX = MyBin2HEX.Replace(ChrW(5), "'0X0005'") '0005    enquiry
        MyBin2HEX = MyBin2HEX.Replace(ChrW(6), "'0X0006'") '0006    acknowledge
        MyBin2HEX = MyBin2HEX.Replace(ChrW(7), "'0X0007'") '0007    bell
        MyBin2HEX = MyBin2HEX.Replace(ChrW(8), "'0X0008'") '0008    backspace
        MyBin2HEX = MyBin2HEX.Replace(ChrW(9), "'0X0009'") '0009    horizontal table
        MyBin2HEX = MyBin2HEX.Replace(ChrW(10), "'0X000A'") '000A New line
        MyBin2HEX = MyBin2HEX.Replace(ChrW(11), "'0X000B'") '000B vertical tab
        MyBin2HEX = MyBin2HEX.Replace(ChrW(12), "'0X000C'") '000C form feed
        MyBin2HEX = MyBin2HEX.Replace(ChrW(13), "'0X000D'") '000D carriage return
        MyBin2HEX = MyBin2HEX.Replace(ChrW(14), "'0X000E'") '000E shift out
        MyBin2HEX = MyBin2HEX.Replace(ChrW(15), "'0X000F'") '000F shift in
        MyBin2HEX = MyBin2HEX.Replace(ChrW(16), "'0X0010'") '0010    data link escape
        MyBin2HEX = MyBin2HEX.Replace(ChrW(17), "'0X0011'") '0011    device control
        MyBin2HEX = MyBin2HEX.Replace(ChrW(18), "'0X0012'") '0012    device control
        MyBin2HEX = MyBin2HEX.Replace(ChrW(19), "'0X0013'") '0013    device control
        MyBin2HEX = MyBin2HEX.Replace(ChrW(20), "'0X0014'") '0014    device control
        MyBin2HEX = MyBin2HEX.Replace(ChrW(21), "'0X0015'") '0015    negative acknowledge
        MyBin2HEX = MyBin2HEX.Replace(ChrW(22), "'0X0016'") '0016    synchronous idle
        MyBin2HEX = MyBin2HEX.Replace(ChrW(23), "'0X0017'") '0017    end of transmission block
        MyBin2HEX = MyBin2HEX.Replace(ChrW(24), "'0X0018'") '0018    cancel
        MyBin2HEX = MyBin2HEX.Replace(ChrW(25), "'0X0019'") '0019    end of medium
        MyBin2HEX = MyBin2HEX.Replace(ChrW(26), "'0X001A'") '001A substitute
        MyBin2HEX = MyBin2HEX.Replace(ChrW(27), "'0X001B'") '001B escape
        MyBin2HEX = MyBin2HEX.Replace(ChrW(28), "'0X001C'") '001C file separator
        MyBin2HEX = MyBin2HEX.Replace(ChrW(29), "'0X001D'") '001D group separator
        MyBin2HEX = MyBin2HEX.Replace(ChrW(30), "'0X001E'") '001E record separator
        MyBin2HEX = MyBin2HEX.Replace(ChrW(31), "'0X001F'") '001F unit separator
        Return MyBin2HEX
    End Function

    Friend Function MyNoCR(A As String, WithWhat As String) As String
        MyNoCR = A

        While MyInStr(vbCrLf, MyNoCR) <> 0
            MyNoCR = MyNoCR.Replace(vbCrLf, WithWhat)
        End While


        While MyInStr(vbLf, MyNoCR) <> 0
            MyNoCR = MyNoCR.Replace(vbLf, WithWhat)
        End While


        While MyInStr(vbCr, MyNoCR) <> 0
            MyNoCR = MyNoCR.Replace(vbCr, WithWhat)
        End While


        'While MyInStr(vbTab & vbTab, MyNoCR) <> 0
        'MyNoCR = MyNoCR.Replace(vbTab & vbTab, ", " & vbTab)
        'End While

    End Function


    'This is used to count the number of times the routine is called, so should only have one at the top of every routine.



    'this is only used to print out what the trace is doing right now.
    Friend Function CommandLineIs() As String
        Dim RTN As String = ""

        For Each s As String In My.Application.CommandLineArgs
            If MyLeft(s, 1) = "/" Then RTN &= vbCrLf & vbTab
            RTN &= s & VBSpace 'MyUniverse.ProgramOptions.FCCL_WhiteSpace
        Next
        logA(2514, RTN)

        Return RTN
    End Function


    'This is not really used, it is to get the directory of where the default files should go (and where to get the definition files.
    Friend Sub MyTraceSystem()
        Dim I As Integer
        Return
        'directories for stuff
        Log(1067, Err6, " Current  -->" & MyUniverse.MyDir_s.Working)
        Log(3416, Err6, " System =" & Environment.SystemDirectory.ToString)
        Log(1068, Err6, " Program  -->" & MyUniverse.MyDir_s.Program)
        Log(1069, Err6, " Languages-->" & MyUniverse.MyDir_s.Languages)
        Log(1070, Err6, " Help     -->" & MyUniverse.MyDir_s.HelpFiles)
        Log(3417, Err6, " CommandLine       =" & Environment.CommandLine.ToString)
        Log(3418, Err6, " Cmd = " & Environment.CommandLine)
        Log(3419, Err6, " DirectoryPath1 =   “ & HighLight(My.Application.Info.DirectoryPath))
        Log(3420, Err6, " DirectoryPath2 =   “ & HighLight(Application.UserAppDataPath.ToString()))
        Log(3421, Err6, " FileSystem.SpecialDirectories.AllUsersApplicationData =    “ & HighLight(My.Computer.FileSystem.SpecialDirectories.AllUsersApplicationData))
        Log(3422, Err6, " FileSystem_SpecialDirectories_CurrentUserApplicationData = “ & HighLight(My.Computer.FileSystem.SpecialDirectories.CurrentUserApplicationData))
        Log(3423, Err6, " FileSystem_SpecialDirectories_Desktop =                    “ & HighLight(My.Computer.FileSystem.SpecialDirectories.Desktop))
        Log(3424, Err6, " FileSystem_SpecialDirectories_MyDocuments =                “ & HighLight(My.Computer.FileSystem.SpecialDirectories.MyDocuments))
        Log(3425, Err6, " FileSystem_SpecialDirectories_ProgramFiles =               “ & HighLight(My.Computer.FileSystem.SpecialDirectories.ProgramFiles))
        Log(3426, Err6, " Programs -->" & MyUniverse.MyDir_s.Program)
        Log(3427, Err6, " FileSystem_SpecialDirectories_Temp=                        “ & HighLight(My.Computer.FileSystem.SpecialDirectories.Temp))
        'user
        Log(1071, Err6, " UserName =  " & Environment.UserName.ToString)
        Log(1072, Err6, " Name =      “ & HighLight(My.Computer.Name))
        Log(1073, Err6, " CurrentPrincipal_Identity_Name= “ & HighLight(My.User.CurrentPrincipal.Identity.Name))
        Log(1074, Err6, " User_Name = “ & HighLight(My.User.Name))
        Log(3430, Err6, " Machine =   " & Environment.MachineName)
        Log(3431, Err6, " Domain =    " & Environment.UserDomainName)
        Log(1075, Err6, " UserDomainName=" & Environment.UserDomainName.ToString)
        Log(1076, Err6, " MachineName=" & Environment.MachineName.ToString)
        Log(3432, Err6, " UICulture_DisplayName= “ & HighLight(My.Application.UICulture.DisplayName))
        Log(3433, Err6, " UICulture_EnglishName= “ & HighLight(My.Application.UICulture.EnglishName))
        Log(1077, Err6, " UICulture_Name=“ & HighLight(My.Application.UICulture.Name))
        Log(3434, Err6, " UICulture_NativeName= “ & HighLight(My.Application.UICulture.NativeName))
        Log(3435, Err6, " UICulture_Parent_Name= “ & HighLight(My.Application.UICulture.Parent.Name))
        Log(3436, Err6, " UICulture_TwoLetterISOLanguageName= “ & HighLight(My.Computer.Mouse.WheelExists.ToString))
        Log(1078, Err6, " UICulture_ThreeLetterWindowsLanguageName= “ & HighLight(My.Application.UICulture.ThreeLetterWindowsLanguageName))


        'program
        Log(1079, Err6, " Info_AssemblyName= “ & HighLight(My.Application.Info.AssemblyName))
        Log(3437, Err6, " Info_ProductName= “ & HighLight(My.Application.Info.ProductName))
        Log(1080, Err6, " Info_Copyright= “ & HighLight(My.Application.Info.Copyright))
        Log(1081, Err6, " Info_Description= “ & HighLight(My.Application.Info.Description))
        Log(3438, Err6, " Info_Title= “ & HighLight(My.Application.Info.Title))
        Log(3439, Err6, " Info_Trademark= “ & HighLight(My.Application.Info.Trademark))
        Log(1082, Err6, " Info_Version= “ & HighLight(My.Application.Info.Version.ToString))
        Log(3440, Err6, " CurrentPrincipal_Identity_GetType_GUID= “ & HighLight(My.User.CurrentPrincipal.Identity.GetType.GUID.ToString))
        Log(3441, Err6, " WebServices_GetType_Name= “ & HighLight(My.WebServices.GetType.Name))
        Log(3442, Err6, " WebServices_GetType_AssemblyQualifiedName= “ & HighLight(My.WebServices.GetType.AssemblyQualifiedName))
        Log(1083, Err6, " WebServices_GetType_Assembly_FullName= “ & HighLight(My.WebServices.GetType.Assembly.FullName))


        'system software
        Log(1084, Err6, " Info_OSFullName= “ & HighLight(My.Computer.Info.OSFullName))
        Log(1085, Err6, " Info_OSPlatform= “ & HighLight(My.Computer.Info.OSPlatform))
        Log(1086, Err6, " Info_OSVersion= “ & HighLight(My.Computer.Info.OSVersion))
        Log(3443, Err6, " OS ver=" & Environment.OSVersion.ToString)
        Log(3444, Err6, " OSVersion   =" & Environment.OSVersion.ToString)
        Log(1087, Err6, " Version   =" & Environment.Version.ToString)
        Log(3445, Err6, " ProcessorCount   =" & Environment.ProcessorCount.ToString)
        Log(1088, Err6, " Working Set=" & Environment.WorkingSet.ToString)
        Log(3446, Err6, " CurrentManagedThreadId  =" & Environment.CurrentManagedThreadId.ToString)
        Log(3447, Err6, " ExitCode   =" & Environment.ExitCode.ToString)
        Log(3448, Err6, " HasShutdownStarted  =" & Environment.HasShutdownStarted.ToString)
        Log(3449, Err6, " 64 Bit=" & Environment.Is64BitOperatingSystem.ToString)



        'system hardware
        Log(1089, Err6, " Info_WorkingSet =              “ & HighLight(My.Application.Info.WorkingSet.ToString))
        Log(1090, Err6, " Info_AvailablePhysicalMemory = “ & HighLight(My.Computer.Info.AvailablePhysicalMemory.ToString))
        Log(1091, Err6, " Info_AvailableVirtualMemory =  “ & HighLight(My.Computer.Info.AvailableVirtualMemory.ToString))
        Log(1092, Err6, " Info_TotalPhysicalMemory =     “ & HighLight(My.Computer.Info.TotalPhysicalMemory.ToString))
        Log(1093, Err6, " Info_TotalVirtualMemory =      “ & HighLight(My.Computer.Info.TotalVirtualMemory.ToString))

        Log(1094, Err6, " Is64BitOperatingSystem =       " & Environment.Is64BitOperatingSystem.ToString)
        Log(1095, Err6, " Is64BitProcess   =" & Environment.Is64BitProcess.ToString)
        Log(3450, Err6, " NewLine   =" & Environment.NewLine.ToString)
        Log(3451, Err6, "StackTrace   =" & Environment.StackTrace.ToString)
        Log(3452, Err6, " SystemPageSize   =" & Environment.SystemPageSize.ToString)
        Log(3453, Err6, " TickCount   =" & Environment.TickCount.ToString)
        Log(3454, Err6, " UserInteractive  =" & Environment.UserInteractive.ToString)
        Log(1096, Err6, " GetLogicalDrives()=" & Environment.GetLogicalDrives.Length & COMMA & Environment.GetLogicalDrives.Count)
        For I = 0 To Environment.GetLogicalDrives.Count - 1
            Log(1097, Err6, vbTab & Environment.GetLogicalDrives(I).ToString)
        Next I
        Log(3455, Err6, " GetCommandLineArgS()=" & Environment.GetCommandLineArgs().ToString)
        Log(3456, Err6, " GetEnvironmentVariables()=" & Environment.GetEnvironmentVariables().ToString)
        Log(3400, Err6, " Mouse_WheelScrollLines= “ & HighLight(My.Computer.Mouse.WheelExists.ToString))
        Log(3401, Err6, " Mouse_WheelExists= “ & HighLight(My.Computer.Mouse.WheelExists.ToString))
        Log(3402, Err6, " Network_GetType_FullName= “ & HighLight(My.Computer.Screen.DeviceName))
        Log(3457, Err6, " Registry_CurrentUser_Name= “ & HighLight(My.Computer.Registry.CurrentUser.Name))
        Log(3456, Err6, " Registry_LocalMachine_Name= “ & HighLight(My.Computer.Registry.LocalMachine.Name))
        Log(3459, Err6, " Registry_PerformanceData_Name= “ & HighLight(My.Computer.Registry.PerformanceData.Name))
        Log(3460, Err6, " Window_DeviceName= “ & HighLight(My.Computer.Screen.DeviceName))
        Log(3403, Err6, " Window_BitsPerPixel= “ & HighLight(My.Computer.Screen.BitsPerPixel.ToString))
        Log(3404, Err6, " Window_Bounds_Size_Width= “ & HighLight(My.Computer.Screen.Bounds.Size.Width.ToString))
        Log(3405, Err6, " Window_Bounds_Size_Height= “ & HighLight(My.Computer.Screen.Bounds.Size.Height.ToString))
        Log(3406, Err6, " Window_WorkingArea_Width= “ & HighLight(My.Computer.Screen.WorkingArea.Width.ToString))
        Log(3407, Err6, " Window_WorkingArea_Height= “ & HighLight(My.Computer.Screen.WorkingArea.Height.ToString))
        Log(3461, Err6, " CurrentPrincipal_Identity_GetType_FullName= “ & HighLight(My.User.CurrentPrincipal.Identity.GetType.FullName))
        Log(3462, Err6, " WebServices_GetType_GUID= “ & HighLight(My.WebServices.GetType.GUID.ToString))
        Log(3463, Err6, " WebServices_GetType_Assembly_Location= “ & HighLight(My.WebServices.GetType.Assembly.Location))
        Log(3464, Err6, " WebServices_GetType_Namespace= “ & HighLight(My.WebServices.GetType.Namespace))
        Log(3465, Err6, " WebServices_GetType_UnderlyingSystemType_FullName= “ & HighLight(My.WebServices.GetType.UnderlyingSystemType.FullName))


        '''''MyUniverse.MyStaticData.FindIndex_In_TableNetLinks.LastIndex = -2
        '''''MyUniverse.MyStaticData.FindIndex_In_TableNetLinks.LastFound = -2
        '''''MyUniverse.MyStaticData.FindIndex_In_TableNetLinks.LastPathName = "xyzzy"

        '''''MyUniverse.MyStaticData.MyEnum.LastWhatString = MyConstantIgnoreFunctionOperatorKeyWord
        '''''MyUniverse.MyStaticData.MyEnum.LastComboBox = MyConstantIgnoreFunctionOperatorKeyWord
        '''''MyUniverse.MyStaticData.MyEnum.Last_Enum = -1
        '''''MyUniverse.MyStaticData.MyUnEnum.LastWhatString = MyConstantIgnoreFunctionOperatorKeyWord
        '''''MyUniverse.MyStaticData.MyUnEnum.LastComboBox = MyConstantIgnoreFunctionOperatorKeyWord
        '''''MyUniverse.MyStaticData.MyUnEnum.LastUnEnum = MyConstantIgnoreFunctionOperatorKeyWord
    End Sub





    'Part of finding internal bugs that I think should never happen (See )
    Friend Function FindingSymbolOutOfXYSizeBugs(IndexSymbol As Integer) As Integer ' Checks Symbol record indexSymbol if it is more then the allowed size.(if /point or /Line))
        Dim NumberOfNames, NumberOfPoints, NumberOfLines As Integer
        FindingSymbolOutOfXYSizeBugs = 0

        NumberOfNames = 0
        NumberOfPoints = 0
        NumberOfLines = 0
        Select Case LCase(Symbol_TableCoded_String(IndexSymbol))
            Case "/name"
                NumberOfNames += 1
            Case "/Line"
                If MyABS(Symbol_FileX1(IndexSymbol)) > MyUniverse.SysGen.Constants.ConstantSymbolCenter Then
                    FindingSymbolOutOfXYSizeBugs += logA(1830, IndexSymbol.ToString, Symbol_FileX1(IndexSymbol).ToString)
                    If MyDebug(A_NOTICE) Then logA(2519)
                End If
                If MyABS(Symbol_FileY1(IndexSymbol)) > MyUniverse.SysGen.Constants.ConstantSymbolCenter Then
                    FindingSymbolOutOfXYSizeBugs += logA(1831, IndexSymbol.ToString, Symbol_FileY1(IndexSymbol).ToString)
                    If MyDebug(A_NOTICE) Then logA(2520)
                End If
                If MyABS(Symbol_FileX2_io(IndexSymbol).MyNumber) > MyUniverse.SysGen.Constants.ConstantSymbolCenter Then
                    FindingSymbolOutOfXYSizeBugs += logA(1832, IndexSymbol.ToString, Symbol_FileX2_io(IndexSymbol).ToString)
                    If MyDebug(A_NOTICE) Then logA(2521)
                End If
                If MyABS(Symbol_FileY2_dt(IndexSymbol).MyNumber) > MyUniverse.SysGen.Constants.ConstantSymbolCenter Then
                    FindingSymbolOutOfXYSizeBugs += logA(1833, IndexSymbol.ToString, Symbol_FileY2_dt(IndexSymbol).ToString)
                    If MyDebug(A_DISPLAY) Then logA(2522)
                End If
                    ' removed not needed ?NumberOfLines += 1
            Case "/point"
                If MyABS(Symbol_FileX1(IndexSymbol)) > MyUniverse.SysGen.Constants.ConstantSymbolCenter Then
                    FindingSymbolOutOfXYSizeBugs += logA(1834, IndexSymbol.ToString, Symbol_FileX1(IndexSymbol).ToString)
                    If MyDebug(A_DISPLAY) Then logA(2523)
                End If
                If MyABS(Symbol_FileY1(IndexSymbol)) > MyUniverse.SysGen.Constants.ConstantSymbolCenter Then
                    FindingSymbolOutOfXYSizeBugs += logA(1835, IndexSymbol.ToString, Symbol_FileY1(IndexSymbol).ToString)
                    If MyDebug(A_DISPLAY) Then logA(2524)
                End If
                    ' removed not needed ?NumberOfPoints += 1
            Case "/unknown"
                logA(1836, MyShowSymbolGraphic(True, IndexSymbol), Symbol_TableCoded_String(IndexSymbol))
            Case Else
                FindingSymbolOutOfXYSizeBugs += logA(1837, Symbol_TableCoded_String(IndexSymbol), Symbol_TableCoded_String(IndexSymbol))
        End Select
        If FindingSymbolOutOfXYSizeBugs > 0 Then
            logA(2317, Symbol_TableSymbolName(IndexSymbol), FindingSymbolOutOfXYSizeBugs.ToString, NumberOfLines.ToString, NumberOfNames.ToString, NumberOfPoints.ToString, NumberOfLines.ToString)
        End If
        Return FindingSymbolOutOfXYSizeBugs
    End Function



    Friend Function MyOptionTest(WhatOption As Integer) As Boolean
        If WhatOption = 0 Then Return True

        If WhatOption > Options.CheckedListBoxFlowChartOptions.Items.Count Then
            Return False
        End If

        If WhatOption = 61 Then Return Options.CheckedListBoxFlowChartOptions.GetItemChecked(WhatOption)


        If ProgramBuzzy("Begin") Then Return False
        If ProgramBuzzy("dead") Then Return False
        If WhatOption > Options.CheckedListBoxFlowChartOptions.Items.Count Then
            logA(1073, WhatOption.ToString, Options.CheckedListBoxFlowChartOptions.Items.Count.ToString)
            Return False
        Else
            Return Options.CheckedListBoxFlowChartOptions.GetItemChecked(WhatOption)
        End If
    End Function

    'Outputs everything into a dump file
    Friend Sub Dump2(ByRef SourceForm As Source)
        Export(SourceForm, True, MyUniverse.MySystem.Dumps.OutputFileName2)
    End Sub 'dump2



    'This is writing out Lines of what is happening, so that when (not if) it dies, you can see where it died at.
    Friend Sub Dump3(BugNumber As Integer, ErrorMessage As String) ' Dump every possible issues to a saved file 
        If MyDebug(A_WARNING) Or MyOptionTest(30) = True Then
            logA(BugNumber, ErrorMessage)
        End If
        DoEvent(72, "Dump3")
    End Sub 'dump3




    '
    'todo need to add the button rules here
    'This is to clear the message text 
    Friend Function ButtonStarted(ButtonName As String) As Boolean ' Make sure that no more than X number of buttons deep (or stack over flow)
        If MyUniverse.SysGen.NumberOfButtonsActive > 88 Then
            logA(2915, "PROGRAM ERROR ", "To Many Buttons ", ButtonName)
            Return False ' can not do any more buttons
        End If
        MyUniverse.SysGen.NumberOfButtonsActive += 1
        Return True
    End Function 'Button Started

    Friend Function ButtonFinished(ButtonName As String) As Boolean  ' Make sure that no more than X number of buttons deep (or stack over flow)
        If MyDebug(A_FMB) Then
            logA(2533, ButtonName)
        End If
        MyUniverse.SysGen.NumberOfButtonsActive -= 1
        If MyUniverse.SysGen.NumberOfButtonsActive < 0 Then
            MsgBox(Translate("Unknown Error Type"), MsgBoxStyle.OkOnly)
        End If
        'reset all button rules if all turned off
        'MyButtonsEnableRules(117)
        Return True ' toto for now All finished buttons worked and stopped
    End Function

    Friend Sub ClearSymbolDisplay() 'used to display nothing (over the status messages
        If MyDebug(A_FMB) Then logA(2534)
        MyUniverse.ProgramOptions.SymbolChanged = False ' Nothing has change from nothing
        Library.TextBoxNamedSymbolName.Text = ""
        'Library.TextBoxNamedDescription.Text=""
        '''''Library.TextBoxNamedNameOfFile.Text = ""
        Library.TextBoxNamedNotes.Text = ""
        Library.TextBoxNamedOpCode.Text = ""
        Library.TextBoxNamedStroke.Text = ""
        Library.TextBoxNamedSyntax.Text = ""
        Library.TextBoxSymbolName.Text = ""
        Library.TextBoxSymbolVersionAuthor.Text = ""
    End Sub

    Friend Sub DisplaySymbolText(ByRef SourceForm As Source, SymbolName As String)
        Dim IndexNamed, IndexSymbol As Integer

        If MyDebug(A_FMB) Then logA(2535, SymbolName)
        IndexNamed = BinarySearch4Index(Options.ListBoxSymbols, SymbolName)
        If IndexNamed = ConstantMyErrorCode Then
            logA(1846, SymbolName)
            ClearSymbolDisplay()
        End If
        IndexSymbol = CorrectingIndexes(SourceForm, SymbolName)
        If IndexSymbol = ConstantMyErrorCode Then
            logA(1847)
            ClearSymbolDisplay()
        End If
        If Named_TableSymbolName(IndexNamed) <> SymbolName Then
            logA(1848, SymbolName, Named_TableSymbolName(IndexNamed))
        End If

        Library.TextBoxNamedSymbolName.Text = Named_TableSymbolName(IndexNamed)
        '''''Library.TextBoxNamedNameOfFile.Text = Named_TableNameOfFile(IndexNamed)
        Library.TextBoxNamedNotes.Text = Named_TableNotes(IndexNamed)
        Library.TextBoxNamedOpCode.Text = Named_TableOpCode(IndexNamed)
        Library.TextBoxNamedStroke.Text = Named_TableStroke(IndexNamed)
        Library.TextBoxNamedSyntax.Text = Named_TableSyntax(IndexNamed)
        Library.TextBoxSymbolName.Text = Named_TableMicroCodeText(IndexNamed)
        Library.TextBoxSymbolVersionAuthor.Text = Named_TableAuthor(IndexNamed)
        'todo need to check that the name is matching.
        IndexSymbol += 1 'jump after the name
        Library.ListBoxLineColor.Items.Clear()
        Library.ListBoxPointNameList.Items.Clear()

        While Symbol_TableCoded_String(IndexSymbol) <> "/Name" And IndexSymbol <= TopOfFile(SourceForm, "Symbol")
            Select Case LCase(Symbol_TableCoded_String(IndexSymbol))
                Case "/name"

                    Return
                Case "/point" ' Add to point list
                    '''''  FixSyxtaxCode(IndexNamed)
                    AddPointNameToDropDownX(SourceForm, Symbol_Table_NameOfPoint(IndexSymbol) + FD + MyShowNamedAndSymbolRecords(SourceForm, True, IndexSymbol))
                Case "/Line" ' Add to Line list
                    AddLineNameToDropDown(Symbol_Table_NameOfPoint(IndexSymbol))
                Case Else
                    logA(2092, Symbol_TableCoded_String(IndexSymbol))
            End Select
            IndexSymbol += 1
        End While
    End Sub




    ' This will highlight the button that is the current mode.
    Friend Sub MySetToolStripHighlight(a As ToolStripButton, Cmd As String)
        If MyUniverse.SysGen.Constants.MyCmdModeString = Cmd Then
            a.BackColor = SystemColors.Highlight
        Else
            a.BackColor = SystemColors.Control
        End If
        'DoEvent(73, "Highlight " & a.Name & vbTab & Cmd)
    End Sub


    Friend Sub MyButtonsEnableRules(TraceNumber As Integer) : End Sub


    'need to also put in something to test the available memory left 
    Friend Function FMBRecurse(routine As String) As Integer ' counts the number of subroutines deep
        'log_X(1053,"Recursive " & routine & COMMA & Len(My.Application.Info.StackTrace).ToString)
        Return CInt(Len(My.Application.Info.StackTrace) / 1000)
        ' DIM   startAt, Counter, Last1, Last2 As Integer
        'Counter = 0
        'startAt = 1


        'While startAt <> 0
        ' Counter += 1
        ' Last2 = Last1
        ' Last1 = Counter
        ' startAt += 1
        ' startAt = MyInStr(routine, My.Application.Info.StackTrace, startAt)
        ' End While

        'LogA(1050,"Recursive " & routine & COMMA & Len(My.Application.Info.StackTrace).ToString & vbTab & vbTab & Counter.ToString)
        ' Return Counter
    End Function

    Friend Function CountStackI(debugLevel As Integer) As Integer
        Dim Counter, KCounter As Integer

        Counter = 1
        KCounter = 0

        While Counter <> 0
            Counter += 1
            KCounter += 1
            Counter = InStr(Counter, My.Application.Info.StackTrace, vbCrLf)
        End While


        Return KCounter
    End Function 'CountStack()

    ''' <summary>
    ''' 
    ''' </summary>
    ''' <param name="MyFormat"></param>
    ''' <param name="Key"></param>
    ''' <param name="Data"></param>
    ''' <returns></returns>
    Friend Function ChangeFormat(MyFormat As String, Key As String, Data As String) As String
        Dim MyArray1(0), myarray2(0) As String
        Dim I As Integer
        Dim R1, R2 As String
        MyParse(MyArray1, MyFormat)
        MyParse(myarray2, "/what=" & Data)
        For I = 1 To MyMin(MySizeOf(MyArray1), MySizeOf(myarray2))
            If Len(MyArray1(I)) > 0 Then R1 = "Y" Else R1 = "N"
            If Len(myarray2(I)) > 0 Then R2 = "Y" Else R2 = "N"
            Select Case R1 & R2
                Case "YY"
                    LogDebug(3491, Err7, I.ToString & vbTab & vbTab & MyArray1(I) & "---" & myarray2(I) & "-->" & R1 & R2)
                Case "NN"
                    'LogDebug(3492,err7,I.ToString & vbTab & vbTab & MyArray1(I) & "---" & myarray2(I) & "-->" & R1 & R2)
                    Return Data
                        '*** if one is blank then there is not the correct number of items parsed.
                Case "YN"
                    LogDebug(3493, Err7, I.ToString & vbTab & vbTab & MyArray1(I) & "---" & myarray2(I) & "-->" & R1 & R2)
                Case "NY"
                    LogDebug(3494, Err7, I.ToString & vbTab & vbTab & MyArray1(I) & "---" & myarray2(I) & "-->" & R1 & R2)
                Case Else
                    LogDebug(3495, Err7, I.ToString & vbTab & vbTab & MyArray1(I) & "---" & myarray2(I) & "-->" & R1 & R2)
            End Select
        Next

        'todo needs to make sure the correct number of items in input

        Return Data
    End Function






    'You ask why are you doing this instead of just a if a=b then
    ''well I DoNot have an answer for you ( I guess that I just like to pop things to the stack
    ' (Except that it is easier to put a break point at the return false part to catch this issue
    Friend Function IsTheDropDownText_TheSameAs_TheSelectedText(FixIt As Boolean, ByRef A As String, B As ListBox) As Boolean
        If A = B.Text Then Return True
#If DEBUGMODE Then
           LogA(2572, "Is The Drop Down Text The Same As Selected Text " & A & " <<--->>  " & B.Text)
#End If
        If FixIt = True Then 'so that I can use this in finding my bugs, (with out changing anything)
            If MyIsNothing(B.Text) Then
                logA(1984, A.ToString, B.Text)
                SelectInToolStripDropDownButton(B, A)
                Return True 'cause it is equal now.
            Else
                If MyIsNothing(A) Then
                    logA(1985, A.ToString, B.Text)
                    A = B.Text
                    Return True
                End If
            End If
        Else
            If MyOptionTest(25) = True Then
                If MyDebug(A_INFORMATION) Then logA(1986, A.ToString, B.Text, B.Name)
                B.Text = A
                Return True
            Else
                If MyDebug(A_INFORMATION) Then logA(1986, A.ToString, B.Text, B.Name)
                B.Text = A
                Return True
            End If
        End If
        Return False
    End Function


    Friend Function GetMarker(WhichOne As Integer, FromWhat As String) As String
        Dim I, J, K As Integer
        J = MyInStr(MyUniverse.SysGen.Constants.RMStart, FromWhat)
        If J = 0 Then Return ""
        For I = 1 To WhichOne
            J = MyInStr(MyUniverse.SysGen.Constants.RMStart, FromWhat)
            If J = 0 Then Return ""
        Next
        K = MyInStr(MyUniverse.SysGen.Constants.RMEnd, FromWhat, J)
        If MyDebug(A_DISPLAY) Then logA(1249, Mid(FromWhat, J, K - J + Len(MyUniverse.SysGen.Constants.RMEnd)))
        Return Mid(FromWhat, J, K - J + Len(MyUniverse.SysGen.Constants.RMEnd))
    End Function

    Friend Function MyConstant(Marker As String) As String
        If MyLeft(Marker, 2) = MyUniverse.SysGen.Constants.RMStart & "'" And MyRight(Marker, 2) = "'" & MyUniverse.SysGen.Constants.RMEnd Then
            Return Mid(Marker, 3, Len(Marker) - 4)
        Else
            Return Marker
        End If
    End Function




    Friend Function CompileThisSymbol(ByRef SourceForm As Source, IndexFlowChart As Integer) As String
        Dim Symbol, Value As String
        Dim MyConnectionsToMyCode As String
        Dim Marker1, Marker2, Marker3, Switch1, Switch2 As String
        Dim IndexNamed As Integer
        Dim IndexSymbol As Integer
        Dim StartAt, EndAt, ValueAt As Integer
        ' DIM   NumberOfPoints As Integer
        Dim MyFlag As String
        Dim debug1 As String
        logA(1638, MyShowFlowChartRecord(SourceForm, False, IndexFlowChart))
        CompileThisSymbol = ""
        'First check that every marker in the syntax has an attribute defined in the graphics to text source code
        If FlowChart_TableCode(SourceForm, IndexFlowChart) <> "/use" Then
            If MyDebug(A_WARNING) Then
                logA(1288, MyShowFlowChartRecord(SourceForm, False, IndexFlowChart))
                Return MyShowFlowChartRecord(SourceForm, False, IndexFlowChart)
            End If
        End If
        Symbol = FlowChart_TableSymbol_Name(SourceForm, IndexFlowChart)
        IndexNamed = FindInNamedList(Symbol)
        logA(1639, MyShowNamedRecord(False, IndexNamed))
        IndexSymbol = Named_FileSymbolIndexes(IndexNamed)
        logA(1640, MyShowNamedAndSymbolRecords(SourceForm, False, IndexSymbol))
        If IndexNamed < 1 Then
            Return CompileThisSymbol
        End If
        CompileThisSymbol = Named_TableSyntax(IndexNamed) ' Named_TableMicroCodeText(IndexNamed)
        If MyDebug(A_DISPLAY) Then logA(1591, MyShowNamedRecord(False, IndexNamed))
        MyConnectionsToMyCode = MyShowAndUpDateProperties(SourceForm, IndexFlowChart)


        While 1 = 1
            logA(1068, CompileThisSymbol, MyShowFlowChartRecord(SourceForm, False, IndexFlowChart))
            Marker1 = GetMarker(0, VBSpace & CompileThisSymbol)
            Value = NoRM(Marker1)
            If Marker1 = "" Then
                Exit While
            End If
            Switch1 = "/" & NoRM(Marker1)
            Marker2 = Marker1
            Marker3 = Pop_Attribute(Marker2)
            If MyInStr(".", Marker1) <> 0 Then
                Switch2 = Pop_What(SourceForm, NoRM(Marker1))
                If MyInStr(".", Switch2) <> 0 Then
                    Switch2 = Mid(Switch2, 1, MyInStr(".", Switch2) - 1)
                Else
                    Switch2 = Marker1
                End If
            Else
                Switch2 = ""
            End If
            logA(1069, Marker1, Marker2, Marker3, Switch1, Switch2, Value, CompileThisSymbol)
            StartAt = MyInStr(Switch1, MyConnectionsToMyCode)
            If StartAt = 0 Then
                StartAt = MyInStr("/" & NoRM(Marker1), MyConnectionsToMyCode)
            End If
            If StartAt = 0 Then
                StartAt = MyInStr("/" & Switch2, MyConnectionsToMyCode)
            End If
            MyFlag = NoRM(Mid(Marker1, MyInStr(".", Marker1) + 1))

            If StartAt > 0 Then
                ValueAt = MyInStr("=", MyConnectionsToMyCode & "=", StartAt + 1) + 1
                EndAt = MyInStr("/", MyConnectionsToMyCode & "/", StartAt + 1)
                Value = MyTrim(Mid(MyConnectionsToMyCode, ValueAt, EndAt - ValueAt))
                logA(1259, Marker1, Switch1, Mid(MyConnectionsToMyCode, StartAt, EndAt - StartAt), Value)
            ElseIf MyLeft(NoRM(Marker1), 7) = "keyword" And MyInStr(".", Marker1) <> 0 Then
                ValueAt = MyInStr(".", Marker1)
                If ValueAt <> 0 Then
                    Value = Mid(Marker1, ValueAt + 1)
                    Value = MyTrim(NoRM(Value))
                End If
            Else
                Value = "ERROR "
                If MyOptionTest(25) = True Then
                Else
                End If
            End If
            debug1 = CompileThisSymbol
            logA(1682, Marker1, Value)
            CompileThisSymbol = MyReplace(CompileThisSymbol, Marker1, Value)
            'If MyDebug(A_DISPLAY) Then
            If debug1 <> CompileThisSymbol Then
                logA(1254, debug1, CompileThisSymbol)
            End If
            logA(1256, IndexFlowChart.ToString, CompileThisSymbol, MyShowFlowChartRecord(SourceForm, False, IndexFlowChart))
        End While

        CompileThisSymbol = Strings.Replace(CompileThisSymbol, FD, MyUniverse.ProgramOptions.FCCL_WhiteSpace, 1, -1, CompareMethod.Text)
        Return CompileThisSymbol
    End Function

    'Is there a path from A to B?

    Friend Function ROUTERCheckLinesEndAtEachOther(ByRef SourceForm As Source, XY1 As MyLineStructure, XY2 As MyLineStructure) As MyPointStructure

        logA(2345, "Router Check Lines End At Each Other  ", MyShow2Lines(XY1, XY2))
        If MyDebug(A_DEBUG) Then
            logA(2580, MyShow2Lines(XY1, XY2))
        End If
        MyDrawWorldPath(SourceForm, XY1, "debugging")
        MyDrawWorldPath(SourceForm, XY2, "debugging")
        MyDrawWorldPaths(SourceForm, XY1, XY2)

        If XY1.a.x = XY2.a.x Then
            If XY1.a.y = XY2.a.y Then
                Return MyPoint1XY(XY1.a.x, XY1.a.y)
            End If
        End If
        If XY1.a.x = XY2.b.x Then
            If XY1.a.y = XY2.b.y Then
                Return MyPoint1XY(XY1.a.x, XY1.a.y)
            End If
        End If
        If XY1.b.x = XY2.a.x Then
            If XY1.b.y = XY2.a.y Then
                Return MyPoint1XY(XY1.b.x, XY1.b.y)
            End If
        End If
        If XY1.b.x = XY2.b.x Then
            If XY1.b.y = XY2.b.y Then
                Return MyPoint1XY(XY1.b.x, XY1.b.y)
            End If
        End If

        Return MyUniverse.MyStaticData.ZeroZero
    End Function ' returns what point connects these two lines



    'This is to replace the error messages with what ever text.
    'MyErrorMessages(True, 1009, "Information", "Compile Finished to file>" & TS & "string1" & TE & "< ")
    '/FCCL_ErrorMessage=True, 1009, "Information", "UpTo9Strings to be replaced " & TS & "string1" & TE & "< ")


    Friend Function MyCompareSyntax_S(String1 As String, String2 As String) As String
        If MyStrComp(String1, String2) = 0 Then Return "equal"
        Return "notEqual"
    End Function



    Friend Sub WhatKey(ByRef SourceForm As Source, e As KeyPressEventArgs)
        Dim MyText As String
        If MyDebug(A_STATUS) Then logA(2584, e.KeyChar.ToString)
        MyText = OLD.INPUTTEXTBOX & e.KeyChar.ToString
        'characters I might have to take care of
        'vbHiragana, vbKatakana, vbLinguisticCasing, vbNarrow vbNewLine, vbSimplifiedChinese, vbTraditionalChinese, vbWide
        Select Case e.KeyChar.ToString
            Case "(", ")", "{", "}", "[", "]"
                MyShowSyntax(SourceForm, MyText)
                Return
            Case "= ", " + ", " - ", " / ", " * ", " '"
                MyShowSyntax(SourceForm, MyText)
                Return
            Case "!", "@", "#", "$", "%", "^", "&", "_", "~"
                MyShowSyntax(SourceForm, MyText)
                Return
            Case "|", "\", ",", ".", "?"
                MyShowSyntax(SourceForm, MyText)
                Return
            Case MyUniverse.ProgramOptions.FCCL_WhiteSpace
                MyShowSyntax(SourceForm, MyText)
                Return
            Case "0", "1", "2", "3", "4", "5", "6", "7", "8", "9" 'digits
                MyShowSyntax(SourceForm, MyText)
                Return

    '=96-105
            Case Keys.NumPad0.ToString, Keys.NumPad1.ToString, Keys.NumPad2.ToString, Keys.NumPad3.ToString, Keys.NumPad4.ToString, Keys.NumPad5.ToString, Keys.NumPad6.ToString, Keys.NumPad7.ToString, Keys.NumPad8.ToString, Keys.NumPad9.ToString
                MyShowSyntax(SourceForm, MyText)
                Return
            Case "a", "b", "c", "d", "e", "f", "g", "g", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z"
                MyShowSyntax(SourceForm, MyText)
                Return
    'It returns caps when in quotes.'capital letters never show up i guess cause the select statement test against lower case?
            Case "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"
                Return
            Case vbCr, vbCrLf, vbLf, vbTab, vbFormFeed, Chr(34)
                Return
            Case vbBack, ChrW(1).ToString 'DELETE CHARACTER
                Return
            Case Keys.Add.ToString '  = 107
                Return
    'Case Keys.D0.ToString '  = 48
    'Case Keys.D1.ToString '  = 49
    'Case Keys.D2.ToString '  = 50
    'Case Keys.D3.ToString '  = 51
    'Case Keys.D4.ToString '  = 52
    'Case Keys.D5.ToString '  = 53
    'Case Keys.D6.ToString '  = 54
    'Case Keys.D7.ToString '  = 55
    'Case Keys.D8.ToString '  = 56
    'Case Keys.D9.ToString '  = 57
            Case Keys.MButton.ToString '  = 4
            Case Keys.XButton1.ToString '  = 5
            Case Keys.XButton2.ToString '  = 6
            Case Keys.Back.ToString '  = 8
            Case Keys.Tab.ToString '  = 9
            Case Keys.LineFeed.ToString '  = 10
            Case Keys.Clear.ToString '  = 12
            Case Keys.[Return].ToString '  = 13
            Case Keys.Enter.ToString '  = 13
            Case Keys.ShiftKey.ToString '  = 16
            Case Keys.ControlKey.ToString '  = 17
            Case Keys.Menu.ToString '  = 18
            Case Keys.Pause.ToString '  = 19
            Case Keys.Capital.ToString '  = 20
            Case Keys.CapsLock.ToString '  = 20
            Case Keys.KanaMode.ToString '  = 21
            Case Keys.HanguelMode.ToString '  = 22  
            Case Keys.JunjaMode.ToString '  = 23
            Case Keys.FinalMode.ToString '  = 24
            Case Keys.HanjaMode.ToString '  = 25
            Case Keys.KanjiMode.ToString '  = 25
            Case Keys.Escape.ToString '  = 27
            Case Keys.IMEConvert.ToString '  = 28
            Case Keys.IMENonconvert.ToString '  = 29
            Case Keys.IMEAccept.ToString '  = 30
            Case Keys.IMEModeChange.ToString '  = 31
            Case Keys.Prior.ToString '  = 33
            Case Keys.PageUp.ToString '  = 33
            Case Keys.[Next].ToString '  = 34
            Case Keys.PageDown.ToString '  = 34
            Case Keys.[End].ToString '  = 35
            Case Keys.Home.ToString '  = 36
            Case Keys.Left.ToString '  = 37
            Case Keys.Up.ToString '  = 38
            Case Keys.Right.ToString '  = 39
            Case Keys.Down.ToString '  = 40
            Case Keys.[Select].ToString '  = 41
            Case Keys.Print.ToString '  = 42
            Case Keys.Execute.ToString '  = 43
            Case Keys.Snapshot.ToString '  = 44
            Case Keys.PrintScreen.ToString '  = 44
            Case Keys.Insert.ToString '  = 45
            Case Keys.Delete.ToString '  = 46
            Case Keys.Help.ToString '  = 47
            Case Keys.LWin.ToString '  = 91' Left Windows Key
            Case Keys.RWin.ToString '  = 92'Right Windows key (Which doesn't exist)
            Case Keys.Apps.ToString '  = 93'This is the right mouse help button   ?
            Case Keys.Sleep.ToString '  = 95
            Case Keys.Multiply.ToString '  = 106
            Case Keys.Separator.ToString '  = 108
            Case Keys.Subtract.ToString '  = 109
            Case Keys.[Decimal].ToString '  = 110
            Case Keys.Divide.ToString '  = 111
            Case Keys.F1.ToString '  = 112
            Case Keys.F2.ToString '  = 113
            Case Keys.F3.ToString '  = 114
            Case Keys.F4.ToString '  = 115
            Case Keys.F5.ToString '  = 116
            Case Keys.F6.ToString '  = 117
            Case Keys.F7.ToString '  = 118
            Case Keys.F8.ToString '  = 119
            Case Keys.F9.ToString '  = 120
            Case Keys.F10.ToString '  = 121
            Case Keys.F11.ToString '  = 122
            Case Keys.F12.ToString '  = 123
            Case Keys.F13.ToString '  = 124
            Case Keys.F14.ToString '  = 125
            Case Keys.F15.ToString '  = 126
            Case Keys.F16.ToString '  = 127
            Case Keys.F17.ToString '  = 128
            Case Keys.F18.ToString '  = 129
            Case Keys.F19.ToString '  = 130
            Case Keys.F20.ToString '  = 131
            Case Keys.F21.ToString '  = 132
            Case Keys.F22.ToString '  = 133
            Case Keys.F23.ToString '  = 134
            Case Keys.F24.ToString '  = 135
            Case Keys.NumLock.ToString '  = 144
            Case Keys.Scroll.ToString '  = 145
            Case Keys.LShiftKey.ToString '  = 160
            Case Keys.RShiftKey.ToString '  = 161
            Case Keys.LControlKey.ToString '  = 162
            Case Keys.RControlKey.ToString '  = 163
            Case Keys.LMenu.ToString '  = 164
            Case Keys.RMenu.ToString '  = 165
            Case Keys.BrowserBack.ToString '  = 166
            Case Keys.BrowserForward.ToString '  = 167
            Case Keys.BrowserRefresh.ToString '  = 168
            Case Keys.BrowserStop.ToString '  = 169
            Case Keys.BrowserSearch.ToString '  = 170
            Case Keys.BrowserFavorites.ToString '  = 171
            Case Keys.BrowserHome.ToString '  = 172
            Case Keys.VolumeMute.ToString '  = 173
            Case Keys.VolumeDown.ToString '  = 174
            Case Keys.VolumeUp.ToString '  = 175
            Case Keys.MediaNextTrack.ToString '  = 176
            Case Keys.MediaPreviousTrack.ToString '  = 177
            Case Keys.MediaStop.ToString '  = 178
            Case Keys.MediaPlayPause.ToString '  = 179
            Case Keys.LaunchMail.ToString '  = 180
            Case Keys.SelectMedia.ToString '  = 181
            Case Keys.LaunchApplication1.ToString '  = 182
            Case Keys.LaunchApplication2.ToString '  = 183
            Case Keys.OemSemicolon.ToString '  = 186
            Case Keys.Oem1.ToString '  = 186
            Case Keys.Oemplus.ToString '  = 187
            Case Keys.Oemcomma.ToString '  = 188
            Case Keys.OemMinus.ToString '  = 189
            Case Keys.OemPeriod.ToString '  = 190
            Case Keys.OemQuestion.ToString '  = 191
            Case Keys.Oem2.ToString '  = 191
            Case Keys.Oemtilde.ToString '  = 192
            Case Keys.Oem3.ToString '  = 192
            Case Keys.OemOpenBrackets.ToString '  = 219
            Case Keys.Oem4.ToString '  = 219
            Case Keys.OemPipe.ToString '  = 220
            Case Keys.Oem5.ToString '  = 220
            Case Keys.OemCloseBrackets.ToString '  = 221
            Case Keys.Oem6.ToString '  = 221
            Case Keys.OemQuotes.ToString '  = 222
            Case Keys.Oem7.ToString '  = 222
            Case Keys.Oem8.ToString '  = 223
            Case Keys.OemBackslash.ToString '  = 226
            Case Keys.Oem102.ToString '  = 226
            Case Keys.ProcessKey.ToString '  = 229
            Case Keys.Packet.ToString '  = 231
            Case Keys.Attn.ToString '  = 246
            Case Keys.Crsel.ToString '  = 247
            Case Keys.Exsel.ToString '  = 248
            Case Keys.EraseEof.ToString '  = 249
            Case Keys.Play.ToString '  = 250
            Case Keys.Zoom.ToString '  = 251
            Case Keys.NoName.ToString '  = 252
            Case Keys.Pa1.ToString '  = 253
            Case Keys.OemClear.ToString '  = 254
            Case Keys.KeyCode.ToString '  = 65535
            Case Keys.Shift.ToString '  = 65536
            Case Keys.Control.ToString '  = 131072
            Case Keys.Alt.ToString '  = 262144
            Case Else
                logA(2085, e.GetType.FullName, e.GetType.Attributes.ToString, e.KeyChar, e.KeyChar.ToString)
        End Select
        If MyDebug(A_INFORMATION) Then logA(2086, e.GetType.FullName, e.GetType.Attributes.ToString, e.KeyChar, e.KeyChar.ToString)
    End Sub



    Friend Sub MyShowSyntax(ByRef SourceForm As Source, MySyntax As String) ' Extra
        MyUniverse.MyStaticData.Path_Names = MyParse(MyUniverse.MyStaticData.My_Syntax_Line_Parsed, OLD.INPUTTEXTBOX)
        MyUniverse.MyStaticData.Path_NamesCounted = CountPathNames(SourceForm, MyUniverse.MyStaticData.Path_Names)
    End Sub

    Friend Function MyShell(Temp As String) As Integer
        Dim DevicePathFileName As String

        If MyDebug(A_FMB) Then logA(2586, Temp)
        MyShell = 0
        DoEvent(79, "Shell Out")
        DevicePathFileName = Temp
        If Dir(DevicePathFileName) <> "" Then
            Return Shell(DevicePathFileName, AppWinStyle.MaximizedFocus,)
        End If

        Select Case MsgBox(Translate("Unable to find program") & VBSpace & Temp & VBSpace & Translate("Search for it?"), MsgBoxStyle.YesNo Or MsgBoxStyle.Information, Translate("Attempting to start computer program"))
            Case MsgBoxResult.Abort, MsgBoxResult.Cancel, MsgBoxResult.Ignore, MsgBoxResult.No, MsgBoxResult.Retry
            Case MsgBoxResult.Yes, MsgBoxResult.Ok
                'search for temp
                DevicePathFileName = FindFileName(Temp)
                If DevicePathFileName <> "" Then
                    If Dir(DevicePathFileName) <> "" Then
                        Return Shell(DevicePathFileName, AppWinStyle.MinimizedNoFocus, True, 1000)
                    End If
                End If
                MsgBox(Translate("Unable to start program") & VBSpace & DevicePathFileName)
            Case Else
                logA(1906)
        End Select
        'need to go find this 

        DevicePathFileName = "\" & Mid(Temp, 2, Len(Temp)) & Temp & "\" & Temp
        If Dir(DevicePathFileName) <> "" Then Return Shell(DevicePathFileName, AppWinStyle.MinimizedNoFocus, True, 1000)
        DevicePathFileName = MyUniverse.MyDir_s.Program & "\" & Temp
        If Dir(DevicePathFileName) <> "" Then Return Shell(DevicePathFileName, AppWinStyle.MinimizedNoFocus, True, 1000)

    End Function

    Friend Function FileIgnoreList(PathName As String) As Boolean
        'todo need to add all of the other places they shouldn't be going
        If MyInStr("$", PathName) <> 0 Then Return True
        If PathName = "\Recovery\" Then Return True
        If PathName = "\Support\" Then Return True
        If PathName = "\System Volume Information\" Then Return True
        If PathName = "\Windows\" Then Return True
        If PathName = "\AppData\" Then Return True
        'If PathName="\\" Then Return True
        Return False
    End Function


    Friend Function FindFileName(PathFileExt As String) As String
        Dim DevicePathFile As String
        Dim MyCurrentPath(1), MyPath, MyFileName, MyExtension As String
        Dim WhereIsFile As String
        Dim MyCurrent As Integer

        DevicePathFile = PathFileExt
        OLD.DisplayStatus(3249, PathFileExt)
        If DevicePathFile = "" Then Return ""
        If MyLeft(DevicePathFile, 2) = "\\" Then
            DevicePathFile = Mid(DevicePathFile, 2, Len(DevicePathFile))
        End If

        If Dir(DevicePathFile) <> "" Then 'Found it
            Return Dir(DevicePathFile)
        End If

        MyPath = Path.GetDirectoryName(DevicePathFile)
        If MyRight(MyPath, 1) <> "\" Then MyPath &= "\"
        MyFileName = Path.GetFileNameWithoutExtension(DevicePathFile)
        If MyFileName = "" Then Return ""
        MyExtension = Path.GetExtension(DevicePathFile)



        MyCurrent = 1
        MyCurrentPath(MyCurrent) = Dir(MyPath & "*", FileAttribute.Directory)
        If MyCurrentPath(MyCurrent) <> "" Then
            If MyRight(MyCurrentPath(MyCurrent), 1) <> "\" Then MyCurrentPath(MyCurrent) = MyCurrentPath(MyCurrent) & "\"

            While MyCurrentPath(MyCurrent) <> "" And MyCurrentPath(MyCurrent) <> MyPath
                If FileIgnoreList(MyCurrentPath(MyCurrent)) = True Then
                    MyCurrentPath(MyCurrent) = ""
                Else
                    MyCurrent += 1
                End If
                ReDim Preserve MyCurrentPath(MyCurrent)
                MyCurrentPath(MyCurrent) = MyPath & Dir() ' Get the next directory
                If MyCurrentPath(MyCurrent) <> "" Then
                    If MyRight(MyCurrentPath(MyCurrent), 1) <> "\" Then MyCurrentPath(MyCurrent) = MyCurrentPath(MyCurrent) & "\"
                End If
            End While

        End If


        For MyCurrent = MySizeOf(MyCurrentPath) To LBound(MyCurrentPath) Step -1
            If MyCurrentPath(MyCurrent) <> "" And MyCurrentPath(MyCurrent) <> MyPath Then
                WhereIsFile = MyCurrentPath(MyCurrent) & MyFileName & MyExtension
                WhereIsFile = FindFileName(WhereIsFile)  'search all of the sub directories
                If WhereIsFile <> "" Then Return WhereIsFile
            End If
        Next


        Return "" ' Not found anywhere (OK, anywhere I looked)
    End Function






    'This starts the other program to Init(When language is selected), preprocess(The entire file into the clipboard?), Post Process(From the clipboard? to file(s?))
    'breaking them up into files, will require a drilldown to be put back in.
    Friend Function FCCL_Init() As String
        Dim Temp As String

        If MyOptionTest(18) = True Then
            Return ""
        End If
        If MyDebug(A_NOTICE) Then logA(2589)
        '''''FlowChartWindow.Show()
        '''''Library.Show()
        '''''FileInputOutputWindow.Show()
        '''''OptionsWindow.Show()

        'TODO stop the old one if any 
        'todo set the fc processID to -1 in Init() to flag that nothing is started
        'todo if fc processID is running then clipboard /FCFinish
        'todo then wait for it to finish
        'todo then start up the new process
        'fight now it just starts a new one
        'start the new language processor
        'PutClipBoard("/FCInit")
        Temp = MyUniverse.MyDir_s.Languages & "\" & MyUniverse.ProgramOptions.FCCL_LanguageClassName & ".exe"
        MyUniverse.MySystem.FCProcessID = MyShell(Temp) 'NoWait, 1000 wait if true
        If MyUniverse.MySystem.FCProcessID < 0 Then
            Temp = "\Program Files\FC" & MyUniverse.ProgramOptions.FCCL_LanguageClassName & ".exe"
            MyUniverse.MySystem.FCProcessID = MyShell(Temp) 'NoWait, 1000 wait if true
            If MyUniverse.MySystem.FCProcessID < 0 Then
                Temp = "\Program Files (x86)\FC" & MyUniverse.ProgramOptions.FCCL_LanguageClassName & ".exe"
                MyUniverse.MySystem.FCProcessID = MyShell(Temp) 'NoWait, 1000 wait if true
            End If
        End If

        If MyUniverse.MySystem.FCProcessID < 0 Then
            MsgBox(1055, MsgBoxStyle.Critical, Temp)
            Return ""
            Exit Function
        End If
        Return ""
    End Function



    'Test to see if these two Line/square objects overlap each other
    'todo need to add to make sure they are at least ...  distance apart
    'todo needs to also check if this is in a symbol (cant route them them (as it currently does)
    Friend Function ROUTER_IsPathOnPath(ByRef SourceForm As Source, a As MyLineStructure, b As MyLineStructure) As Boolean
        Dim X As MyLineStructure = Nothing
        Dim Y As MyLineStructure = Nothing

        logA(2345, "Router Is Path On Path? ", MyShow2Lines(a, b))
        If MyOptionTest(34) Then
            MyReSizeWorld(SourceForm, a)
            MyReSizeWorld(SourceForm, b)
            MyReSizeWorld(SourceForm, MinMaxIt(a, b))
            PanToWorldXY(SourceForm, CenterOf2Lines(a, b).x, CenterOf2Lines(a, b).y)
            MyDrawBox(SourceForm, MinMaxIt(a, b))
            MyDrawLineXY_XY(SourceForm, a, RandomColor(SourceForm)) 'existing paths
            MyDrawLineXY_XY(SourceForm, b, "GREEN")
            MyDrawPathsPossible(SourceForm, a, b)
        End If
        X.a.x = MyMin(a.a.x, a.b.x)
        X.b.x = MyMax(a.a.x, a.b.x)
        X.a.y = MyMin(a.a.y, a.b.y)
        X.b.y = MyMax(a.a.y, a.b.y)
        If MyOptionTest(34) Then
            MyDrawPathsPossible(SourceForm, a, b)
            MyDrawLineXY_XY(SourceForm, X, RandomColor(SourceForm))
            MyDrawLineXY_XY(SourceForm, a.a.x, a.a.y, a.b.x, a.b.y, RandomColor(SourceForm))
        End If
        Y.a.x = MyMin(b.a.x, b.b.x)
        Y.b.x = MyMax(b.a.x, b.b.x)
        Y.a.y = MyMin(b.a.y, b.b.y)
        Y.b.y = MyMax(b.a.y, b.b.y)
        If MyOptionTest(34) Then
            MyDrawPathsPossible(SourceForm, X, Y)
            MyDrawLineXY_XY(SourceForm, Y, "green")
            WW3_My_Draw_Line_Or_Path(SourceForm, X, RandomColor(SourceForm), 4)
            WW3_My_Draw_Line_Or_Path(SourceForm, Y, RandomColor(SourceForm), 4)
            MyDrawPathsPossible(SourceForm, X, Y)
        End If
        If X.b.x < Y.a.x And X.b.x < Y.a.x Then

            Return False 'A is all left B
        End If
        'Is A all right of B
        If X.a.x > Y.b.x And X.a.x > Y.b.x Then

            Return False 'A is right of B
        End If

        If MyOptionTest(34) Then
            WW3_My_Draw_Line_Or_Path(SourceForm, X, RandomColor(SourceForm), 8)
            WW3_My_Draw_Line_Or_Path(SourceForm, Y, RandomColor(SourceForm), 8)
        End If
        'is A all above B
        If X.a.y < Y.b.y And X.b.y < Y.a.y Then

            Return False 'A is all left B
        End If
        'Is A all below B
        If X.a.y > Y.b.y And X.a.y > Y.b.y Then

            Return False 'A is right of B
        End If
        If MyDebug(A_DEBUG) Then logA(2595, MyShow2Lines(X, Y), MyShow2Lines(a, b))

        Return True
    End Function ' returns true if these are not on top of each other


    Friend Function Router_FindPoint(ByRef SourceForm As Source, IndexFlowChart1 As Integer, IndexFlowChart2 As Integer) As Boolean
        Return DoesFlowChartPathMatch(SourceForm, IndexFlowChart1, IndexFlowChart2)
    End Function

    Friend Function Router_MakePaths(ByRef SourceForm As Source, ByRef Connected As String, ByRef PathPoints As String) As Boolean
        Dim Routed, Unrouted As String
        Dim I, J, K As Integer

        Routed = Connected

        While Len(Routed) > 0
            Unrouted = PathPoints
            I = PopNonZeroValue(Routed)

            While Len(Unrouted) > 0
                ' Find if this is connected to any of the connected paths
                J = PopNonZeroValue(Unrouted)
                If Router_FindPoint(SourceForm, I, J) = True Then
                    If MyOptionTest(34) Then
                        PanToWorldXY(SourceForm, CenterOf2Lines(MyLine(SourceForm, I), MyLine(SourceForm, J)).x, CenterOf2Lines(MyLine(SourceForm, I), MyLine(SourceForm, J)).y)
                        PaintAll(SourceForm, I, I)
                        PaintAll(SourceForm, J, J)
                    End If
                    Connected &= FD & J.ToString & FD
                    PathPoints = RemoveNumberFromTextList(PathPoints, J)



                    Return True
                End If
            End While

        End While



        'So make a path from the routed to the first unrouted
        Routed = Connected
        Unrouted = PathPoints
        I = PopNonZeroValue(Routed)
        J = PopNonZeroValue(Unrouted)
        If MyOptionTest(34) Then PanToWorldXY(SourceForm, CenterOf2Lines(MyLine(SourceForm, I), MyLine(SourceForm, J)).x, CenterOf2Lines(MyLine1(SourceForm, I), MyLine1(SourceForm, J)).y)
        K = AddNEWFlowChartRecordPath(SourceForm, FlowChart_TablePathName(SourceForm, I), "/Path",
                                      FlowChart_TableX2(SourceForm, I),
                                      FlowChart_TableY2(SourceForm, I),
                                      FlowChart_TableX2(SourceForm, J),
                                      FlowChart_TableY2(SourceForm, J), FlowChart_TableDataType(SourceForm, I))
        If MyOptionTest(34) Then
            PaintAll(SourceForm, I, I)
            PaintAll(SourceForm, J, J)
            PaintAll(SourceForm, K, K)
        End If

        Return False ' no connection between connected and path points (which are a list of the flowchart record #'s of paths
    End Function

    Friend Function Router_Connect(ByRef SourceForm As Source, NetIndex As Integer) As Boolean
        Dim Routed, Unrouted As String
        Dim IndexFlowChart As Integer

        Unrouted = Net_TableLinks(NetIndex)
        IndexFlowChart = PopNonZeroValue(Unrouted)
        Routed = FD & IndexFlowChart.ToString & FD
        Router_MakePaths(SourceForm, Routed, Unrouted)

        Return False
    End Function

    Friend Function Router_StartRoute(ByRef SourceForm As Source, IndexFC As Integer) As Boolean
        Dim XYXY1 As MyLineStructure
        Dim A1, A2 As String
        Dim I1, I2, I3 As Integer

        If FlowChart_TableCode(SourceForm, IndexFC) <> "/path" Then

            Return False 'this is not a path to be routed to 
        End If
        XYXY1 = FlowChart2Line(SourceForm, IndexFC)
        A1 = Router_GetListOfPaths(SourceForm, IndexFC) ' this get the list of paths that have this path name

        While Len(A1) > 0
            I1 = PopNonZeroValue(A1) ' get first path
            A2 = Router_GetListOfPaths(SourceForm, IndexFC) ' this get the list of paths that have this path name

            While Len(A2) > 0
                I2 = PopNonZeroValue(A2) ' get next path
                If I1 <> I2 Then ' do not route to itself
                    I3 = AddFlowChartRecordPath(SourceForm, FlowChart_TablePathName(SourceForm, I1), "/Path", MyLineXY(MyLine1(SourceForm, I1).b, MyLine1(SourceForm, I2).b), FlowChart_TableDataType(SourceForm, IndexFC))
                    PaintAll(SourceForm, I3, I3)
                    If ZeroZero(Router_AutoRoute(SourceForm, I1, I2)) Then ' find or make a path between these two


                        Return True ' a path is made
                    Else
                        logA(1769, A1, A2, I1.ToString, I2.ToString)
                    End If
                End If 'same?
            End While ' Try another connection

        End While ' continue through all of the other paths to make sure you have a connection


        Return False
    End Function



    Friend Function DD(A1 As MyLineStructure, B1 As MyLineStructure) As MyPointStructure
        Dim A2 As MyPointStructure = Nothing
        Dim B2 As MyPointStructure = Nothing
        A2.x = MyDistance(A1.a, B1.a)
        A2.y = MyDirection(A1.a, B1.a)

        B2.x = MyDistance(A1.a, B1.b)
        B2.y = MyDirection(A1.a, B1.b)
        If A2.x < B2.x Then A2.x = B2.x : A2.y = B2.y

        B2.x = MyDistance(A1.b, B1.a)
        B2.y = MyDirection(A1.b, B1.a)
        If A2.x < B2.x Then A2.x = B2.x : A2.y = B2.y

        B2.x = MyDistance(A1.b, B1.b)
        B2.y = MyDirection(A1.b, B1.b)
        If A2.x < B2.x Then A2.x = B2.x : A2.y = B2.y
        Return A2
    End Function
    Friend Function Direction(A As MyLineStructure, B As MyLineStructure) As MyLineStructure
        Direction = Nothing
        Direction.a.x = MyDirection(A.a, B.a)
        Direction.a.y = MyDistance(A.a, B.b)
        Direction.b.x = MyDirection(A.b, B.a)
        Direction.b.y = MyDistance(A.b, B.b)
    End Function

    'This will return the number of paths for this path name
    Friend Function CountMin(ByRef SourceForm As Source, PathName As String) As Integer
        Dim I As Integer
        CountMin = 0

        For I = 1 To TopOfListBox(SourceForm.ListBoxFlowChart)
            If FlowChart_TablePathName(SourceForm, I) = PathName Then CountMin += 1
        Next

        Return CountMin
    End Function


    'find and make
    ' this will try to find a path connecting these two points, and if failed then makes path(s) between these points
    Friend Function Router_FindPath(ByRef SourceForm As Source, A As MyPointStructure, B As MyPointStructure) As MyPointStructure

        Router_FindPath = Router_IsPathClear(SourceForm, A, B) ' try to find a clear path
        If ZeroZero(Router_FindPath) = False Then  ' try to find a clear path

            Return MyUniverse.MyStaticData.ZeroZero ' Not a path between these two points
        Else

            Return B ' these two points have a clear path between them (or up to them )
        End If

    End Function


    Friend Function Router_FindOrMakePath(ByRef SourceForm As Source, A As MyPointStructure, B As MyPointStructure, IndexNets As Integer) As MyPointStructure
        Dim P1 As MyPointStructure = Nothing
        Dim P2 As MyPointStructure = Nothing
        Dim P3 As MyPointStructure = Nothing

        WW3_My_Draw_Line_Or_Path(SourceForm, MyLine1(SourceForm, A, B), RandomColor(SourceForm), 1)
        If A.x <> B.x Or A.y <> B.y Then
            P1 = A
            P2 = B
            P3 = B
            WW3(SourceForm, P1, P2, P3, RandomColor(SourceForm))
            If A.x <> B.x Then
                P2.y = P1.y
                P3.x = P1.x
            End If
            WW3(SourceForm, P1, P2, P3, RandomColor(SourceForm))
            If A.y <> B.y Then
                P2.x = P1.x
                P3.y = P1.y
            End If
            WW3(SourceForm, P1, P2, P3, RandomColor(SourceForm))
            P1 = Router_FindOrMakePath(SourceForm, A, P2, IndexNets)
            WW3(SourceForm, P1, P2, P3, RandomColor(SourceForm))
            If ZeroZero(P1) Then
                P1 = Router_FindOrMakePath(SourceForm, A, P3, IndexNets)
                WW3(SourceForm, P1, P2, P3, RandomColor(SourceForm))
                If ZeroZero(P1) Then Return MyUniverse.MyStaticData.ZeroZero
            End If
        End If
        Router_FindOrMakePath = Router_IsPathClear(SourceForm, A, B) ' try to find a clear path
        If ZeroZero(Router_FindOrMakePath) = False Then ' test if a clear path was found
            ' A clear path was found so make a path segment, and then return to make all of the path segments to get here
            logA(4315, MyUniverse.MyStaticData.LastDataType)
            AddFlowChartRecordPath(SourceForm, "Errored", "/path", MyLine1(SourceForm, A, Router_FindOrMakePath), "Errored")
            P1 = Router_IsPathClear(SourceForm, Router_FindOrMakePath, B)
            P2 = Router_IsPathClear(SourceForm, P1, B)
        Else
            WW3(SourceForm, P1, P2, P3, RandomColor(SourceForm))

            Return Router_FindOrMakePath
        End If

        WW3(SourceForm, P1, P2, P3, RandomColor(SourceForm))

    End Function


    'returns zeroZero if fails
    Friend Function Router_AutoRoute(ByRef SourceForm As Source, Index1 As Integer, Index2 As Integer) As MyPointStructure
        Dim J, K As Integer
        Dim X1, Y1, X2, Y2 As Integer
        Dim L As MyPointStructure
        Dim SPath, EPath As MyLineStructure

        Router_AutoRoute = Nothing
        SPath = FlowChart2Line(SourceForm, Index1)
        EPath = FlowChart2Line(SourceForm, Index2)

        If FlowChart_TableCode(SourceForm, Index1) <> "/path" Then

            Return MyUniverse.MyStaticData.ZeroZero
        End If
        If FlowChart_TableCode(SourceForm, Index2) <> "/path" Then

            Return MyUniverse.MyStaticData.ZeroZero
        End If

        PanToWorldPP(SourceForm, CenterOf2Lines(MyLine1(SourceForm, Index1), MyLine1(SourceForm, Index2)), CenterOf2Lines(MyLine1(SourceForm, Index1), MyLine1(SourceForm, Index2)))

        'this return the direction (as X) and the distance (As Y) (for all four possible connections)
        J = CountMin(SourceForm, FlowChart_TablePathName(SourceForm, Index1)) ' returns the count of the paths with this name
        K = CountMin(SourceForm, FlowChart_TablePathName(SourceForm, Index2)) ' counts the number of paths with this name
        L = DD(FlowChart2Line(SourceForm, Index1), FlowChart2Line(SourceForm, Index2)) 'return direction (as x) and distance (as Y)


        If FlowChart_Table(SourceForm, Index1) <> FlowChart_Table(SourceForm, Index2) Then
            logA(1817, FlowChart_Table(SourceForm, Index1), FlowChart_Table(SourceForm, Index2).ToString)
        End If

        X1 = FlowChart_TableX1(SourceForm, Index1)
        Y1 = FlowChart_TableY1(SourceForm, Index1)
        X2 = FlowChart_TableX2(SourceForm, Index2)
        Y2 = FlowChart_TableY2(SourceForm, Index2)

    End Function

    Friend Function Router_GetListOfPaths(ByRef SourceForm As Source, IndexFC As Integer) As String
        Return Net_TableLinks(FindNetName(FlowChart_TablePathName(SourceForm, IndexFC)))
    End Function

    Friend Function Router_IsPathClear(ByRef SourceForm As Source, A As MyPointStructure, B As MyPointStructure) As MyPointStructure
        Dim I As Integer
        ' for now just look at everything

        If A.x <> B.x And A.y <> B.y Then

            Return MyUniverse.MyStaticData.ZeroZero
        End If
        For I = 1 To TopOfListBox(SourceForm.ListBoxFlowChart)
            '''''ShowProgressBar(1, I, TopOfListBox(SourceForm.ListBoxFlowChart))
            If FlowChart_TableCode(SourceForm, I) = "/path" Then
                If PathOnTopHere(SourceForm, MyLine1(SourceForm, A, B), FlowChart2Line(SourceForm, I)) Then
                    Return MyUniverse.MyStaticData.ZeroZero
                End If
            End If
        Next

        Return B ' return how far it got
    End Function

    'Routine number is positive to start a Routine, and negative to stop a routine (Ignore recursive for now)
    'list of unused numbers
    '  153-155 167 170 172 174 177-999 36-49 61 76 87 88
    ' used other places 24, 25, 32, 32 (used twice) 
    '46 - 49, 61,76,87 - 88,130,133,153 - 155,167,169 - 170,172,174,177 - 
    'start but no stopped -----> '-324,-1,0,200,201,201,202,203,203,204,204,205,205,206,206,207,208,209,210,211,213,214,215,216,217,218,219,220,222,223,223,224,225,226,227,228,229,230,231,232,233,234,235,235,236,236,237,237,238,238,239,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,298,299,300,301,302,303,305,306,307,308,309,310,311,312,313,314,314,315,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,339,340,341,342,343,344,345,346,347,348,349,350,351,352,353,354,355,356,357,358,359,360,361,362,363,364,365,366,367,368,369,370,371,372,373,374,375,376,377,378,379,380,381,382,383,384,385,386,387,388,389,390,391,392,393,394,395,396,397,398,399
    '

    ''' <summary>
    ''' 
    ''' </summary>
    ''' <param name="MyRootDir"></param>
    ''' <returns></returns>
    Friend Function FindLanguageClassName(MyRootDir As String) As String
        Dim A, X As String
        Dim KCounter As Integer
        Dim SubDirectories(0) As String

        If MyDebug(A_INFORMATION) Then
            logA(4010, MyRootDir)
        End If
        If MyInStr("\\", MyRootDir) <> 0 Then

            Return Nothing
        End If
        If MyDebug(A_INFORMATION) Then
            logA(2602, MyRootDir)
        End If
        'first find the directory
        A = MyUniverse.ProgramOptions.FCCL_LanguageClassName
        X = Dir(MyRootDir & "\*.", FileAttribute.Directory)
        If MyDebug(A_INFORMATION) Then logA(1819, MyRootDir & "\" & A & COMMA & X)

        While X <> "" And MyInStr(FD & A, X) = 0
            If MyDebug(A_INFORMATION) Then logA(1819, MyRootDir & "\" & A & COMMA & X)
            SubDirectories(MySizeOf(SubDirectories)) = X
            If MyDebug(A_INFORMATION) Then logA(1819, MyRootDir & "\" & A & COMMA & X)
            If FileNameOnly(X) = MyUniverse.ProgramOptions.FCCL_LanguageClassName Then
                If MyDebug(A_INFORMATION) Then logA(1819, MyRootDir & "\" & A & COMMA & X)


                Return MyRootDir & "\" & X
            End If
            ReDim Preserve SubDirectories(MySizeOf(SubDirectories) + 1)
            X = Dir()
            If MyDebug(A_INFORMATION) Then logA(1819, MyRootDir & "\" & A & COMMA & X)
        End While


        For KCounter = LBound(SubDirectories) To MySizeOf(SubDirectories)
            X = FindLanguageClassName(MyRootDir & SubDirectories(KCounter) & "\")
            If MyDebug(A_INFORMATION) Then logA(1819, MyRootDir & "\" & A & COMMA & X)
            If Len(X) > 0 Then

                Return X
            End If
        Next KCounter

        'second find the file

        Return Nothing
    End Function





End Module
